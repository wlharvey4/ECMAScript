# -*- mode: org; -*-
#+Title:ECMAScript 262
#+Date:2019-11-08 02:02
#+macro:version 0.5.62

* JavaScript Versions
** JavaScript 1.0
#+cindex:JavaScript 1.0
JavaScript was released as version 1.0 in March 1996 in Netscape Navigator 2.0
and Internet Explorer 2.0.

** JavaScript 1.1
Version shipped in Netscape Navigator 3.0. Released on August 19, 1996.

** JavaScript 1.2
Version shipped in Netscape Navigator 4.0-4.05. Released on June 11, 1997.

** JavaScript 1.3
Version shipped in Netscape Navigator 4.06-4.7x. Released on October 19, 1998.
Standardization work to be compliant with ECMA-262 1st and 2nd Edition.

** JavaScript 1.4
Version shipped with Netscape's server-side JavaScript. Released in 1999.

** JavaScript 1.5
Version shipped in Netscape Navigator 6.0 and Firefox 1.0. Release on November
14, 2000.  Standardization work to be compliant with ECMA-262 3rd Edition.

** JavaScript 1.6
Version shipped in Firefox 1.5. Released in November 2005.  Includes ECMAScript
for XML (E4X), new Array methods plus String and Array generics.

** JavaScript 1.7
Version shipped in Firefox 2. Released in October 2006.  Includes generators,
iterators, array comprehensions, let expressions, and destructuring assignment.

** JavaScript 1.8
Version shipped in Firefox 3. Released in June 2008.  Includes expression
closures, generator expressions and Array.reduce()

** JavaScript 1.8.1
Version shipped in Firefox 3.5. Released on June 30, 2009.  Includes the
TraceMonkey JIT and supports native JSON.

** JavaScript 1.8.2
Version shipped in Firefox 3.6. Released June 22, 2009.  Includes only minor
changes.

** JavaScript 1.8.5
Version shipped in Firefox 4. Released July 27, 2010.  Includes many new
features for ECMA-262 Edition 5 compliance.  This is the last JavaScript
version.
* ECMAScript Description
#+cindex:Eich, Brendan
#+cindex:specification, ECMAScript
#+cindex:ECMAScript specification
The ECMAScript specification is a standardized specification of a scripting
language developed by Brendan Eich of Netscape.

#+cindex:ECMA-262
#+cindex:ISO/IEC 16262
#+cindex:Spikdermonkey
ECMAScript is a scripting language specification standardized by ECMA
International in ECMA-262 and ISO/IEC 16262.  It was created to standardize
JavaScript (``Spidermonkey''), so as to foster multiple independent
implementations.  Other implementations include
  #+cindex:JScript
- JScript (Microsoft)
  #+cindex:ActionScript
- ActionScript (Macromedia Inc.; Adobe)


{{{heading(Built-In Types)}}}

#+cindex:object-based language
#+cindex:object definition
#+cindex:properties
#+cindex:attributes
#+cindex:primitive values
#+cindex:built-in types
ECMAScript is *object-based*: basic language and host facilities are provided
by /objects/, and an ECMAScript program is a cluster of communicating objects.
An ECMAScript *object* is a collection of /properties/ each with zero or more
/attributes/ that determine how each property can be used.  *Properties* are
containers that hold other /objects/, /primitive values/, or /functions/.  A
*primitive value* is a member of one of the following built-in types:
- Undefined
- Null
- Boolean
- Number
- String


#+cindex:Object type
An *object* is a member of the remaining built-in type
- Object


#+cindex:function
#+cindex:callable object, function
#+cindex:object, callable, function
#+cindex:method
And a *function* is a /callable object/.  A *method* is a function that is
associated with an object via a property.

{{{heading(Built-in Objects)}}}

#+cindex:built-in objects
#+cindex:objects, built-in
ECMAScript defines a collection of *built-in objects* that round out the
definition of ECMAScript entities.  These built-in objects include:
- the global object
- the Object object
- the Function object
- the Array object
- the String object
- the Boolean object
- the Number object
- the Math object
- the Date object
- the RegExp object
- the JSON object
- the Error objects
  - EvalError
  - RangeError
  - ReferenceError
  - SyntaxError
  - TypeError
  - URIError


{{{heading(Built-In Operators)}}}

#+cindex:built-in operators
#+cindex:operators, built-in
ECMAScript also defines a set of *built-in operators*.  ECMAScript operators
include:
- unary operators
- multiplicative operators
- additive operators
- bitwise shift operators
- relational operators
- equality operators
- binary bitwise operators
- binary logical operators
- assignment operators
- comma operator


{{{heading(ECMAScript Syntax)}}}

#+cindex:syntax
*ECMAScript syntax* intentionally resembles Java syntax.  ECMAScript syntax is
relaxed to enable it to serve as an easy-to-use scripting language.

** Version Numbers

   | Year | JavaScript |      ECMA      | Browser            |
   |      |    <c>     |      <c>       |                    |
   |------+------------+----------------+--------------------|
   | 1996 |    1.0     |                | Netscape 2         |
   | 1997 |            |      ES1       | IE 4               |
   | 1998 |    1.3     |                | Netscape 4         |
   | 1999 |            |      ES2       | IE 5               |
   | 2000 |            |      ES3       | IE 5.5             |
   | 2000 |    1.5     |                | Firefox 1          |
   | 2009 |            |      ES5       |                    |
   | 2011 |            |      ES5.1     | IE 9[fn:1]         |
   | 2011 |   1.8.5    |                | Firefox 4[fn:2]    |
   | 2012 |            |                | IE 10              |
   | 2012 |            |                | Chrome 23          |
   | 2012 |            |                | Safari 6           |
   | 2013 |            |                | Firefox 21         |
   | 2013 |            |                | Opera 15           |
   | 2015 |            |     ES2015     | All browsers[fn:3] |
   |      |            | (formerly ES6) |                    |
   | 2016 |            |     ES2016     |                    |
   | 2017 |            |     ES2017     |                    |
   | 2018 |            |     ES2018     |                    |
   |------+------------+----------------+--------------------|

** ECMAScript History

   - 1993 ::
     - NCSA’s *Mosaic* was the first widely popular web browser.

   - 1994 ::
     - a company called *Netscape* was founded to exploit the potential of the
       nascent World Wide Web.
     - Netscape created the proprietary web browser *Netscape Navigator*,
     - Many of the original Mosaic authors went on to work on Navigator, but
       the two intentionally shared no code.
     - Netscape quickly realized that the Web needed to become more dynamic.

   - 1995 ::
     - Netscape hired *Brendan Eich* with the promise of letting him implement
       Scheme (a Lisp dialect) in the browser.
     - Before he could get started, Netscape collaborated with hardware and
       software company *Sun* (since bought by Oracle) to include its more
       static programming language, *Java*, in Navigator.
     - As a consequence, a hotly debated question at Netscape was why the Web
       needed two programming languages: Java and a scripting language.
     - Netscape management decided that a scripting language had to have a
       syntax similar to Java’s.
     - That ruled out adopting existing languages such as Perl, Python, TCL, or
       Scheme.
     - To defend the idea of JavaScript against competing proposals, Netscape
       needed a prototype. Eich wrote one in 10 days.
     - JavaScript’s first code name was *"Mocha"*.
     - Netscape marketing later changed it to *"LiveScript"*, for trademark
       reasons and because the names of several products already had the prefix
       “Live.”
     - In late November 1995, *Navigator 2.0B3* came out and included the
       prototype, which continued its early existence without major changes.
     - In early December 1995, Java’s momentum had grown and the language was
       renamed again, to its final name, *JavaScript*.

   - 1996 ::
     - *Microsoft* implemented the same language, under the different
       name *JScript*, in Internet Explorer 3.0
     - Partially to keep Microsoft in check, Netscape decided to standardize
       JavaScript and asked the standards organization *Ecma International* to
       host the standard.
     - Work on a specification called *ECMA-262* started.
     - Because Sun (now Oracle) had a trademark on the term JavaScript, it
       couldn’t be the official name of the language to be standardized. Hence,
       *ECMAScript* was chosen, derived from JavaScript and Ecma.
     - However, that name is used only to refer to versions of the language
       (where one refers to the specification).  Everyone still calls the
       language *JavaScript*.
       #+cindex:TC39
     - *ECMA-262* is managed and evolved by Ecma’s *Technical Committee 39
       (TC39)*.  [[https://tc39.es][TC39]]

   - 1997 ::
     - ECMAScript 1 *First Edition*
     - *Dynamic HTML*: allows you to dynamically change the content and
       appearance of a web page, achieved by manipulating the Document Object
       Model (DOM) of the page, a tree-shaped data structure.  Things that can
       be done include: changing content, changing style, and showing and
       hiding elements.  First in Internet Explorer 4 and in Netscape
       Navigator 4.

   - 1998 ::
     - ECMAScript 2 --- Editorial changes to align ECMA-262 with the standard
       ISO/IEC 16262

   - 1999 ::
     - ECMAScript 3 --- ~do-while~, regular expressions, new string methods
       (~concat~, ~match~, ~replace~, ~slice~, ~split~ with a regular
       expression, etc.), exception handling, and more
     - *XMLHttpRequest*: lets a client-side script send an HTTP or HTTPS
       request to a server and get back data, usually in a text format (XML,
       HTML, JSON).  Introduced in Internet Explorer 5.

   - 2001 ::
     - *JSON*: a JavaScript-based data exchange format.  *Douglas Crockford*
       named and documented JSON (JavaScript Object Notation), whose main idea
       is to use JavaScript syntax to store data in text format.  JSON uses
       JavaScript literals for objects, arrays, strings, numbers, and booleans
       to represent structured data.

   - 2004 ::
     - *Dojo Toolkit*: a framework for programming JavaScript in the large.
       The Dojo Toolkit facilitates programming in the large by providing the
       necessary infrastructure: an inheritance library, a module system, an
       API for desktop-style graphical widgets, and more.
       - https://dojotoolkit.org
       - https://github.com/dojo/dojo

   - 2005 ::
     - *AJAX* (/Asynchronous JavaScript and XML/): browser-based desktop-class
       applications.  Ajax is a collection of technologies that brings a level
       of interactivity to web pages that rivals that of desktop applications.
       The two cornerstones of Ajax are:
       1. loading content asynchronously in the background (via
          ~XMLHttpRequest~); and
       2. dynamically updating the current page with the results (via /dynamic
          HTML/).

       [[https://www.adaptivepath.com/ideas/ajax-new-approach-web-applications/][Ajax: A New Approach to Web Applications]] February 18, 2005 | By Jesse
       James Garrett

       Ajax marked the mainstream breakthrough of JavaScript and dynamic web
       applications.  It is interesting to note how long that took—at that
       point, the Ajax ingredients had been available for years.  Since the
       inception of Ajax, other data formats have become popular (JSON instead
       of XML), other protocols are used (e.g., Web Sockets in addition to
       HTTP), and bidirectional communication is possible. But the basic
       techniques are still the same.

       The term Ajax is used much less these days and has mostly been replaced
       by the more comprehensive terms *HTML5* and *Web Platform* (which both
       mean /JavaScript plus browser APIs/).

     - *Apache CouchDB*: a JavaScript-centric database.  Roughly, CouchDB is a
       JSON database: you feed it JSON objects, without the need to specify a
       schema in advance. Additionally, you can define views and indexes via
       JavaScript functions that perform map/reduce operations. Hence, CouchDB
       is a very good fit for JavaScript because you can work directly with
       native data.  Compared to a /relational database/, there is no
       mapping-related impedance mismatch.  Compared to an /object database/,
       you avoid many complications because only data is stored, not behavior.

       CouchDB is just one of several similar *NoSQL databases*.  Most of them
       have excellent JavaScript support.

       - http://couchdb.apache.org
       - https://github.com/apache/couchdb

   - 2006 ::
     - *jQuery*: helping with DOM manipulation.  The browser DOM is one of the
       most painful parts of client-side web development.  jQuery made DOM
       manipulation fun by abstracting over browser differences and by
       providing a powerful fluent-style API for querying and modifying the
       DOM.

   - 2007 ::
     - *WebKit*: aking the mobile web mainstream.  Based on prior work by KDE,
       WebKit is an /HTML engine/ that was introduced by Apple in 2003.  It was
       open-sourced in 2005.  With the introduction of the iPhone in 2007, the
       mobile Web suddenly became mainstream and had little to no limitations
       compared to the nonmobile Web.

   - 2008 ::
     - ECMAScript 4 (Abandoned)

       ECMAScript 4 was developed as the next version of JavaScript, with a
       prototype written in ML.  However, TC39 could not agree on its feature
       set.  To prevent an impasse, the committee met at the end of July 2008
       and came to an accord, summarized in four points:

       1. Develop an incremental update of ECMAScript 3 (which became
          *ECMAScript 5*).

       2. Develop a major new version that does less than ECMAScript 4, but
          much more than the incremental update of ECMAScript 3. The code name
          for the new version is *Harmony*, due to the nature of the meeting in
          which it was conceived.  Harmony will be split into ECMAScript 6 and
          ECMAScript 7.

       3. Features from ECMAScript 4 that would be *dropped* included
          /packages/, /namespaces/, and /early binding/.

       4. Other ideas were to be developed in consensus with all of TC39.

       Thus, the ECMAScript 4 developers agreed to make Harmony less radical
       than ECMAScript 4, and the rest of TC39 agreed to keep moving things
       forward.

   - V8 :: proving JavaScript can be fast.  When Google introduced its Chrome
     web browser, one of its highlights was a fast JavaScript engine called V8.
     It changed the perception of JavaScript as being slow and led to a speed
     race with other browser vendors from which we are still profiting.  V8 is
     open source and can be used as a standalone component whenever you need a
     fast embedded language that is widely known.

   - 2009 ::
     - ECMAScript 5 --- Adds a strict mode, getters and setters, new array
       methods, support for JSON, and more

     - *Node.js*: implementing JavaScript on the server.  Created by Ryan Dahl,
       Node.js lets you implement servers that perform well under load.  To do
       so, it uses /event-driven/, /nonblocking I/O/ and /JavaScript/ (via V8).
       JavaScript was chosen for some of the following reasons:
       - “Because it’s bare and does not come with I/O APIs.” [Node.js can thus
         introduce its own nonblocking APIs.]
       - “Web developers use it already.” [JavaScript is a widely known
         language, especially in a web context.]
       - “DOM API is event-based.  Everyone is already used to running without
         threads and on an event loop.” [Developers are used to an asynchronous
         coding style.]

       The appeal of Node.js for JavaScript programmers goes beyond being able
       to program in a familiar language; you get to use the same language on
       both client and server.  That means you can share more code (e.g., for
       validating data) and use techniques such as isomorphic
       JavaScript. Isomorphic JavaScript is about assembling web pages on
       either client or server, with numerous benefits: pages can be rendered
       on the server for faster initial display, SEO, and running on browsers
       that either don’t support JavaScript or a version that is too old. But
       they can also be updated on the client, resulting in a more responsive
       user interface.

     - *PhoneGap*: writing native apps in HTML5.  The initial mission of
       PhoneGap was to make it possible to implement native mobile apps via
       HTML5. Since then, support has expanded to nonmobile operating
       systems. Currently supported platforms include Android, Bada,
       BlackBerry, Firefox OS, iOS, Mac OS X, Tizen, Ubuntu, Windows (desktop),
       and Windows Phone.

     - *Chrome OS*: making the browser the operating system.  With Chrome OS,
       the web platform is the native platform. This approach has several
       advantages:
       - It is much easier to create an operating system, because all of the
         user interface technology is already there.
       - Many developers already (mostly) know how to write apps for the
         operating system.
       - Managing apps is simple. That helps public installations such as
         Internet cafes and schools.

   - 2011 ::
     - ECMAScript 5.1 --- Editorial changes to align ECMA-262 with the third
       edition of the international standard ISO/IEC 16262:2011

     - *Windows 8*: first-class HTML5 apps.  Microsoft's Windows 8 has
       extensive integration with HTML5.  HTML5 applications are first-class
       citizens in Windows 8, on par with those implemented via incumbent
       technologies such as .NET and C++.

   - 2015 ::
     - ECMAScript 6
     - renamed to *ECMAScript 2015*
     - and *ES2015*
     - many new features added

   - 2016 ::
     - *ECMAScript 2016* (7th Edition)
     - exponentiation operator; ~Array.prototype.includes()~

   - 2017 ::
     - *ECMAScript 2017* (8th Edition)
     - concurrency; atomics; ~async/await~

   - 2018 ::
     - *ECMAScript 2018* (9th Edition)
     - asynchronous iteration and generators; new RegExp features; rest/spread
       parameters

** CommonJS

   The dominant incarnation of this standard is *Node.js modules* (Node.js
   modules have a few features that go beyond CJS).

   - http://www.commonjs.org
   - http://wiki.commonjs.org/wiki/CommonJS [fn:4]

   JavaScript is a powerful object oriented language with some of the fastest
   dynamic language interpreters around.  The official JavaScript specification
   defines APIs for some objects that are useful for building browser-based
   applications.  *However, the spec does not define a standard library that is
   useful for building a broader range of applications*.

   The CommonJS API will fill that gap by *defining APIs that handle many
   common application needs*, ultimately providing a standard library as rich
   as those of Python, Ruby and Java.  The intention is that an application
   developer will be able to write an application using the CommonJS APIs and
   then run that application across different JavaScript interpreters and host
   environments.

   With CommonJS-compliant systems, you can use JavaScript to write:

   - Server-side JavaScript applications
   - Command line tools
   - Desktop GUI-based applications
   - Hybrid applications (Titanium, Adobe AIR)

   [[https://arstechnica.com/information-technology/2009/12/commonjs-effort-sets-javascript-on-path-for-world-domination/][CommonJS effort sets JavaScript on path for world domination]] KRIS KOWAL -
   12/1/2009, 9:19 PM

** Prototype-Based Inheritance

{{{heading(Constructors)}}}

#+cindex:constructors
#+cindex:objects, from constructors
ECMAScript supports /constructors/ which create *objects* by executing code
that allocates storage for the objects and initialises all or part of them by
assigning initial values to their properties.

{{{subheading(Prototype Property)}}}

#+cindex:Prototype property
#+cindex:protype-based inheritance
#+cindex:inheritance, prototype-based
#+cindex:properties, shared
Each constructor has a =prototype= property that is used to implement
prototype-based inheritance and shared properties.

{{{subheading(new Expressions)}}}

#+cindex:@code{new} expressions
Objects are created by using constructors in ~new~ expressions.  Invoking a
constructor without using ~new~ has consequences that depend on the
constructor.  For example, =String("A String")= produces a primitive string,
not an object.

{{{heading(Prototype Chain)}}}

#+cindex:constructor
#+cindex:prototype
#+cindex:object
Every constructor has an associated prototype, and every object created by that
constructor has an /implicit/ reference to the prototype (called the object’s
prototype) associated with its constructor.  A prototype may have a non-null
implicit reference to its prototype, and so on.  This is called the prototype
chain.

{{{subheading(References to Properties)}}}

#+cindex:reference to property
When a reference is made to a property in an object, that reference is to the
property of that name in the first object in the prototype chain that contains
a property of that name.  In other words, first the object mentioned directly
is examined for such a property; if that object contains the named property,
that is the property to which the reference refers; if that object does not
contain the named property, the prototype for that object is examined next; and
so on.

{{{heading(State)}}}

#+cindex:state
#+cindex:inheritance
In a class-based object-oriented language, in general, state is carried by
instances, methods are carried by classes, and inheritance is only of structure
and behaviour. In ECMAScript, the state and methods are carried by objects, and
structure, behaviour, and state are all inherited.  All objects that do not
directly contain a particular property that their prototype contains share that
property and its value.

** Brief History of [ [ Prototype ] ]

#+cindex:@code{[[Prototype]]} history
There are now many ways to manage =[ [Prototype] ]=.  Why? For historical
reasons.

- =prototype= :: The =prototype= property of a constructor function has worked
               since very ancient times.

- =Object.create()= :: in the year 2012, ~Object.create()~ appeared in the
     standard.  It gave the ability to create objects with a given prototype,
     but did not provide the ability to get/set it.

- =__proto__= :: So browsers implemented the non-standard =__proto__= accessor
                 that allowed the user to get/set a prototype at any time.

- ~Object.getPrototypeOf()~ :: ECMAScript 5.1 (2012) defined the
     ~Object.getPrototypeOf()~ function to return an object’s =[ [Prototype] ]=
     property.

- ~Object.setPrototypeOf()~ :: ECMAScript 2015 defined the
     ~Object.setPrototypeOf()~ function to set an object’s =[ [Prototype] ]
     property.

** Programming Paradigms

JavaScript is multi-paradigm, object-oriented, and prototype-based, and has
dynamic typing; it treats functions as first-class citizens, and allows
functional programming styles.  These characteristics make JavaScript a very
versatile language, which gives tremendous power to the developer but at the
same time it causes a fragmentation of programming styles, conventions,
techniques, and ultimately the patterns of its ecosystem.

There are so many ways to achieve the same result using JavaScript that
everybody has their own opinion on what the best way is to approach a problem.
A clear demonstration of this phenomenon is the abundance of frameworks and
opinionated libraries in the JavaScript ecosystem; probably no other language
has ever seen so many, especially now that Node.js has given new astonishing
possibilities to JavaScript and has created so many new scenarios.

* ECMAScript Specifications
For JavaScript to be considered a valid version of ECMAScript, it must provide
mechanisms to support the syntax and semantics defined in the spec.  Once a
version of JavaScript conforms to ECMAScript, language designers are free to
embellish their version with extra features and methods as they see fit.

#+ATTR_TEXINFO: :options Note
#+begin_quotation
A conforming implementation of ECMAScript is permitted to provide additional
types, values, objects, properties, and functions beyond those described in
this specification. In particular, a conforming implementation of ECMAScript is
permitted to provide properties not described in this specification, and values
for those properties, for objects that are described in this specification. A
conforming implementation of ECMAScript is permitted to support program and
regular expression syntax not described in this specification.

#+TEXINFO: @author ECMAScript Specification
#+end_quotation

  [[http://www.ecma-international.org/publications/standards/Ecma-262.htm][Current edition]].

- [[https://github.com/tc39/ecma262][tc39/ecma262 on GitHub]]

  This repository contains the source for the current draft of ECMA-262, the
  ECMAScript® Language Specification.

  This source is processed to obtain a human-readable version, which you can
  view [[https://tc39.es/ecma262/][here]].

  #+cindex:first edition 1997
  #+cindex:ECMA-262 specification, first edition
  The first edition of ECMA-262 was adopted by the Ecma General Assembly in
  June 1997.  [[http://www.ecma-international.org/publications/standards/Ecma-262-arch.htm][Historical standards]].

** Edition 1

#+cindex:first edition Standard
June 1997.  [[https://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%25201st%2520edition,%2520June%25201997.pdf][First edition]]

``ECMAScript: A general purpose, cross-platform programming language''

Netscape 2 was the first browser to run JavaScript.  After Netscape the Mozilla
foundation continued to develop JavaScript for the Firefox browser.

** Edition 2

#+cindex:second edition
#+cindex:2nd edition
June 1998.  [[https://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%25202nd%2520edition,%2520August%25201998.pdf][2nd Edition]]

Editorial changes ``to keep it fully aligned with ISO/IEC 16262.''

** Edition 3

   December 1999.  [[https://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%25203rd%2520edition,%2520December%25201999.pdf][3rd Edition]] PDF

   ECMAScript 3 is fully supported in all browsers.

   - Regular expressions
   - better string handling
   - new control statements
   - try/catch exception handling
   - tighter definition of errors
   - formatting for numeric output

*** Brief History
- https://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf


#+cindex:Netscape JavaScript
#+cindex:Microsoft JScript
This ECMA Standard is based on several originating technologies, the most well
known being JavaScript (Netscape) and JScript (Microsoft).

#+cindex:Eich, Brendan
#+cindex:Netscape Navigator 2.0 browser
#+cindex:Internet Explorer 3.0
The language was invented by Brendan Eich at Netscape and first appeared in
that company’s Navigator 2.0 browser.  It has appeared in all subsequent
browsers from Netscape and in all browsers from Microsoft starting with
Internet Explorer 3.0.

#+cindex:ECMA General Assembly
#+cindex:first edition 1997
#+cindex:ECMA Standard, first edition
The development of this Standard started in November 1996.  The first edition of
this ECMA Standard was adopted by the ECMA General Assembly of June 1997.

#+cindex:ISO/IEC JTC 1
#+cindex:ISO/IEC 16262 international standard
That ECMA Standard was submitted to ISO/IEC JTC 1 for adoption under the
fast-track procedure, and approved as international standard ISO/IEC 16262, in
April 1998.

#+cindex:second edition ECMA-262, 1998
The ECMA General Assembly of June 1998 approved the second edition of ECMA-262
to keep it fully aligned with ISO/IEC 16262.  Changes between the first and the
second edition are editorial in nature.

#+cindex:third edition ECMA-262, 1999
The current document defines the third edition of the Standard and includes:
- powerful regular expressions,
- better string handling,
- new control statements,
- try/catch exception handling,
- tighter definition of errors,
- formatting for numeric output and
- minor changes in anticipation of forthcoming internationalisation facilities
  and future language growth.


Work on the language is not complete. The technical committee is working on
significant enhancements, including mechanisms for scripts to be created and
used across the Internet, and tighter coordination with other standards bodies
such as groups within the World Wide Web Consortium and the Wireless
Application Protocol Forum.

** Edition 4

   Abandoned.

** Edition 5

   December 2009.  [[https://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262%25205th%2520edition%2520December%25202009.pdf][5th Edition]] PDF

   ECMAScript 5 is fully supported in all /modern/ browsers.

   - [[http://kangax.github.io/compat-table/es5/][ES5 compatibility table]]
   - [[https://github.com/es-shims/es5-shim][es5-shim]]

   Codifies de facto interpretations of the language specification that have
   become common among browser implementations and adds support for new
   features that have emerged since the publication of the third edition.

   - strict mode that provides enhanced error checking and program security ::

        'use strict' directive defines that the JavaScript code should be
        executed in "strict mode".

        ECMAScript defines a strict variant of the language. The
        strict variant of the language excludes some specific syntactic and
        semantic features of the regular ECMAScript language and modifies the
        detailed semantics of some features.  The strict variant also specifies
        additional error conditions that must be reported by throwing error
        exceptions in situations that are not specified as errors by the
        non-strict form of the language.

        Strict mode selection and use of the strict mode syntax and semantics
        of ECMAScript is explicitly made at the level of individual ECMAScript
        code units.  Because strict mode is selected at the level of a
        syntactic code unit, strict mode only imposes restrictions that have
        local effect within such a code unit.

   - ambiguities clarified ::

   - accessor properties---getters and setters ::

        Getters and setters allow the programnmer to implement the getting and
        setting of a property via methods.

   - syntactic changes ::

        ECMAScript 5 includes the following syntactic changes:

     + Reserved words as property keys; the programmer can use reserved words
       (such as ~new~ and ~function~) after the dot operator and as unquoted
       property keys in object literals.

     + Legal trailing commas

     + Multiline string literals using a trailing backslash (=/=)

   - New Functionality in the Standard Library ::

     + *Metaprogramming* (reflective creation and inspection of objects)

       - Getting and setting prototypes

         - ~Object.create()~

         - ~Object.getPrototypeOf()~

       - Managing property attributes via property descriptors (program control
         of property attributes)

         - ~Object.defineProperty()~

         - ~Object.defineProperties()~

         - ~Object.create()~

         - ~Object.getOwnPropertyDescriptor()~

       - Listing properties

         - ~Object.keys()~

         - ~Object.getOwnPropertyNames()~

       - Protecting objects

         - ~Object.preventExtensions()~

         - ~Object.isExtensible()~

         - ~Object.seal()~

         - ~Object.isSealed()~

         - ~Object.freeze()~

         - ~Object.isFrozen()~

       - New Function method

         - ~Function.prototype.bind()~

     + *New Methods*

       - on Strings

         - ~String.prototype.trim()~

         - Access characters via the bracket operator =[...]=

       - on Arrays

         - ~Array.isArray()~

         - ~Array.prototype.every()~

         - ~Array.prototype.filter()~

         - ~Array.prototype.forEach()~

         - ~Array.prototype.indexOf()~

         - ~Array.prototype.lastIndexOf()~

         - ~Array.prototype.map()~

         - ~Array.prototype.reduce()~

         - ~Array.prototype.some()~

       - on Dates

         - ~Date.now()~

         - ~Date.prototype.toISOString()~

     + JSON library support

       - ~JSON.parse()~

       - ~JSON.stringify()~

       - Some built-in objects have special toJSON() methods:

         - ~Boolean.prototype.toJSON()~

         - ~Number.prototype.toJSON()~

         - ~String.prototype.toJSON()~

         - ~Date.prototype.toJSON()~

** Edition 5.1

   June 2011.  [[http://www.ecma-international.org/ecma-262/5.1/index.html#Title][ECMAScript 5.1]] HTML

   Fully aligned with third edition of the international standard ISO/IEC
   16262:2011.

** Edition 6 --- ECMAScript 2015 (ES 6) (ES2015)

   June 2015.  [[http://www.ecma-international.org/ecma-262/6.0/index.html#Title][ECMAScript 2015 (ES2015)]]

   Internet Explorer does not support ECMAScript 2015.

   The sixth edition was initially known as ECMAScript 6 (ES6) and later
   renamed to ECMAScript 2015 (ES2015).

   #+BEGIN_QUOTE
   ECMAScript 5 is a nice and decent programming language, of course. But
   because of its history, it has some nasty aspects which ECMAScript 6 finally
   resolves.... ECMAScript 6's language design is cleaner than ECMAScript 5,
   its syntax increases the expressiveness of your code, it decreases the
   necessary boilerplate code (e.g. function vs. arrow syntax) and it
   especially let you get rid of some very nasty but required hacks and
   workarounds from the ECMAScript 5 era (e.g. ~var self = this~).

   --- Dr. Ralf S. Engelschall
   #+END_QUOTE

   - ~let~ and ~const~ declarations
   - exponentiation operator =**=
   - default parameter values
   - number and math enhancements,
     - new =Number= properties
       - =EPSILON=
       - =MIN_SAFE_INTEGER=
       - =MAX_SAFE_INTEGER=
     - new =Number= methods
       - ~Number.isInteger()~
       - ~Number.isSafeInteger()~
   - new library methods on =Array=
     - ~Array.find()~
     - ~Array.findIndex()~
   - new global methods
     - ~isFinite()~
     - ~isNaN()~
   - significant new syntax for writing complex applications, defined
     semantically in the same terms as ECMAScript 5 strict mode:
     + classes
     + modules
   - iterators
   - for/of loops
   - Python-style generators and generator expressions
   - arrow functions
     - allow a short syntax for writing function expressions
     - do not have their own =this=
     - are not hoisted
     - use =const= instead of =var= because a function expression is always a
       constant
   - binary data
   - typed arrays
   - collections
     + maps
     + sets
     + weak maps
   - promises
   - reflection
   - proxies (metaprogramming for virtual objects and wrappers)
   - template literals

** Edition 7 --- ES2016

   June 2016.  [[http://www.ecma-international.org/ecma-262/7.0/index.html#Title][ECMAScript 2016 (ES2016)]]

   - exponentiation operator (~**~)
   - ~Array.prototype.includes~

** Edition 8 --- ES2017

   June 2017.  [[http://www.ecma-international.org/ecma-262/8.0/index.html#Title][ECMAScript 2017 (ES2017)]]

   - concurrency
   - atomics
   - async/await (syntactic integration with promises )

** Edition 9 --- ES2018

   June 2018.  [[http://www.ecma-international.org/ecma-262/9.0/index.html#Title][ECMAScript 2018 (ES2018)]]

   - features for asynchronous iteration and generators
   - new regular expression features
   - rest/spread parameters

** Edition 10 --- ES2020 (Draft)

   March 2019.  [[https://tc39.github.io/ecma262/][ECMAScript 2020 (Draft)]]

** TC39 JavaScript Specification Group
- https://tc39.es

#+cindex:specification, TC39 group
#+cindex:Ecma International
Ecma International's TC39 is a group of JavaScript developers, implementers,
academics, and more, collaborating with the community to maintain and evolve
the definition of JavaScript.

We develop the JavaScript (formally, ECMAScript) specification [[https://github.com/tc39/ecma262/][on GitHub]] and
meet every two months to discuss proposals. To learn more about the process,
please take a look at the [[https://tc39.github.io/process-document/][four stages]] for [[Y][new language feature proposals]].  See
our [[https://github.com/tc39/agendas/][meeting agendas]] and [[https://github.com/tc39/tc39-notes/][minutes]] to learn more.

{{{heading(Contributing to TC39)}}}

TC39 welcomes contributions.  You can help by giving feedback on proposals,
improving documentation, writing tests or implementations, or suggesting
language feature ideas.  See our [[https://github.com/tc39/ecma262/blob/master/CONTRIBUTING.md][contributor guide]] for details.

*** Stage 3 Proposals
- [[https://github.com/tc39/proposal-global][globalThis]]
- [[https://github.com/tc39/proposal-dynamic-import][import()]]
- [[https://github.com/tc39/proposal-bigint][BigInt]]
- [[https://github.com/tc39/proposal-private-methods][Private instance methods and accessors]]
- [[https://github.com/tc39/proposal-class-fields][Class Public Instance Fields & Private Instance Fields]]
- [[https://github.com/tc39/proposal-static-class-features][Static class fields and private static methods]]
- [[https://github.com/tc39/proposal-promise-allSettled][Promise.allSettled]]
- [[https://github.com/tc39/proposal-hashbang][Hashbang Grammar]]

** Console Living Standard
- https://console.spec.whatwg.org/

- https://developer.mozilla.org/en-US/docs/Web/API/Console


This specification defines APIs for console debugging facilities.  Last Updated
9 August 2019

* ECMAScript 3 Features
** Lexical Conventions

*** Tokens

*** Identifiers

*** Punctuators

*** Literals

*** Semicolon Insertion

** Types

** Type Conversion

** Execution Contexts

** Expressions
An /expression/ is a phrase of JavaScript that a JavaScript interpreter can
*evaluate* to produce a value.

- A constant embedded literally in your program is a very simple kind of
  expression.

- A variable name is also a simple expression that evaluates to whatever value
  has been assigned to that variable.

- Complex expressions are built from simpler expressions.

  - An array access expression, for example, consists of one expression that
    evaluates to an array followed by an open square bracket, an expression
    that evaluates to an integer, and a close square bracket.  This new, more
    complex expression evaluates to the value stored at the specified index of
    the specified array.

  - A function invocation expression consists of one expression that evaluates
    to a function object and zero or more additional expressions that are used
    as the arguments to the function.


The most common way to build a complex expression out of simpler expressions is
with an /operator/.  An operator combines the values of its operands (usually two
of them) in some way and evaluates to a new value.  Not all expressions require
or use operators, however.

*** Primary Expressions
#+cindex:primary expressions
The simplest expressions, known as /primary expressions/, are those that stand
alone---they do not include any simpler expressions.  Primary expressions in
JavaScript are

- constant or literal values, ::
  - number literals
  - string literals
  - regular expression literals

- certain language keywords, ::
     Some of JavaScript’s reserved words are primary expressions:

  - =true=

  - =false=

  - =null=

  - =this=

- variable references ::
     #+cindex:strict mode
     #+cindex:ECMAScript 5
     the third type of primary expression is the bare variable reference.  When
     any identifier appears by itself in a program, JavaScript assumes it is a
     variable and looks up its value.  If no variable with that name exists,
     the expression evaluates to the =undefined= value.  In the strict mode of
     ECMAScript 5, however, an attempt to eval- uate a nonexistent variable
     throws a ReferenceError instead.

*** Object and Array Initializers
#+cindex:initializers
#+cindex:object initializers
#+cindex:array initializers
Object and array initializers are expressions whose value is a newly created
object or array.  These initializer expressions are sometimes called “object
literals” and “array literals.”

Unlike true literals, however, they are not primary expressions, because they
include a number of subexpressions that specify property and element values.

**** Array Initializers
#+cindex:array initializer
#+cindex:nested arrays
#+cindex:arrays, nested
An array initializer is a comma-separated list of expressions contained within
square brackets.  The value of an array initializer is a newly created array.
The elements of this new array are initialized to the values of the
comma-separated expressions.  The element expressions in an array initializer
can themselves be array initializers, which means that these expressions can
create nested arrays.  Undefined elements can be included in an array literal
by simply omitting a value between commas.

**** Object Initializers
#+cindex:object initializer
Object initializer expressions are like array initializer expressions, but the
square brackets are replaced by curly brackets, and each subexpression is
prefixed with a property name and a colon.  Object literals can be nested.  The
property names in object literals may be strings rather than identifiers (this
is useful to specify property names that are reserved words or are otherwise
not legal identifiers).

**** Function Definition Expressions
#+cindex:function definition expressions
A function definition expression defines a JavaScript function, and the value
of such an expression is the newly defined function.  A function definition
expression typically consists of the keyword function followed by a
comma-separated list of zero or more identifiers (the parameter names) in
parentheses and a block of JavaScript code (the function body) in curly braces.
A function definition expression can also include a name for the function.
Functions can also be defined using a function statement rather than a function
expression.

**** Property Access Expressions

**** Invocation Expressions

**** Object Creation Expressions
#+cindex:object creation expression
#+cindex:constructor
#+cindex:initialize object
An object creation expression creates a new object and invokes a function
(called a constructor) to initialize the properties of that object.  Object
creation expressions are like invocation expressions except that they are
prefixed with the keyword =new=:

: new Point(2,3)

If no arguments are passed to the constructor function in an object creation
expression, the empty pair of parentheses can be omitted.

When an object creation expression is evaluated, JavaScript:

1. first creates a new empty object, just like the one created by the object
   initializer ={}=.

   #+cindex:@code{this} value, object creation
2. Next, it invokes the specified function with the specified arguments,
   passing the new object as the value of the ~this~ keyword.

3. The function can then use ~this~ to initialize the properties of the newly
   created object.

4. Functions written for use as constructors do not return a value, and the
   value of the object creation expression is the newly created and initialized
   object.  If a constructor does return an object value, that value becomes
   the value of the object creation expression and the newly created object is
   discarded.

** Operators
#+cindex:operators
Operators are used for JavaScript’s arithmetic expressions, comparison
expressions, logical expressions, assignment expressions, and more.

#+caption:JavaScript Operators
#+name:javascript-operators
| Operator         | Operation                          | A | N | Types             |
|------------------+------------------------------------+---+---+-------------------|
| =++=             | Pre- or post-increment             | R | 1 | lval->num         |
| =--=             | Pre- or post-decrement             | R | 1 | lval->num         |
| =-=              | Negate number                      | R | 1 | num->num          |
| =+=              | Convert to number                  | R | 1 | num->num          |
| =~=              | Invert bits                        | R | 1 | int->int          |
| =!=              | Invert boolean value               | R | 1 | bool->bool        |
| =delete=         | Remove a property                  | R | 1 | lval->bool        |
| =typeof=         | Determine type of operand          | R | 1 | any->str          |
| =void=           | Return undefined value             | R | 1 | any->undef        |
|------------------+------------------------------------+---+---+-------------------|
| =*,/,%=          | Multiply, divide, remainder        | L | 2 | num,num->num      |
|------------------+------------------------------------+---+---+-------------------|
| =+,-=            | Add, subtract                      | L | 2 | num,num->num      |
| =+=              | Concatenate strings                | L | 2 | num,num->num      |
|------------------+------------------------------------+---+---+-------------------|
| =<<=             | Shift left                         | L | 2 | int,int->int      |
| =>>=             | Shift right with sign extension    | L | 2 | int,int->int      |
| =>>>=            | Shift right with zero extension    | L | 2 | int,int->int      |
|------------------+------------------------------------+---+---+-------------------|
| =<,<==           | Compare in numeric order           | L | 2 | num,num->bool     |
| =>,>==           | Compare in alphabetic order        | L | 2 | str,str->bool     |
| =instanceof=     | Test object class                  | L | 2 | obj,func->bool    |
| =in=             | Test whether property exists       | L | 2 | str,obj->bool     |
|------------------+------------------------------------+---+---+-------------------|
| ~==~             | Test for equality                  | L | 2 | any,any->bool     |
| ~!=~             | Test for inequality                | L | 2 | any,any->bool     |
| ~===~            | Test for strict equality           | L | 2 | any,any->bool     |
| ~!==~            | Test for strict inequality         | L | 2 | any,any->bool     |
|------------------+------------------------------------+---+---+-------------------|
| =&,^,pipe=       | Compute bitwise AND, XOR,OR        | L | 2 | int,int->int      |
|------------------+------------------------------------+---+---+-------------------|
| =&&,pipe-pipe=   | Compute logical AND, OR            | L | 2 | any,any->any      |
|------------------+------------------------------------+---+---+-------------------|
| =?:=             | Choose 2nd or 3rd operand          | R | 3 | bool,any,any->any |
|------------------+------------------------------------+---+---+-------------------|
| ~=~              | Assign to a variable or property   | R | 2 | lval,any->any     |
| ~*=,/=,%=,+=~    | Operate and assign                 | R | 2 | lval,any->any     |
| ~-=,&=,^=,pipe=~ |                                    | R | 2 | lval,any->any     |
| ~<<=,>>=,>>>=~   |                                    | R | 2 | lval,any->any     |
|------------------+------------------------------------+---+---+-------------------|
| =,=              | Discard 1st operand, return second | L | 2 | any,any->any      |
|------------------+------------------------------------+---+---+-------------------|

*** Arithmetic Operators

*** Assignment Operators

*** Bitwise Operators

*** Comma Operator

*** Comparison Operators

*** Conditional Ternary Operator

*** Grouping Operator

*** Logical Operators

*** Delete Operator

*** In Operator

*** Instanceof Operator
#+cindex:@code{instanceof} operator
#+cindex:@code{prototype} property
#+cindex:prototype chain
#+cindex:@code{constructor.prototype}
The =instanceof= operator tests whether the =prototype= property of a
constructor appears anywhere in the prototype chain of an object.  Said another
way, the =instanceof= operator tests the presence of ~constructor.prototype~ in
object's prototype chain.

: <object> instanceof <constructor-function>

#+cindex:@code{Object.setPrototypeOf}
#+pindex:@code{__proto__} property
Note that the value of an =instanceof= test can change based on changes to the
=prototype= property of constructors, and it can also be changed by changing an
object prototype using ~Object.setPrototypeOf~.  It is also possible using the
non-standard =__proto__= pseudo-property.

The ~instanceof~ operator expects a left-side operand that is an object and a
right-side operand that identifies a class of objects.  The operator evaluates
to =true= if the left-side object is an instance of the right-side class and
evaluates to =false= otherwise.

#+cindex:classes of objects
#+cindex:object classes
#+cindex:constructor function
In JavaScript, classes of objects are defined by the constructor function that
initializes them.  Thus, the right-side operand of ~instanceof~ should be a
function.  If the left-side operand of ~instanceof~ is not an object,
~instanceof~ returns =false=.  If the right-hand side is not a function, it
throws a =TypeError=.

{{{heading(instanceof and the Prototype Chain)}}}

#+cindex:prototype chain
#+cindex:inheritance mechanism
In order to understand how the ~instanceof~ operator works, you must understand
the “prototype chain.”  This is JavaScript’s inheritance mechanism.  To
evaluate the expression ~o instanceof f~, JavaScript evaluates ~f.prototype~,
and then looks for that value in the prototype chain of =o=.  If it finds it,
then =o= is an instance of =f= (or of a superclass of =f=) and the operator
returns =true=.  If ~f.prototype~ is not one of the values in the prototype
chain of =o=, then =o= is not an instance of =f= and ~instanceof~ returns
=false=.

*** Typeof Operator
#+cindex:@code{typeof} operator
The =typeof= operator returns a string indicating the type of the unevaluated
operand.

~typeof~ is a unary operator that is placed before its single operand, which
can be of any type.  Its value is a string that specifies the type of the
operand.

: typeof operand
: typeof(operand)

{{{heading(Possible Return Values of typeof)}}}

#+caption:Possible return values of the operator typeof
#+name:possible-return-values-of-typeof
| Type             | Result      |
|------------------+-------------|
| Undefined        | "undefined" |
| Null             | "object"    |
| Boolean          | "boolean"   |
| Number           | "number"    |
| BigInt           | "bigint"    |
| String           | "string"    |
| Symbol           | "symbol"    |
| Host object      | depends     |
| Function object  | "function"  |
| Any other object | "object"    |
|------------------+-------------|

You might use the ~typeof~ operator in an expression like this:

: (typeof value == "string") ? "'" + value + "'" : value

The ~typeof~ operator is also useful when used with the ~switch~ statement.

**** Notes on the typeof Operator

{{{subheading(Null Returns “object”)}}}

~typeof~ returns “object” if the operand value is null.  If you want to
distinguish =null= from objects, you’ll have to explicitly test for this
special-case value.

{{{subheading(Difficultity with Objects)}}}

Because ~typeof~ evaluates to “object” for all object and array values other
than functions, it is useful only to distinguish objects from other, primitive
types.  In order to distinguish one class of object from another, you must use
other techniques, such as:

- ~instanceof~ operator
- ~class~ attribute
- =constructor= property

{{{subheading(new Operator)}}}

All constructor functions, with the exception of the Function constructor, will
always be typeof 'object'

#+begin_src js
var str = new String('String');
var num = new Number(100);

typeof str; // It will return 'object'
typeof num; // It will return 'object'

var func = new Function();

typeof func; // It will return 'function'
#+end_src

{{{subheading(Need for parentheses)}}}

Parentheses can be used for determining the data type of expressions.

#+begin_src js
var iData = 99;

typeof iData + ' Wisen'; // 'number Wisen'
typeof (iData + ' Wisen'); // 'string'
#+end_src

{{{subheading(Regular Expressions)}}}

Callable regular expressions were a non-standard addition in some browsers.

#+begin_src js
typeof /s/ === 'function'; // Chrome 1-12 Non-conform to ECMAScript 5.1
typeof /s/ === 'object';   // Firefox 5+  Conform to ECMAScript 5.1
#+end_src

{{{subheading(Errors and the Temporal Dead Zone)}}}

#+cindex:temporal dead zone
Before ECMAScript 2015, =typeof= was always guaranteed to return a string for
any operand it was supplied with.  Even with undeclared identifiers, =typeof=
will return 'undefined'.  Using =typeof= could never generate an error.

But with the addition of block-scoped =let= and =Statements/const= using
=typeof= on =let= and =const= variables (or using =typeof= on a class) in a
block before they are declared will throw a =ReferenceError=.  Block scoped
variables are in a "temporal dead zone" from the start of the block until the
initialization is processed, during which, it will throw an error if accessed.

#+begin_src js
typeof undeclaredVariable === 'undefined';

typeof newLetVariable; // ReferenceError
typeof newConstVariable; // ReferenceError
typeof newClass; // ReferenceError

let newLetVariable;
const newConstVariable = 'hello';
class newClass{};
#+end_src

{{{subheading(Exceptions)}}}

All current browsers expose a non-standard host object =document.all= with type
=undefined=.

Although the specification allows custom type tags for non-standard exotic
objects, it requires those type tags to be different from the predefined ones.
The case of =document.all= having type 'undefined' is classified in the web
standards as a "willful violation" of the original ECMA JavaScript standard.

*** Void Operator

#+cindex:@code{void} operator
The =void= operator evaluates the given expression and then returns
=undefined=.

: void <expression>

This operator allows evaluating expressions that produce a value into places
where an expression that evaluates to =undefined= is desired.

The =void= operator is often used merely to obtain the =undefined= primitive
value, usually using ~void(0)~ (which is equivalent to ~void 0~).  In these
cases, the global variable =undefined= can be used instead (assuming it has not
been assigned to a non-default value).

{{{heading(The IIFE and Void)}}}

#+cindex:immediately-invoked function expression
#+cindex:IIFE
When using an immediately-invoked function expression, =void= can be used to
force the =function= keyword to be treated as an expression instead of a
declaration.

#+begin_src js -n
void function iife() {
    var bar = function () {};
    var baz = function () {};
    var foo = function () {
        bar();
        baz();
     };
    var biz = function () {};

    foo();
    biz();
}();
#+end_src

Without the =void=, the above will throw a =SyntaxError= at the closing
parenthesis.

{{{heading(JavaScript URIs)}}}

#+cindex:javascript: uri
When a browser follows a ~javascript: URI~, it evaluates the code in the URI
and then replaces the contents of the page with the returned value, unless the
returned value is =undefined=.  The =void= operator can be used to return
=undefined=.  For example:

#+begin_src js -n
<a href="javascript:void(0);">
  Click here to do nothing
</a>

<a href="javascript:void(document.body.style.backgroundColor='green');">
  Click here for green background
</a>
#+end_src

{{{heading(Non-leaking Arrow Functions)}}}

#+cindex:arrow function
Arrow functions introduce a short-hand braceless syntax that returns an
expression.  This can cause unintended side effects by returning the result of
a function call that previously returned nothing.  To be safe, when the return
value of a function is not intended to be used, it can be passed to the =void=
operator to ensure that (for example) changing APIs do not cause arrow
functions' behaviors to change.

: button.onclick = () => void doSomething();

This ensures the return value of ~doSomething~ changing from =undefined= to
=true= will not change the behavior of this code.
** Statements

#+begin_example
Statement :
   Block
   VariableStatement
   EmptyStatement
   ExpressionStatement
   IfStatement
   IterationStatement
   ContinueStatement
   BreakStatement
   ReturnStatement
   WithStatement
#+end_example

*** Control Flow Statements
#+cindex:control flow statements
#+cindex:statements, control flow

**** Block
#+cindex:block statement
#+cindex:statement, block
A block statement is used to group zero or more statements. The block is
delimited by a pair of curly brackets.

**** =break= Statement
#+cindex:@code{break} statement
#+cindex:statement, @code{break}
Terminates the current loop, switch, or label statement and transfers program
control to the statement following the terminated statement.

**** =continue= Statement
#+cindex:@code{continue} statement
#+cindex:statement, @code{continue}
Terminates execution of the statements in the current iteration of the current
or labeled loop, and continues execution of the loop with the next iteration.

**** =Empty= Statement
#+cindex:@code{Empty} statement
An empty statement is used to provide no statement, although the JavaScript
syntax would expect one.

**** =if/else= Statement
#+cindex:@code{if} / @code{else}
Executes a statement if a specified condition is true.  If the condition is
false, another statement can be executed.

**** =switch= Statement
#+cindex:@code{switch} statement
Evaluates an expression, matching the expression's value to a case clause, and
executes statements associated with that case.

**** =throw= Statement
#+cindex:@code{throw} statement
Throws a user-defined exception.

**** =try/catch= Statement
#+cindex:@code{try} / @code{catch} statement
Marks a block of statements to try, and specifies a response, should an
exception be thrown.

*** Variable Declarations

**** =var= Declaration
#+cindex:@code{var} declaration
Declares a variable, optionally initializing it to a value.

*** Function Declarations

**** =function= Declaration
#+cindex:@code{function} declaration
Declares a function with the specified parameters.

**** =return= Statement
#+cindex:@code{return} statement
Specifies the value to be returned by a function.

*** Iteration Statements

#+cindex:iteration statement
#+cindex:@code{while} statement
#+cindex:@code{for} statement
#+begin_example
IterationStatement :
     while ( Expression ) Statement
     for ( Expressionopt ; Expressionopt ; Expressionopt ) Statement
     for ( var VariableDeclarationList ; Expressionopt ; Expressionopt ) Statement
     for ( LeftHandSideExpression in Expression ) Statement
     for ( var Identifier Initializeropt in Expression ) Statement
#+end_example

**** =do...while=
#+cindex:@code{do...while}
Creates a loop that executes a specified statement until the test condition
evaluates to false.  The condition is evaluated after executing the statement,
resulting in the specified statement executing at least once.

**** =for= Statement
#+cindex:@code{for} Statement
Creates a loop that consists of three optional expressions, enclosed in
parentheses and separated by semicolons, followed by a statement executed in
the loop.

**** =for each...in= Statement
#+cindex:@code{for each...in} statement
Iterates a specified variable over all values of object's properties.  For each
distinct property, a specified statement is executed.

**** =for..in= Statement

#+cindex:@code{for...in} statement
#+cindex:non-Symbol
#+cindex:Symbol, non-
#+cindex:enumerable properties, object
The =for...in= statement iterates over all non-Symbol, enumerable properties of
an object in an arbitrary order.

{{{heading(Syntax)}}}

#+begin_example
for (variable in object)
  statement
#+end_example

- variable :: A different property name is assigned to variable on each
              iteration.

- object :: Object whose non-Symbol enumerable properties are iterated over.


{{{heading(Description)}}}

A =for...in= loop only iterates over enumerable, non-Symbol properties.  The
loop will iterate over all enumerable properties of the object itself and those
the object inherits from its constructor's prototype.  A =for...in= loop
iterates over the properties of an object in an arbitrary order.

If a property is modified in one iteration and then visited at a later time,
its value in the loop is its value at that later time.  A property that is
deleted before it has been visited will not be visited later.  Properties added
to the object over which iteration is occurring may either be visited or
omitted from iteration.

In general, it is best not to add, modify, or remove properties from the object
during iteration, other than the property currently being visited.  There is no
guarantee whether an added property will be visited, whether a modified
property (other than the current one) will be visited before or after it is
modified, or whether a deleted property will be visited before it is deleted.

{{{heading(Iterating Over Arrays)}}}

#+begin_cartouche
*NOTE:* =for...in= should not be used to iterate over an Array where the index
order is important.
#+end_cartouche

Array indexes are just enumerable properties with integer names and are
otherwise identical to general object properties.  There is no guarantee that
=for...in= will return the indexes in any particular order.  The =for...in=
loop statement will return all enumerable properties, including those with
non–integer names and those that are inherited.

Because the order of iteration is implementation-dependent, iterating over an
array may not visit elements in a consistent order.  Therefore, it is better to
use a =for= loop with a numeric index (or ~Array.prototype.forEach()~ or the
=for...of= loop) when iterating over arrays where the order of access is
important.

{{{heading(Iterating Over Own Properties Only)}}}

#+cindex:@code{getOwnPropertyNames()} method
#+cindex:@code{hasOwnProperty()} method
#+cindex:@code{propertyIsEnumerable()} method
#+cindex:@code{check} method
If you only want to consider properties attached to the object itself, and not
its prototypes, use ~getOwnPropertyNames()~ or perform a ~hasOwnProperty()~
check (~propertyIsEnumerable()~ can also be used).  Alternatively, if you know
there won't be any outside code interference, you can extend built-in
prototypes with a ~check~ method.

{{{heading(When to User for...in)}}}

=for...in= is built for iterating object properties.  It may be most
practically used for debugging purposes, being an easy way to check the
properties of an object (by outputting to the console or otherwise).  Although
arrays are often more practical for storing data, in situations where a
key-value pair is preferred for working with data (with properties acting as
the "key"), there may be instances where you want to check if any of those keys
hold a particular value.

{{{heading(Examples)}}}

{{{subheading(Basic Use of for...in Iteration)}}}

The =for...in= loop below iterates over all of the object's enumerable,
non-Symbol properties and logs a string of the property names and their values.

#+caption:Example of basic for...in iteration
#+name:example-basic-for-in-iteration
#+begin_src js
var obj = {a: 1, b: 2, c: 3};

for (const prop in obj) {
  console.log(`obj.${prop} = ${obj[prop]}`);
}

// Output:
// "obj.a = 1"
// "obj.b = 2"
// "obj.c = 3"
#+end_src

{{{subheading(Iterating Over Property's Own)}}}

#+cindex:@code{hasOwnProperty()} method
The following function illustrates the use of ~hasOwnProperty()~: the inherited
properties are not displayed.

#+caption:Example of iterating over only an object's own properties
#+name:example-for-in-own-properties-only
#+begin_src js
var triangle = {a: 1, b: 2, c: 3};

function ColoredTriangle() {
  this.color = 'red';
}

ColoredTriangle.prototype = triangle;

var obj = new ColoredTriangle();

for (const prop in obj) {
  if (obj.hasOwnProperty(prop)) {
    console.log(`obj.${prop} = ${obj[prop]}`);
  } 
}

// Output:
// "obj.color = red"
#+end_src


**** =while= Statement
#+cindex:@code{while} statement
Creates a loop that executes a specified statement as long as the test
condition evaluates to true.  The condition is evaluated before executing the
statement.

*** Miscellaneous Statements and Expressions

**** =debugger= Statement
Invokes any available debugging functionality.  If no debugging functionality
is available, this statement has no effect.

**** =label= Statement
#+cindex:@code{label} statement
Provides a statement with an identifier that you can refer to using a =break=
or =continue= statement.

**** =with=
#+cindex:@code{with} statement
#+cindex:deprecated, @code{with} statement
#+begin_example
WithStatement :
     with ( Expression ) Statement
#+end_example

{{{heading(The ~with~ Statement is Deprecated)}}}

#+cindex:strict mode, @code{with} statement
*DEPRECATED*: Using ~with~ is not recommended, and is forbidden in ECMAScript 5
strict mode.

The recommended alternative is to assign the object whose properties you want
to access to a temporary variable.

{{{heading(About the ~with~ Statement)}}}

#+cindex:scope chain, extends
The ~with~ statement extends the scope chain for a statement.

- expression :: Adds the given expression to the scope chain used when
                evaluating the statement. The parentheses around the expression
                are required.

- statement :: Any statement. To execute multiple statements, use a =block=
               statement =({ ... })= to group those statements.


{{{heading(Description of the ~with~ Statement)}}}

{{{subheading(Scope Chain of the Execution Context)}}}

#+cindex:scope chain
#+cindex:execution context
JavaScript looks up an unqualified name by searching a /scope chain/ associated
with the execution context of the script or function containing that
unqualified name.

The ~with~ statement adds the given object to the head of this scope chain
during the evaluation of its statement body.

#+cindex:@code{ReferenceError}
If an unqualified name used in the body matches a property in the scope chain,
then the name is bound to the property and the object containing the
property.  Otherwise a ~ReferenceError~ is thrown.

{{{heading(A ~with~ Statement Example)}}}

The following ~with~ statement specifies that the Math object is the default
object. The statements following the with statement refer to the PI property
and the cos and sin methods, without specifying an object. JavaScript assumes
the Math object for these references.

#+caption:An Example of the ~with~ Statement
#+name:with-statement-example
#+begin_src js -n
var a, x, y;
var r = 10;

with (Math) {
  a = PI * r * r;
  x = r * cos(PI);
  y = r * sin(PI / 2);
}
#+end_src

#+cindex:scope chain
#+cindex:computed object
#+cindex:execution context
The ~with~ statement adds a /computed object/ to the front of the scope chain
of the current execution context, then executes a statement with this augmented
scope chain, then restores the scope chain.

{{{heading(Semantics)}}}

1. Evaluate =Expression=

2. Call ~GetValue(Result(1))~

3. Call ~ToObject(Result(2))~

4. Add ~Result(3)~ to the front of the scope chain

   #+cindex:scope chain, augmented
5. Evaluate ~Statement~ using the augmented scope chain from step 4

6.  Let ~C~ be ~Result(5~).  If an exception was thrown in step 5, let ~C~ be
   (throw, ~V~, empty), where ~V~ is the exception.  (Execution now proceeds as
   if no exception were thrown.)

7. Remove ~Result(3)~ from the front of the scope chain

8. Return ~C~


{{{heading(Intended Use of the ~with~ Statement)}}}

The ~with~ statement's intended use is to avoid redundancy when accessing an
object several times.  The following is an example of code with redundancies:

#+begin_src js
foo.bar.baz.bla =123;
foo.bar.baz.yadda = 'abc';
#+end_src

~with~ makes this shorter:

#+begin_src js
  with (foo.bar.baz) { 
      bla = 123;
      yadda = 'abc';
  }
#+end_src

{{{subheading(Techniques for avoiding the ~with~ statement)}}}

Use a temporary variable with a short name, or an IIFE:

#+begin_src js
  // Don't do this:
  with (foo.bar.baz) {
  console.log('Hello '+first+' '+last);

  // Do this instead:
  var b = foo.bar.baz;
  console.log('Hello '+b.first+' '+b.last);

  // Or use an IIFE to avoid exposing ~b~ to the current scope
  (function () {
      var b = foo.bar.baz;
      console.log('Hello '+b.first+' '+b.last);
  }());

  // Or make the object a parameter of the IIFE:
  (function (b) {
      console.log('Hello '+b.first+' '+b.last);
  }(foo.bar.baz));
#+end_src


{{{heading(Performance Issues)}}}

- pro :: The ~with~ statement can help reduce file size by reducing the need to
         repeat a lengthy object reference without performance penalty.  The
         scope chain change required by ~with~ is not computationally
         expensive.  Use of ~with~ will relieve the interpreter of parsing
         repeated object references.  *In many cases this benefit can be
         achieved by using a temporary variable to store a reference to the
         desired object*.

- con :: The ~with~ statement forces the specified object to be searched first
         for all name lookups.  Therefore all identifiers that aren't members
         of the specified object will be found more slowly in a ~with~ block.
         Where performance is important, ~with~ should only be used to
         encompass code blocks that access members of the specified object.

- con :: The ~with~ statement makes it hard for a human reader or JavaScript
         compiler to decide whether an unqualified name will be found along the
         scope chain, and if so, in which object.  So given this example:

         #+attr_texinfo: :author Brendan Eich
         #+begin_quote
         ``[W]ith violates lexical scope, making program analysis (e.g. for
         security) hard to infeasible.''
         #+end_quote

         #+begin_src js -n
           function f(x, o) {
             with (o) {
               console.log(x);
             }
           }
         #+end_src

         #+cindex:activation object
         Only when ~f~ is called is ~x~ either found or not, and if found,
         either in ~o~ or (if no such property exists) in ~f~'s activation
         object, where ~x~ names the first formal argument.  If you forget to
         define ~x~ in the object you pass as the second argument, or if there's
         some similar bug or confusion, you won't get an error --- just
         unexpected results.
** Function Definition
Every JavaScript function is actually a Function object.

#+cindex:Function constructor
#+cindex:@code{eval}
The =Function()= constructor creates a new =Function= object.  Calling the
constructor directly can create functions dynamically.  The =Function()=
constructor creates functions which execute in the global scope only.
Functions created with the Function constructor do not create closures to their
creation contexts; they always are created in the global scope.  When running
them, they will only be able to access their own local variables and global
ones, not the ones from the scope in which the Function constructor was
created.  This is different from using ~eval~ with code for a function
expression.[fn:NodeFunc]

[fn:NodeFunc]The top-level scope in Node is /not/ the global scope.  Local
variables to a Node module will not be found by a function created in Node.


Invoking the =Function= constructor as a function (without using the new
operator) has the same effect as invoking it as a constructor.  The global
=Function= object has no methods or properties of its own.

: new Function ( arg1[, arg2[, ...argN]], BODY)

- arg1, arg2, ...argN :: Names to be used by the function as formal argument
     names.  Each must be a string that corresponds to a valid JavaScript
     identifier or a list of such strings separated with a comma;

- BODY :: A string containing the JavaScript statements comprising the function
          definition.


: var adder = new Function('a', 'b', 'return a + b');

*** Function Properties and Methods
#+cindex:Function properties and methods
Since it is a function itself, the global Function object does inherit some
methods and properties through the prototype chain from =Function.prototype=.

**** Function.prototype Properties

#+cindex:Function.prototype.arguments
- ~Function.prototype.arguments~ :: An array corresponding to the arguments
     passed to a function.  This is deprecated as property of =Function=.  Use
     the =arguments= object available within the function instead.

     #+cindex:Function.prototype.caller
- ~Function.prototype.caller~ :: Specifies the function that invoked the
     currently executing function (not standard).

     #+cindex:Function.prototype.length
- ~Function.prototype.length~ :: Specifies the number of arguments expected by
     the function.

- ~Function.prototype.name~ :: The name of the function.

- ~Function.prototype.constructor~ :: Specifies the function that creates an
     object's prototype.  See ~Object.prototype.constructor~ for more details.

**** Function.prototype Methods

- ~Function.prototype.apply()~ :: Calls a function and sets its ~this~ to the
     provided value, arguments can be passed as an Array object.

- ~Function.prototype.bind()~ :: Creates a new function which, when called, has
     its ~this~ set to the provided value, with a given sequence of arguments
     preceding any provided when the new function was called.

- ~Function.prototype.call()~ :: Calls (executes) a function and sets its
     ~this~ to the provided value, arguments can be passed as they are.

- ~Function.prototype.isGenerator()~ :: Returns true if the function is a
     generator; otherwise returns false.

- ~Function.prototype.toSource()~ :: Returns a string representing the source
     code of the function. Overrides the ~Object.prototype.toSource~ method.

- ~Function.prototype.toString()~ :: Returns a string representing the source
     code of the function. Overrides the ~Object.prototype.toString~ method.

**** Function Instances
Function instances inherit methods and properties from ~Function.prototype~.

You can change the constructor's prototype object to make changes to all
Function instances.

** Program

** Native Objects or Standard Built-in Objects
*** Global Objects
#+cindex:global objects
#+cindex:global scope
/Global objects/ refer to objects in the global scope.  The global scope
consists of the properties of the global object, including inherited
properties, if any.

{{{heading(Standard Objects by Category)}}}

**** Value Properties
These global properties return a simple value; they have no properties or
methods.

#+cindex:Infinity
- =Infinity= :: The global =Infinity= property is a numeric value representing
                infinity.  It is a variable in global scope.  The initial value
                of Infinity is =Number.POSITIVE_INFINITY=.

                The value =Infinity= (positive infinity) is greater than any
                other number.  Mathematically, this value behaves the same as
                infinity; for example, any positive number multiplied by
                =Infinity= equals Infinity, and any number divided by
                =Infinity= equals 0.

  #+cindex:NaN
  #+cindex:Number.NaN
- =Nan= :: The global =NaN= property is a value representing =Not-A-Number=,
           the same as the value of =Number.NaN=.  It is the returned value
           when Math functions fail (~Math.sqrt(-1)~) or when a function trying
           to parse a number fails (~parseInt("blabla")~).

           #+cindex:Number.isNaN()
           #+cindex:isNaN()
           Use ~Number.isNaN()~ or ~isNaN()~ to most clearly determine whether
           a value is =NaN=.  Note the difference between ~isNaN()~ and
           ~Number.isNaN()~: the former will return =true= if the value is
           currently =NaN=, or if it is going to be =NaN= after it is coerced
           to a number, while the latter will return =true= only if the value
           is currently =NaN=:

           #+begin_src js
           isNaN('hello world');        // true
           Number.isNaN('hello world'); // false
           #+end_src

  #+cindex:undefined
- =undefined= :: The global =undefined= property represents the primitive value
                 =undefined=.  It is one of JavaScript's primitive types.

                 A variable that has not been assigned a value is of type
                 =undefined=.  A method or statement also returns =undefined=
                 if the variable that is being evaluated does not have an
                 assigned value.  A function returns =undefined= if a value was
                 not returned.

                 You can use =undefined= and the strict equality and inequality
                 operators to determine whether a variable has a value.
                 : if (x === undefined) {...} // returns true only if x is undefined
                 : if (x == undefined)  {...} // returns true if x is undefined or null

                 Alternatively, ~typeof~ can be used; one reason to use
                 ~typeof~ is that it does not throw an error if the variable
                 has not been declared.
                 : if (typeof x === 'undefined') {...}

  #+cindex:null
- =null= literal :: The value =null= represents the intentional absence of any
                    object value.  It is one of JavaScript's primitive values.

                    The value =null= is written with a literal: 'null'.  =null=
                    is not an identifier for a property of the global object,
                    like =undefined= can be.  Instead, =null= expresses a lack
                    of identification, indicating that a variable points to no
                    object.
                    : null === null        // true

  #+cindex:globalThis
- =globalThis= :: The global =globalThis= property contains the global =this=
                  value, which is akin to the global object (currently at
                  Stage 3).

                  The =globalThis= property provides a standard way of
                  accessing the global =this= value (and hence the global
                  object itself) across environments.  Unlike similar
                  properties such as =window= and =self=, it's guaranteed to
                  work in window and non-window contexts.  In this way, you can
                  access the global object in a consistent manner without
                  having to know which environment the code is being run in.
                  
**** Function Properties
**** Fundamental Objects
**** Numbers and Dates
**** Text Processing
**** Indexed Collections
**** Keyed Collections
**** Structured Data
**** Control Abstract Objects
**** Reflection
**** Internationalization
**** WebAssembly
**** Other

*** Object Objects
These are the fundamental, basic objects upon which all other objects are
based.  This includes objects that represent general objects, functions, and
errors.

**** =Object=

***** About Objects
#+cindex:Object, fundamental datatype
#+cindex:datatype, fundamental, the Object
#+cindex:composite value
#+cindex:properties, unordered collection
JavaScript’s fundamental datatype is the object.  An object is a composite
value: it aggregates multiple values (primitive values or other objects) and
allows you to store and retrieve those values by name.  Said another way, an
object is an unordered collection of properties, each of which has a name and a
value.  Property names are strings, so we can say that /objects map strings to
values/.  This string-to-value mapping goes by various names:

#+cindex:string-to-value mapping
#+cindex:hash, hashtable
#+cindex:dictionary
#+cindex:associative array
- hash
- hashtable
- dictionary
- associative array


{{{heading(The Prototype)}}}

#+cindex:inherited properties
#+cindex:prototype
In addition to maintaining its own set of properties, a JavaScript object also
inherits the properties of another object, known as its “prototype.”  The
methods of an object are typically inherited properties.

{{{heading(Objects are Dynamic and Mutable)}}}

#+cindex:objects are dynamic
#+cindex:dynamic, objects
#+cindex:mutable, objects
JavaScript objects are /dynamic/---properties can usually be added and deleted.
Objects are /mutable/ and are manipulated by reference rather than by value.

{{{heading(Operations on Objects)}}}

The most common things to do with objects are:

- create them
- set them
- query them
- delete them
- test them
- enumerate their properties


{{{heading(Object Properties and Values)}}}

#+cindex:name, property
#+cindex:value, property
#+cindex:property, name and value
#+cindex:getter
#+cindex:setter
A /property/ has a *name* and a *value*.  A property name may be any string,
including the empty string.  The /value/ may be any JavaScript value, or (in
ECMAScript 5) it may be a getter or a setter function (or both).

{{{heading(Property Attributes)}}}

In addition to its name and value, each property has associated values that
we’ll call /property attributes/:

#+cindex:attributes, property
#+cindex:property attributes
#+cindex:writable attribute
#+cindex:enumerable attribute
#+cindex:configurable attribute
- writable attribute :: specifies whether the value of the property can be set
- enumerable attribute :: specifies whether the property name is returned by a
     for/in loop
- configurable attribute :: specifies whether the property can be deleted and
     whether its attributes can be altered


#+cindex:ECMAScript 3
Prior to ECMAScript 5, all properties in objects created by your code are
writable, enumerable, and configurable.

#+cindex:ECMAScript 5
In ECMAScript 5, you can configure the attributes of your properties.

{{{heading(Object Attributes)}}}

#+cindex:object attributes
#+cindex:attributes, object
#+cindex:prototype attribute
#+cindex:class attribute
#+cindex:extensible flag

- prototype :: a reference to another object from which properties are
               inherited
- class :: a string that categorizes the type of an object
  #+cindex:ECMAScript 5
- extensible flag :: specifies (in ECMAScript 5) whether new properties may be
     added to the object


{{{heading(Types of Objects)}}}

#+cindex:object types

#+cindex:native object
- native object :: an object or class of objects defined by the ECMAScript
                   specifi- cation. Arrays, functions, dates, and regular
                   expressions (for example) are native objects.

#+cindex:host object
- host object :: an object defined by the host environment (such as a web
                 browser) within which the JavaScript interpreter is embedded.

#+cindex:user-defined object
- user-defined object :: any object created by the execution of JavaScript
     code.

#+cindex:own property
- own property :: a property defined directly on an object

#+cindex:inherited property
- inherited property :: a property defined by an object’s prototype object.

**** =Function=

**** =Boolean=

**** =Symbol=

**** =Error=

**** =EvalError=

**** =InternalError=

**** =RangeError=

**** =ReferenceError=

**** =SyntaxError=

**** =TypeError=

*** Function Properties
These global functions---functions which are called globally rather than on an
object---directly return their results to the caller.

**** ~eval()~

**** ~uneval()~

**** ~isFinite()~

**** ~isNaN()~

**** ~parseFloat()~

**** ~parseInt()~

**** ~decodeUR()~

**** ~decodeURIComponent()~

**** ~encodeURI()~

**** ~encodeURIComponent()~

**** ~escape()~

**** ~unescape()~

*** Array Objects---Indexed Collections
These objects represent collections of data which are ordered by an index
value.  This includes (typed) arrays and array-like constructs.

**** Array

**** Int8Array

**** Uint8Array

**** Uint8ClampedArray

**** Int16Array

**** Uint16Array

**** Int32Array

**** Uint32Array

**** Float32Array

**** Float64Array

**** BigInt64Array

**** BigUint64Array

*** Keyed Collections
These objects represent collections which use keys; the iterable ones such as
=Map= and =Set= contain elements which are iterable in the order of insertion.

**** =Map=

**** =Set=

**** =WeakMap=

**** =WeakSet=

*** String Objects

**** =String=

*** Boolean Objects

*** Number Objects

**** =Number=

**** =BigInt=

*** Math Objects

**** =Math=

*** Date Objects
**** =Date=
**** Article---Why you shouldn't use Moment.js...
:PROPERTIES:
:uri:      https://inventi.studio/en/blog/why-you-shouldnt-use-moment-js
:author:   InventiStudio
:date:     March 13, 2019
:END:

#+cindex:Moment.js
Everyone of us, at some point realized that or has been warned by older
friends, if lucky enough.  Whatever the reason was, at the end we all reached
for external library and the choice was obvious - Moment.js.  The most popular
JS DateTime library that gave us everything we wanted so much from native Date
API.

If it is much better than native API, why do we advise you not to use it?

1. It's slow
2. It's heavy
3. It's mutable
4. It's hard to debug


{{{heading(Alternatives)}}}

#+cindex:Day.js
#+cindex:Luxon
#+cindex:JS-Joda
#+cindex:Date-Fns
- Moment.js
- Day.js
- Luxon
- JS-Joda
- Date-Fns


{{{heading(TL;DR)}}}

Moment.js is heavy, slow, mutable and hard to debug, still yet it has some
advantages.  However you should consider using different library, e.g JS-Joda,
Luxon, Date-Fns or Day.js, depending on your needs.  And even if you decide to
stick with Moment.js, be aware of few things, e.g moment(undefined) will give
you valid date.

*** RegExp Objects

**** =RegExp=
RegExp methods:

- ~exec~
- ~test~

String methods:

- ~match~
- ~matchAll~
- ~replace~
- ~search~
- ~split~

**** RegExp in the Specification

[[https://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%25203rd%2520edition,%2520December%25201999.pdf][15 Native ECMAScript Objects --> 15.10 RegExp Objects]]

#+cindex:RegExp object
#+cindex:regular expression
#+cindex:flags, RegExp
A RegExp object contains a regular expression and the associated flags.

/The form and functionality of regular expressions is modelled after the
regular expression facility in the Perl 5 programming language./

{{{heading(15.10.1 Patterns)}}}

#+cindex:regular expression patterns
The =RegExp= constructor applies the following grammar to the input pattern
string.  An error occurs if the grammar cannot interpret the string as an
expansion of Pattern.

{{{heading(15.10.2 Pattern Semantics)}}}

A regular expression pattern is converted into an internal function using the
process described below.  An implementation is encouraged to use more efficient
algorithms than the ones listed below, as long as the results are the same.

**** Creating a RegExp

You construct a regular expression in one of two ways:

{{{heading(Using a Literal)}}}

#+cindex:literal regular expression
Using a regular expression literal, which consists of a pattern enclosed
between slashes, as follows:

: var re = /ab+c/;

Regular expression literals provide compilation of the regular expression when
the script is loaded.  If the regular expression remains constant, using this
can improve performance.

{{{heading(Calling the RegExp Constructor)}}}

#+cindex:RegExp constructor function
Or calling the constructor function of the RegExp object:

: var re = new RegExp('ab+c');

Using the constructor function provides runtime compilation of the regular
expression.  Use the constructor function when you know the regular expression
pattern will be changing, or you don't know the pattern and are getting it from
another source, such as user input.

**** Creating a RegExp Pattern

A regular expression pattern is composed of simple characters or a combination
of simple and special characters

***** Special Characters

Following is a complete list and description of the special characters that can
be used in regular expressions.

****** Assertions
Indicates in some way that a match is possible. Assertions include look-ahead,
look-behind, and conditional expressions.

****** Boundaries
Indicate the beginnings and endings of lines and words.

****** Character Classes
Distinguishes kinds of characters such as, for example, distinguishing between
letters and digits.

****** Groups and Ranges
Indicates groups and ranges of expression characters.

****** Quantifiers
Indicates numbers of characters or expressions to match.

****** Unicode Property Classes
Distinguishes based on unicode character properties, for example, upper and
lower case letters, math symbols, and punctuation.

***** List of Special Characters

- \ :: A backslash that precedes a non-special character indicates that the
       next character is special and is not to be interpreted literally.  A
       backslash that precedes a special character indicates that the next
       character is not special and should be interpreted literally.

       #+cindex:multiline flag
       #+cindex:flag, multiline
- ^ :: Matches beginning of input.  If the multiline flag is set to true, also
       matches immediately after a line break character.

       #+cindex:multiline flag
       #+cindex:flag, multiline
- $ :: Matches end of input.  If the multiline flag is set to true, also
       matches immediately before a line break character.

- * :: Matches the preceding expression 0 or more times. Equivalent to {0,}.

- + :: Matches the preceding expression 1 or more times. Equivalent to {1,}.

- ? :: Matches the preceding expression 0 or 1 time. Equivalent to {0,1}.

       #+cindex:dotAll flag
       #+cindex:s flag
       #+cindex:flag, multiline
- . :: (The decimal point) matches any single character except the newline
       character, by default.  If the =s= ("dotAll") flag is set to true, it
       also matches newline characters.

       #+cindex:capturing parentheses
- (x) :: Matches 'x' and remembers the match.  The parentheses are called
         /capturing parentheses/.

         #+cindex:non-capturing parentheses
- (?:x) :: Matches 'x' but does not remember the match. The parentheses are
           called /non-capturing parentheses/, and let you define
           subexpressions for regular expression operators to work with.

           #+cindex:lookahead
- x(?=y) :: Matches 'x' only if 'x' is followed by 'y'. This is called a
            /lookahead/.

            #+cindex:negated lookahead
            #+cindex:lookahead, negated
- x(?!y) :: Matches 'x' only if 'x' is not followed by 'y'. This is called a
            /negated lookahead/.

            #+cindex:lookbehind
- (?<=y)x :: Matches x only if x is preceded by y. This is called a
             /lookbehind/.[fn:13]

             #+cindex:negated lookbehind
             #+cindex:lookbehind, negated
- (?<!y)x :: Matches x only if x is not preceded by y. This is called a
             /negated lookbehind/.[fn:13]

- x|y :: Matches 'x', or 'y' (if there is no match for 'x').

- {n} :: Matches exactly n occurrences of the preceding expression.  N must be
         a positive integer.

- {n,} :: Matches at least n occurrences of the preceding expression.  N must
          be a positive integer.

- {n,m} :: Where n and m are positive integers and n <= m.  Matches at least n
           and at most m occurrences of the preceding expression.  When m is
           omitted, it's treated as ∞.

           #+cindex:character set
- [xyz] :: Character set.

- [^xyz] :: Negated character set.

- [\b] :: Matches a backspace (U+0008). You need to use square brackets if you
          want to match a literal backspace character. (Not to be confused with
          \b.)

          #+cindex:word boundary
- \b :: Matches a word boundary.

        A word boundary matches the position between a word character followed
        by a non-word character, or between a non-word character followed by a
        word character, or the beginning of the string, or the end of the
        string.

        #+attr_texinfo: :tag Note
        #+begin_quote
        JavaScript's regular expression engine defines a specific set of
        characters to be "word" characters. Any character not in that set is
        considered a non-word character. This set of characters is fairly
        limited: it consists solely of the Roman alphabet in both upper- and
        lower-case, decimal digits, and the underscore character. Accented
        characters, such as "é" or "ü" are, unfortunately, treated as non-word
        characters for the purposes of word boundaries, as are ideographic
        characters in general.
        #+end_quote

        #+cindex:non-word boundary
- \B :: Matches a non-word boundary.  This matches the following cases:

  - Before the first character of the string

  - After the last character of the string

  - Between two word characters

  - Between two non-word characters

  - The empty string

    #+cindex:control character
- \cX :: Where X is a character ranging from A to Z. Matches a control
         character in a string, i.e., =/\cM/= matches control-M (U+00D).

         #+cindex:digit
- \d :: Matches a digit character. Equivalent to [0-9].

        #+cindex:non-digit
- \D :: Matches a non-digit character. Equivalent to [^0-9].

        #+cindex:form feed
        #+cindex:@code{\f}
- \f :: Matches a form feed (U+000C).

        #+cindex:line feed
        #+cindex:new line
        #+cindex:@code{\n}
- \n :: Matches a line feed (U+000A).

        #+cindex:carriage return
        #+cindex:@code{\r}
- \r :: Matches a carriage return (U+000D).

        #+cindex:white space
        #+cindex:@code{\s}
- \s :: Matches a white space character, including space, tab, form feed, line
        feed.

        : [\f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]

        #+cindex:non-white spacde
        #+cindex:@code{\S}
- \S :: Matches a character other than white space.

        #+cindex:tab
        #+cindex:@code{\t}
- \t :: Matches a tab (U+0009).

        #+cindex:vertical tab
        #+cindex:@code{\v}
- \v :: Matches a vertical tab (U+000B).

        #+cindex:word character
        #+cindex:@code{\w}
- \w :: Matches any alphanumeric character including the underscore.  Equivalent
        to [A-Za-z0-9_].

        #+cindex:non-word character
        #+cindex:@code{\W}
- \W :: Matches any non-word character. Equivalent to [^A-Za-z0-9_].

        #+cindex:back reference
- \n :: Where n is a positive integer, a back reference to the last substring
        matching the n parenthetical in the regular expression (counting left
        parentheses).

        #+cindex:@code{NULL} character
- \0 :: Matches a =NULL= (U+0000) character.  Do not follow this with another
        digit, because \0<digits> is an octal escape sequence.  Instead use
        =\x00=.

        #+cindex:hex
- \xhh :: Matches the character with the code =hh= (two hexadecimal digits)

          #+cindex:hex
- \uhhhh :: Matches the character with the code =hhhh= (four hexadecimal
            digits).

            #+cindex:u flag
            #+cindex:Unicode value
- \u{hhhh} :: (only when u flag is set) Matches the character with the Unicode
              value =hhhh= (hexadecimal digits).

**** Working with Regular Expressions

#+caption:Methods that use regular expressions
#+name:methods-using-reg-exps
| Method       | Description                                                                                              |
|--------------+----------------------------------------------------------------------------------------------------------|
| exec (RE)    | executes a search for a match in a string; returns an array of information or null on a mismatch         |
| test (RE)    | tests for a match in a string;  returns true or false;                                                   |
|--------------+----------------------------------------------------------------------------------------------------------|
| match (S)    | returns an array containing all of the matches, including capturing groups, or null if no match is found |
| matchAll (S) | returns an iterator containing all of the matches, including capturing groups                            |
| search (S)   | tests for a match in a string; returns the index of the match, or -1 if the search fails                 |
| replace (S)  | executes a search for a match in a string; replaces the matched substring with a replacement substring.  |
| split (S)    | uses a regular expression or a fixed string to break a string into an array of substrings                |
|--------------+----------------------------------------------------------------------------------------------------------|

- When you want to know whether a pattern is found in a string, use the ~test~ or
  ~search~ method;

- for more information (but slower execution) use the ~exec~ or ~match~
  methods.

  - If you use ~exec~ or ~match~ and if the match succeeds, these methods
    return an array and update properties of the associated regular expression
    object and also of the predefined regular expression object, =RegExp=.

  - If the match fails, the ~exec~ method returns =null= (which coerces to
    =false=).

#+caption:Example demonstrating results of regular expression match
#+name:regexp-match-results
#+begin_src js
var myRe = /d(b+)d/g;
var myArray = myRe.exec('cdbbdbsbz');
#+end_src

- ~myArray~ :: 
  - The matched string and all remembered substrings.
    : ['dbbd', 'bb', index: 1, input: 'cdbbdbsbz']

  - ~index~ :: The 0-based index of the match in the input string.
               : 1

  - ~input~ :: The original string.
               : "cdbbdbsbz"

  - ~[0]~ :: The last matched characters.
             : "dbbd"

  - ~[1],...,[n]~ :: remembered parenthesized substring matches

- ~myRe~ :: 
  - ~lastIndex~ :: The index at which to start the next match. (This
                   property is set only if the regular expression
                   uses the =g= option)

  - ~source~ :: The text of the pattern.  Updated at the time that the regular
                expression is created, not executed.


{{{heading(Using parenthesized substring matches)}}}

#+cindex:parenthesized substring matches
Including parentheses in a regular expression pattern causes the corresponding
submatch to be remembered.  For example, =/a(b)c/= matches the characters 'abc'
and remembers 'b'.  To recall these parenthesized substring matches, use the
Array elements [1], ..., [n].  The number of possible parenthesized substrings
is unlimited. The returned array holds all that were found.

***** Searching with Flags
#+cindex:flags
Regular expressions have six optional flags that allow for functionality like
global and case insensitive searching.  These flags can be used separately or
together in any order, and are included as part of the regular expression.

#+caption:Regular expression flags
#+name:regular-expression-flags
| Flag | Description                                                                                   |
|------+-----------------------------------------------------------------------------------------------|
| g    | Global search                                                                                 |
| i    | Case-insensitive search                                                                       |
| m    | Multi-line search                                                                             |
| s    | Allows =.= to match newline characters [fn:13]                                                |
| u    | "unicode"; treat a pattern as a sequence of unicode code points                               |
| y    | Perform a "sticky" search that matches starting at the current position in the target string. |
|------+-----------------------------------------------------------------------------------------------|

The behavior associated with the 'g' flag is different when the ~.exec()~
method is used.  (The roles of "class" and "argument" get reversed: In the case
of ~.match()~, the string class (or data type) owns the method and the regular
expression is just an argument, while in the case of ~.exec()~, it is the
regular expression that owns the method, with the string being the argument.
Contrast ~str.match(re)~ versus ~re.exec(str)~.)  The 'g' flag is used with the
~.exec()~ method to get iterative progression.

*** Error Objects

*** Structured Data

**** ArrayBuffer

**** Shared ArrayBuffer

**** Atomics

**** DataView

**** JSON

*** Control Abstraction Objects

*** Reflection

*** Internationalization
*** WebAssembly
*** Other

** About This
#+cindex:this, about
*** this Keyword

#+cindex:this, keyword
=this= is a /keyword/, not a variable or property name.  JavaScript syntax does
not allow it to be assigned to or given a dynamic value.

#+cindex:scope, this
#+cindex:this scope
=this= does *not* have a /dynamic scope/.  This means nested functions do *not*
inherit the =this= value of their caller.  If a nested function is invoked as a
/method/, its =this= value is the object it was invoked on.  If a nested
function is invoked as a /function/ then its =this= value will be either the
global object (non-strict mode) or =undefined= (strict mode).

If you want to access the =this= value of the outer function, you need to store
that value into a variable that is in scope for the inner function.  It is
common to use the variable =self= for this purpose.  For example:

#+caption:To allow a nested function access to 'this', save it as 'self'
#+name:nested-function-access-to-this
#+header: :results output :exports both
#+begin_src js
  var o = {				// Object o
      m: function() {			// Method m of Object o
          var self = this;		// save 'this' as 'self'
          console.log(this === o);	// 'true'; 'this' is 'o'
          f();				// Invoke helper function 'f'

          function f() {			// Nested helper function 'f'
              console.log(this === o);	// 'false'; 'this' is 'global' or 'undefined'
              console.log(self === o);	// 'true'; 'self' is in f's scope'
          }
      }
  }
  o.m();					// Invoke the method m on the object o
#+end_src

#+RESULTS: nested-function-access-to-this
: true
: false
: true
*** this and the Call Site

#+cindex:call site
#+cindex:call stack
- call site ::  the location in code where a function is called (not where it’s
               declared).  Inspect the call-site to answer the question: what
               is this /this/ a reference to?

- call stack :: the stack of functions that have been called to get us to the
                current moment in execution.  The call-site we care about is in
                the invocation before the currently executing function.


Take care when analyzing code to find the actual call-site (from the
call-stack), because it’s the only thing that matters for ~this~ binding.  If
you’re trying to diagnose ~this~ binding, use the developer tools to get the
call-stack, then find the second item from the top, and that will show you the
real call-site.

*** Call Site Rules
How does the call site determine what the ~this~ value will be?  There are
essentially four rules that may apply.  After looking at the four rules
independently, we must determine which one will be followed, that is, what the
precedence of the four rules are.

**** Default Binding
#+cindex:default binding
#+cindex:standalone function invocation
Default binding occurs when a function is invoked in the global context:
standalone function invocation.  This rule is the default, catch-all rule when
no other rule applies.  When default binding applies, the ~this~ value is
assigned either a reference to the global object or =undefined= if =strict
mode= is in effect.

#+caption:Default Binding Rule
#+name:default-binding-rule
#+begin_src js -n
function foo() {
    // "use strict";
    console.log(this.a);
}

var a = 2;

foo(); // 2 or TypeError if foo is in strict mode
#+end_src

Variables declared in the global scope (as is ~a~) are synonymous with
global-object properties of the same name.  They are the same thing.  Thus, ~a~
=== ~global.a~, for example.

When ~foo~ is invoked, ~this.a~ resolves to ~global.a~.  This occurs because
the default binding rule applies.  How can it be determined that the default
binding rule applies?  The call site of the function invocation is inspected
and seen to be at the global level.  The function is being invoked as a simple
function.

If ~strict~ mode is in effect, then the ~this~ value is assigned the
=undefined= value, not the global object.  If strict mode were in effect for
the invocation of the above function, then the function invocation would throw
a =TypeError= exception, since =undefined= cannot resolve a reference.  Note
that the mode of the call site is irrelevant; what matters is the mode of the
function being invoked.

**** Implicit Binding
#+cindex:implicit binding
#+cindex:context object
The implicit binding rule applies when the call site has a /context object/.

#+caption:Implicit Binding Rule
#+name:implicit-binding-rule
#+begin_src js -n
  function foo() {
      console.log(this.a);
  }

  var obj = {
      a: 2,
      foo: foo;
  }

  obj.foo() // 2
#+end_src

Here, ~foo~ (the function) is declared and implemented exactly as in the
previous example, at the global level.  A reference to it is then made from
within the object ~obj~.  The function is not really owned nor contained by the
object, but merely referenced from it.

However, the object ~obj~ is invoking the function, and thus the context of the
call is the ~obj~ object, and the function's ~this~ value is bound to that
context.

When there is a context object for a function reference, the implicit binding
rule says that it’s that object that should be used for the function call’s
~this~ binding.  Therefore, because ~obj~ is the ~this~ for the ~foo()~ call,
~this.a~ is synonymous with ~obj.a~.

Only the final method call matters to the call site.  Thus, some call such as:

: obj1.obj2.obj3.foo()

the context of the call to ~foo()~ is ~obj3~ only.

***** Implicitly Losing Context
One of the most common frustrations that ~this~ binding creates is when an
implicitly bound function loses that binding, which usually means it falls back
to the default binding of either the global object or =undefined=, depending on
strict mode.

#+caption:Losing Implicit Context
#+name:losing-implicit-context
#+begin_src js -n
  function foo() {
      console.log( this.a );
  }

  var obj ={
      a: 2,
      foo: foo
  };

  var bar = obj.foo; // function reference/alias!

  var a = "oops, global"; // `a` also property on global object

  bar(); // "oops, global"
#+end_src

The important thing to note here is that ~var bar = obj.foo~ resolves to ~var
bar = foo~, that is, a reference to the function itself, and the object ~obj~
is completely ignored.  When ~bar~ is invoked, it invokes ~foo~ from the global
scope as a plain function call, and thus the default binding rule applies.

The more subtle, more common, and more unexpected way this occurs is when we
consider passing a callback function:

#+caption:Losing Implicit Context via a Callback
#+name:losing-implicit-context-via-callback
#+begin_src js -n
  function foo() {
      console.log( this.a );
  }

  function doFoo(fn) {
      // `fn` is just another reference to `foo`
      fn(); // <-- call-site!
  }

  var obj = {
      a: 2,
      foo: foo
  };

  var a = "oops, global"; // `a` also property on global object

  doFoo( obj.foo ); // "oops, global"
#+end_src

Parameter passing is just an implicit assignment, and since we’re passing a
function, it’s an implicit reference assignment, so the end result is the same
as the previous snippet.

It’s quite common that our function callbacks lose their ~this~ binding, as
we’ve just seen.  But another way that this can surprise us is when the
function we’ve passed our callback to intentionally changes the this for the
call.  Event handlers in popular JavaScript libraries are quite fond of forcing
your callback to have a this that points to, for instance, the DOM element that
triggered the event.  While that may sometimes be useful, other times it can be
downright infuriating. Unfortunately, these tools rarely let you choose.

**** Explicit Binding
#+cindex:explicit binding
What if you want to force a function call to use a particular object for the
~this~ binding, without putting a property function reference on the object?
“All” functions in the language have some utilities available to them (via
their =[ [Prototype] ]=) which can be useful for this task.  Specifically,
functions have ~call(..)~ and ~apply(..)~ methods.

#+cindex:explicit binding
How do these utilities work?  They both take, as their first parameter, an
object to use for the ~this~, and then invoke the function with that ~this~.
Since you are directly stating what you want the ~this~ to be, we call it
/explicit/ binding.

#+caption:Explicit Binding
#+name:explicit-binding
#+begin_src js -n
  function foo() {
      console.log(this.a);
  }

  var obj = {
      a: 2
  };

  foo.call(obj); // 2
#+end_src

If you pass a simple primitive value (of type =string=, =boolean=, or =number=)
as the ~this~ binding, the primitive value is wrapped in its object-form (~new
String(..)~, ~new Boolean(..)~, or ~new Number(..)~, respectively).  This is
often referred to as “boxing.”

Unfortunately, explicit binding alone still doesn’t offer any solution to the
issue mentioned previously, of a function “losing” its intended ~this~ binding,
or just having it paved over by a framework, etc.

***** Hard Binding
But a variation pattern around explicit binding actually does the trick.

#+caption:Hard Binding
#+name:hard-binding
#+begin_src js -n
  function foo() {
      console.log(this.a);
  }

  var obj = {
      a: 2
  };

  var bar = function() {
      foo.call(obj);
  };

  bar(); // 2
  setTimeout(bar, 100); // 2

  // hard-bound `bar` can no longer have its `this` overridden
  bar.call(window); // 2
#+end_src

We create a function ~bar()~ which, internally, manually calls ~foo.call(obj)~,
thereby forcibly invoking ~foo~ with ~obj~ binding for ~this~.  No matter how
you later invoke the function ~bar~, it will always manually invoke ~foo~ with
~obj~.

This binding is both explicit and strong, so we call it /hard/ binding.

The most typical way to wrap a function with a hard binding creates a
pass-through of any arguments passed and any return value received:

#+caption:Hard Binding with Pass-Through
#+name:harding-binding-pass-through
#+begin_src js -n
  function foo(something) {
      console.log( this.a, something );
      return this.a + something;
  }

  var obj = {
      a:2
  };

  var bar = function() {
      return foo.apply( obj, arguments );
  };

  var b = bar(3); // 2 3
  console.log(b); // 5
#+end_src

**** new Binding
#+cindex:@code{new} binding

**** Precedence of Call Site Rules
#+cindex:precedence of binding rules

*** this as Object Reference of Activation Object
#+cindex:activation object
#+cindex:this, keyword
When a function is created, a keyword called ~this~ is created (behind the
scenes), which links to the object in which the function operates.  ~this~ is
available to the scope of its function, yet is a reference to the object of
which that function is a property/method.  The keyword ~this~ looks and acts
like any other variable, except you can't modify it.  As opposed to arguments
and any parameters sent to the function, ~this~ is a keyword (not a property)
in the *call/activation* object.

#+begin_src js
var cody = {
    living:true,
    age:23,
    gender:'male',
    getGender:function() { return cody.gender; }
};

console.log(cody.getGender()); // logs 'male'
#+end_src

Notice how inside of the ~getGender~ function, we are accessing the gender
property using dot notation (e.g. ~cody.gender~) on the cody object itself.
This can be rewritten using ~this~ to access the =cody= object because ~this~
points to the =cody= object.

#+begin_src js
var cody = {
    living:true,
    age:23,
    gender:'male',
    getGender:function() { return this.gender; }
};

console.log(cody.getGender()); // logs 'male'
#+end_src

The ~this~ used in ~this.gender~ simply refers to the =cody= object on which
the function is operating.

{{{heading(The Value of this)}}}

#+cindex:@code{this} value
#+cindex:strict mode
The value of ~this~, passed to all functions, is based on the context in which
the function is called at runtime.  The value of ~this~ in nonmethod functions is
the global object unless strict mode is in effect, in which case the value will
be =undefined=.  The value of ~this~ when passed to a method will be a
reference to the object making the call.

The ~myObject~ object in the code below is given a property called =sayFoo=,
which points to the ~sayFoo~ function.  When the ~sayFoo~ function is called
from the global scope, this refers to the window object.  When it is called as
a method of ~myObject~, this refers to ~myObject~.

#+begin_src js -n
var foo = 'foo';
var myObject = {foo: 'I am myObject.foo'};

var sayFoo = function() {
    console.log(this['foo']);
};

// give myObject a sayFoo property and have it point to sayFoo function
myObject.sayFoo = sayFoo;

myObject.sayFoo(); // logs 'I am myObject.foo'

sayFoo(); // logs 'foo'
#+end_src

Clearly, the value of ~this~ is based on the context in which the function is
being called.  Consider that both ~myObject.sayFoo~ and ~sayFoo~ point to the
same function.  However, depending upon where (i.e. the context) ~sayFoo()~ is
called from, the value of ~this~ is different.

*** this in Nested Functions

#+cindex:ECMAScript 3
#+cindex:head object
#+cindex:nest functions and @code{this}
You might be wondering what happens to ~this~ when it is used inside of a
function that is contained inside of another function.  The bad news is in ECMA
3, ~this~ loses its way and refers to the head object (window object in
browsers), instead of the object within which the function is defined.

In the code below, ~this~ inside of ~func2~ and ~func3~ loses its way and
refers not to =myObject= but instead to the head object.

#+begin_src js -n
var myObject = {
    func1:function() {
        console.log(this); //logs myObject
        varfunc2=function() {
            console.log(this) //logs window, and will do so from this point on
            varfunc3=function() {
                console.log(this);//logs window, as it’s the head object
            }();
        }();
    }
};

myObject.func1();
#+end_src

#+cindex:ECMAScript 5
The good news is that this will be fixed in ECMAScript 5.  For now, you should
be aware of this predicament, especially when you start passing functions
around as values to other functions.

Consider the code below and what happens when passing an anonymous function to
~foo.func1~.  When the anonymous function is called inside of ~foo.func1~ (a
function inside of a function) the ~this~ value inside of the anonymous
function will be a reference to the head object.

#+begin_src js -n
var foo = {
    func1:function(bar){
        bar();//logs window, not foo
        console.log(this); // the this keyword here will be a reference to foo object
    }
}

foo.func1( function() { console.log(this) } );
#+end_src

#+cindex:scope chain and @code{this}
#+cindex:@code{that}
So that the ~this~ value does not get lost, you can simply use the scope chain
to keep a reference to ~this~ in the parent function.  The code below
demonstrates how, using a variable called ~that~, and leveraging its scope, we
can keep better track of function context.

#+begin_src js -n
var myObject = {
    myProperty: 'I can see the light',
    myMethod:function() {
        var that=this; // store a reference to this (i.e. myObject) in my Methodscope
        var helperFunction function() { //child function
            // logs 'I can see the light' via scope chain because that=this
            console.log(that.myProperty); // logs 'I can see the light'
            console.log(this); // logs window object, if we don't use "that"
        }();
    }
}

myObject.myMethod(); // invoke myMethod
#+end_src

The following is an example where we call ~forEach~ with a function to iterate
over an array.  Calling ~logHiToFriends~ produces an error:

#+begin_src js -n
var jane = {
    name: 'Jane',
    friends: [ 'Tarzan', 'Cheeta' ],
    logHiToFriends: function () {
        'use strict';
        this.friends.forEach(function (friend) {
            // `this` is undefined here
            console.log(this.name+' says hi to '+friend);
        });
    }
}

> jane.logHiToFriends()
TypeError: Cannot read property 'name' of undefined
#+end_src

So while ~this~ is defined inside the ~logHiToFriends~ method, it is
=undefined= inside the ~forEach~ function.  In addition to the prevous method
of storing the ~this~ value inside a different variable, e.g., ~that~,
~forEach~ has a second parameter that allows you to provide a value for ~this~:

#+begin_src js -n
logHiToFriends: function () {
    'use strict';
    this.friends.forEach(function (friend) {
        console.log(this.name+' says hi to '+friend);
    }, this);
}
#+end_src

#+attr_texinfo: :options Array.prototype forEach ( callback( curValue [, index [, array]]) [, thisArg] );
#+begin_defmethod

The ~forEach()~ method calls a provided callback function once for each element
in an array in ascending order.  It is not invoked for index properties that
have been deleted or are uninitialized (sparse arrays).  The ~callback~ is
invoked with three arguments.  Unlike ~map()~ or ~reduce()~ it always returns
the value =undefined= and is not chainable.  The typical use case is to execute
side effects at the end of a chain.  ~forEach()~ does not mutate the array on
which it is called (although ~callback~, if invoked, may do so).

- {{{var(callback)}}} :: Function to execute on each element, taking three
     arguments:

  - {{{var(curValue)}}} :: The current element being processed in the array.

  - {{{var(index)}}} (optional) :: The index of the current element being
       processed in the array.

  - {{{var(array)}}} (optional) :: The array ~forEach()~ was called upon.

- {{{var(thisArg)}}} (optional) :: Value to use as ~this~ when executing
     callback.

- Return Value :: =undefined=


There is no way to stop or break a ~forEach()~ loop other than by throwing an
exception.  If you need such behavior, the ~forEach()~ method is the wrong
tool.  Early termination may be accomplished with:

- A simple ~for~ loop

- A ~for...of~ / ~for...~ in loops

- ~Array.prototype.every()~

- ~Array.prototype.some()~

- ~Array.prototype.find()~

- ~Array.prototype.findIndex()~


Array methods: ~every()~, ~some()~, ~find()~, and ~findIndex()~ test the array
elements with a predicate returning a truthy value to determine if further
iteration is required.
#+end_defmethod

*** Controlling this with call and apply
You can overwrite/control the value of ~this~ using ~apply()~ or ~call()~ to
define what object ~this~ points to when invoking a function.  By doing so, the
default way in which JavaScript determines the value of ~this~ is overridden.

Below, we create an object and a function.  We then invoke the function via
~call()~ so that the value of ~this~ inside the function uses =myObject= as its
context.  The statements inside the ~myFunction~ function will then populate
=myObject= with properties instead of populating the head object.  We have
altered the object to which ~this~ (inside of ~myFunction~) refers.

#+begin_src js -n

var myObject = {};

var myFunction = function(param1, param2) {
    //set via call() 'this' points to myObject when function is invoked
    this.foo=param1;
    this.bar=param2;
    console.log(this) // logs Object { foo='foo', bar='bar' }
};

myFunction.call(myObject, 'foo', 'bar'); // invoke function, set this value to myObject

console.log(myObject) // logs Object {foo = 'foo', bar = 'bar'}
#+end_src

In the example above, we are using ~call()~, but apply()~ could be used as
well.  The difference between the two is how the parameters for the function
are passed.  Using ~call()~, the parameters are just comma-separated values.
Using ~apply()~, the parameter values are passed inside of an array.

: myFunction.apply(myObject, ['foo', 'bar']); // invoke function, set this value

*** this and a Constructor Function
When a function is invoked with the ~new~ keyword, the value of ~this~ within
the function refers to the instance itself.  In the constructor function, we
can leverage the object via ~this~ before the object is actually created.

Below, we set up a =Person= constructor function that uses ~this~ to reference
an object being created.  When an instance of =Person= is created, ~this.name~
will reference the newly created object and place a property called =name= in
the new object with a value from the parameter (=name=) passed to the
constructor function.

#+begin_src js -n
var Person = function(name) {
    this.name=name || 'johndoe'; //this will refer to the instance created
}

var cody = new Person('Cody Lindley'); // create an instance, based on Person constructor

console.log(cody.name); // logs 'Cody Lindley'
#+end_src

~this~ refers to the "object that is to be" when the constructor function is
invoked using the ~new~ keyword.  Had we not used the ~new~ keyword, the value
of ~this~ would be the context in which Person is invoked---in this case the
head object (i.e., =window=).

When in strict mode, if a constructor function is called without the =new=
keyword, any attempt to set a property will raise a warning, since the ~this~
value will be =undefined=:

#+begin_src js
function Point(x, y) {
    'use strict';
    this.x = x;
    this.y = y;
}

> var pt = Point(3, 1);
TypeError: Cannot set property 'x' of undefined
#+end_src

Due to strict mode, you get a warning when you accidentally forget =new= and
call it as a function.  In sloppy mode, you don’t get a warning, and global
variables ~x~ and ~y~ are created.

*** this in a Prototype Method
When used in functions added to a constructorʼs prototype property, ~this~
refers to the instance on which the method is invoked.  The keyword ~this~ is
used to refer to instances when used inside of a method contained in the
prototype object.  If the instance does not contain the property, the prototype
lookup begins.

*** this and the Global Object
**** The Global Object
The global object is a predefined object that serves as a placeholder for the
global properties and functions of JavaScript.  All other predefined objects,
functions, and properties are accessible through the global object.

#+cindex:@code{this} keyword
#+cindex:global object, this
#+cindex:scope chain, top, global object
In top-level JavaScript code, you can refer to the global object with the
keyword ~this~.  It is rarely necessary to refer to the global object in this
way, however, because the global object serves as the top of the scope chain,
which means that unqualified variable and function names are looked up as
properties of the object.  When JavaScript code refers to the ~parseInt()~
function, for example, it is referring to the ~parseInt~ property of the global
object.

The fact that the global object is the top of the scope chain also means that
all variables declared in top-level JavaScript code become properties of the
global object.

**** Properties of the Global Object using this
#+cindex:global object properties, using @code{this}
In core JavaScript, none of the predefined properties of the global object are
enumerable, so you can list all implicitly and explicitly declared global
variables with a =for/in= loop like this:

#+begin_src js
var variables = ""
for(var name in this)
    variables += name + "\n";
#+end_src

*** this as a Primary Expression
#+cindex:expression
An /expression/ is a phrase of JavaScript that a JavaScript interpreter can
evaluate to produce a value.

- A constant embedded literally in your program is a very simple kind of
  expression.

- A variable name is also a simple expression that evaluates to whatever value
  has been assigned to that variable.

  #+pindex:expression, complex
- Complex expressions are built from simpler expressions.

  #+cindex:array access expression
  - An /array access expression/, for example, consists of one expression that
    evaluates to an array followed by an open square bracket, an expression
    that evaluates to an integer, and a close square bracket.  This new, more
    complex expression evaluates to the value stored at the specified index of
    the specified array.

    #+cindex:function invocation expression
  - Similarly, a /function invocation expression/ consists of one expression
    that evaluates to a function object and zero or more additional expressions
    that are used as the arguments to the function.


#+cindex:primary expression
The simplest expressions, known as /primary expressions/, are those that stand
alone---they do not include any simpler expressions.  Primary expressions in
JavaScript are:

- constant or literal values

  - Literals are constant values that are embedded directly in your program.

    - number literals

    - string literals

    - regular expression literal

- certain language keywords

  - Some of JavaScript’s reserved words are primary expressions:

    - ~true~

    - ~false~

    - ~null~

      #+cindex:@code{this} keyword
    - ~this~: Evaluates to the "current" object

      Unlike the other keywords, ~this~ is not a constant---it evaluates to
      different values in different places in the program.  The ~this~ keyword
      is used in object-oriented programming.  Within the body of a method,
      ~this~ evaluates to the object on which the method was invoked.

- variable references

*** this and Event Handlers
**** Event Handler Invocation
- event handler arguments
- event handler invocation context (~this~ value)
- invocation scope
- event handler return value

**** Event Handler Arguments
#+cindex:event object
Event handlers are normally invoked with an event object as their single
argument.  The properties of the event object provide details about the event.

**** Event Handler Context
#+cindex:event handler
An important thing to know about event handlers is that within the code of an
event handler, the ~this~ keyword refers to the document element that triggered
the event.

When you register an event handler by setting a property, it looks as if you
are defining a new method on the document element:

#+begin_src js
e.onclick = function() { /* handler code */ };
#+end_src

Event handlers are invoked as methods of the object on which they are defined.
That is, within the body of an event handler, the ~this~ keyword refers to the
event target.

#+cindex:@code{addEventListener()}
#+cindex:@code{attachEvent()}
Handlers are invoked with the target as their ~this~ value even when registered
using ~addEventListener()~.  This is not true for ~attachEvent()~: handlers
registered with ~attachEvent()~ are invoked as functions, and their ~this~
value is the global (Window) object.

You can work around this with code like this:

#+begin_src js
/*
,* Register the specified handler function to handle events of the specified
,* type on the specified target. Ensure that the handler will always be
,* invoked as a method of the target.
,*/
function addEvent(target, type, handler) {
    if (target.addEventListener)
        target.addEventListener(type, handler, false); 
    else
        target.attachEvent("on" + type, function(event) {
            // Invoke the handler as a method of target,
            // passing on the event object
            return handler.call(target, event);
        });
}
#+end_src

**** Event Handler Scope
Like all JavaScript functions, event handlers are lexically scoped.  They are
executed in the scope in which they are defined, not the scope from which they
are invoked, and they can access any local variables from that scope.

***** HTML Event Handlers
Event handlers registered as HTML attributes are a special case, however.  They
are converted into top-level functions that have access to global variables but
not to any local variables.  But, for historical reasons, they run with a
modified scope chain.  Event handlers defined by HTML attributes can use the
properties of the target object, the containing =<form>= object (if there is
one), and the =Document= object as if they are local variables.

HTML attributes are not natural places to include long strings of code, and
this modified scope chain allows helpful shortcuts.  You can use ~tagName~
instead of ~this.tagName~.  You can use ~getElementById~ instead of
~document.getElementById~.  And, for document elements that are inside a
=<form>=, you can refer to any other form element by ID, using =zipcode=, for
example, instead of =this.form.zipcode=.

#+cindex:shadow
On the other hand, the modified scope chain of HTML event handlers is a source
of pitfalls, since the properties of each of the objects in the chain shadow
any properties of the same name in the global object.  The =Document= object
defines a (rarely used) ~open()~ method, for example, so an HTML event handler
that wants to invoke the ~open()~ method of the =Window= object must explicitly
write ~window.open~ instead of ~open~.

There is a similar (but more pernicious) problem with forms, because the names
and IDs of form elements define properties on the containing form element.  So
if a form contains an element with the ID “location”, for example, all HTML
event handlers within that form must use ~window.location~ instead of
~location~ if they want to refer to the window’s =Location= object.

**** Handler Return Value
#+cindex:event handler return value
The return value of an event handler registered by setting an object property
or an HTML attribute is sometimes significant.  In general, a return value of
=false= tells the browser that it should not perform the default action
associated with the event.  The ~onclick~ handler of a =Submit= button in a
form, for example, can return =false= to prevent the browser from submitting
the form.  Similarly, an ~onkeypress~ handler on an input field can filter
keyboard input by returning =false= if the user types an inappropriate
character.

#+cindex:@code{addEventListener()}
#+cindex:@code{attachEvent()}
It is important to understand that event handler return values are significant
only for handlers registered as properties.  We’ll see below that event
handlers registered with ~addEventListener()~ or ~attachEvent()~ must instead
call the ~preventDefault()~ method or set the =returnValue= property of the
event object.

**** Form Event Handlers
#+cindex:@code{<form>} element
#+cindex:@code{form} property
#+cindex:Form property
#+cindex:document element, event handler
Since elements within a =<form>= element have a ~form~ property
that refers to the containing form, the event handlers of these elements can
always refer to the =Form= object as ~this.form~.  Going a step further, this
means that an event handler for one form element can refer to a sibling form
element named ~x~ as ~this.form.x~.

*** Understanding JavaScript Function Invocation and "this"
- https://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/
- By Yehuda Katz
- 10 Aug 2011


{{{heading(Core Function Invocation Primitive)}}}

#+cindex:core function invocation primitive
Are the semantics of ~this~ in function invocations confusing?  If so, then a
lot of this confusion is cleared up by understanding the core function
invocation primitive, and then looking at all other ways of invoking a function
as sugar on top of that primitive.  This is exactly how the ECMAScript spec
thinks about it.

{{{subheading(A Function's ~call~ Method)}}}

This is the core function invocation primitive.  The call method is relatively
straight forward.

1. Make an argument list (~argList~) out of parameters 1 through the end

2. The first parameter is ~thisValue~

3. Invoke the function with ~this~ set to ~thisValue~ and the ~argList~ as its
   argument list


For example:

#+begin_src js
function hello(thing) {
  console.log(this + " says hello " + thing);
}

hello.call("Yehuda", "world") //=> Yehuda says hello world
#+end_src

We invoked the ~hello~ method with this set to "Yehuda" and a single argument
"world".  This is the core primitive of JavaScript function invocation.  You can
think of all other function calls as desugaring to this primitive. (to
"desugar" is to take a convenient syntax and describe it in terms of a more
basic core primitive).

**** Simple Function Invocation

Invoking functions with ~call~ all the time would be pretty annoying.
JavaScript allows us to invoke functions directly using the =parens= syntax
(~hello("world"~).  When we do that, the invocation desugars:

#+begin_src js
function hello(thing) {
  console.log("Hello " + thing);
}

// this:
hello("world")

// desugars to:
hello.call(window, "world");
#+end_src

This behavior has changed in ECMAScript 5[fn:5] only when using strict mode:

#+begin_src js
// this:
hello("world")

// desugars to:
hello.call(undefined, "world");
#+end_src

The short version is: a function invocation like ~fn(...args)~ is the same as
~fn.call(window [ES5-strict: undefined], ...args)~.

Note that this is also true about functions declared inline:

: (function() {})()
is the same as
: function() {}).call(window [ES5-strict: undefined)

**** Member Functions
The next very common way to invoke a method is as a member of an object
(~person.hello()~).  In this case, the invocation desugars:

#+begin_src js -n
var person = {
  name: "Brendan Eich",
  hello: function(thing) {
    console.log(this + " says hello " + thing);
  }
}

// this:
person.hello("world")

// desugars to this:
person.hello.call(person, "world");
#+end_src

Note that it doesn't matter how the ~hello~ method becomes attached to the object
in this form.  Remember that we previously defined ~hello~ as a standalone
function.  Let's see what happens if we attach is to the object dynamically:

#+begin_src js -n
function hello(thing) {
  console.log(this + " says hello " + thing);
}

person = { name: "Brendan Eich" }
person.hello = hello;

person.hello("world") // still desugars to person.hello.call(person, "world")

hello("world") // "[object DOMWindow]world"
#+end_src

Notice that the function doesn't have a persistent notion of its 'this'.  It is
always set at call time based upon the way it was invoked by its caller.

**** Using ~function.prototype.bind~ Method
Because it can sometimes be convenient to have a reference to a function with a
persistent ~this~ value, people have historically used a simple closure trick to
convert a function into one with an unchanging ~this~:

#+begin_src js -n
var person = {
  name: "Brendan Eich",
  hello: function(thing) {
    console.log(this.name + " says hello " + thing);
  }
}

var boundHello = function(thing) { return person.hello.call(person, thing); }

boundHello("world");
#+end_src

#+cindex:@code{bind} function
We can make this trick general-purpose with a few tweaks:

#+begin_src js -n
var bind = function(func, thisValue) {
  return function() {
    return func.apply(thisValue, arguments);
  }
}

var boundHello = bind(person.hello, person);
boundHello("world") // "Brendan Eich says hello world"
#+end_src

#+cindex:@code{Function.prototype.apply} method
#+cindex:@code{apply} method
First, arguments is an Array-like object that represents all of the arguments
passed into a function.  Second, the ~apply~ method works exactly like the
~call~ primitive, except that it takes an Array-like object instead of listing
the arguments out one at a time.

Our ~bind~ method simply returns a new function.  When it is invoked, our new
function simply invokes the original function that was passed in, setting the
original value as ~this~.  It also passes through the arguments.

#+cindex:ES5
Because this was a somewhat common idiom, ES5 introduced a new method ~bind~ on
all Function objects that implements this behavior:

#+begin_src js -n
var boundHello = person.hello.bind(person);
boundHello("world") // "Brendan Eich says hello world"
#+end_src

This is most useful when you need a raw function to pass as a callback:

#+begin_src js -n
var person = {
  name: "Alex Russell",
  hello: function() { console.log(this.name + " says hello world"); }
}

$("#some-div").click(person.hello.bind(person));

// when the div is clicked, "Alex Russell says hello world" is printed
#+end_src
*** This and Function Invocation Context
#+cindex:invocation context
In addition to the arguments, each invocation has another value—the /invocation
context/---that is the value of the ~this~ keyword.  When a function is invoked
on or through an object, that object is the /invocation context/ or `this`
value for the function.

Note that ~this~ is a keyword, not a variable or property name.  JavaScript
syntax does not allow you to assign a value to ~this~.

**** Invoking Functions
#+cindex:invoke function
#+cindex:function, invoke
JavaScript functions can be invoked in four ways:

- as functions
- as methods
- as constructors
- indirectly through their ~call()~ and ~apply()~ methods

**** Function Invocation
#+cindex:invocation expression
#+cindex:function invocation expression
#+cindex:method invocation expression
Functions are invoked as functions or as methods with an /invocation
expression/.  An /invocation expression/ consists of a function expression that
evaluates to a function object followed by an open parenthesis, a
comma-separated list of zero or more argument expressions, and a close
parenthesis.  If the function expression is a /property-access expression/---if
the function is the property of an object or an element of an array---then it
is a /method invocation expression/.

#+cindex:argument expression
In an invocation, each argument expression (the ones between the parentheses)
is evaluated, and the resulting values become the arguments to the function.
These values are assigned to the parameters named in the function definition.
In the body of the function, a reference to a parameter evaluates to the
corresponding argument value.

For regular function invocation, the return value of the function becomes the
value of the invocation expression. If the function returns because the
interpreter reaches the end, the return value is undefined. If the function
returns because the interpreter exe- cutes a return, the return value is the
value of the expression that follows the return or undefined if the return
statement has no value.

#+cindex:invocation context
#+cindex:ECMAScript 3
#+cindex:ECMAScript 5 nonstrict mode, strict mode
#+cindex:@code{this} value
For function invocation in ECMAScript 3 and nonstrict ECMAScript 5, the
invocation context (the ~this~ value) is the global object.  In strict mode,
however, the invocation context is =undefined=.  Functions written to be
invoked as functions do not typically use the ~this~ keyword at all.  It can be
used, however, to determine whether strict mode is in effect:

#+begin_src js
// Define and invoke a function to determine if we're in strict mode.
// !undefined == true
// !window == false
var strict = (function() { return !this; }());
#+end_src

**** Method Invocation
#+cindex:method
A /method/ is nothing more than a JavaScript function that is stored in a
property of an object.

: o.m(x, y);

#+cindex:invocation expression
#+cindex:function expression
#+cindex:argument expression
#+cindex:property access expression
The code above is an /invocation expression/: it includes a /function
expression/ ~o.m~ and two /argument expressions/, ~x~ and ~y~.  The function
expression is itself a /property access expression/, and this means that the
function is invoked as a method rather than as a regular function.

Method invocations differ from function invocations in one important way,
however: the /invocation context/.  /Property access expressions/ consist of
two parts: an object (in this case ~o~) and a property name (~m~).  In a method
invocation expression like this, the object ~o~ becomes the /invocation
context/, and the function body can refer to that object by using the keyword
~this~.

{{{heading(Object-Oriented Programming Paradigm)}}}

Methods and the ~this~ keyword are central to the object-oriented programming
paradigm.  Any function that is used as a method is effectively passed an
implicit argument---the object through which it is invoked.  Typically, a
method performs some sort of operation on that object, and the
method-invocation syntax is an elegant way to express the fact that a function
is operating on an object.

***** Method Chaining

When methods return objects, you can use the return value of one method
invocation as part of a subsequent invocation.  This results in a series (or
“chain” or “cascade”) of method invocations as a single expression.  When you
write a method that does not have a return value of its own, consider having
the method return ~this~.  If you do this consistently throughout your API, you
will enable a style of programming known as /method chaining/ in which an
object can be named once and then multiple methods can be invoked on it:

: shape.setX(100).setY(100).setSize(50).setOutline("red").setFill("blue").draw();

Unlike variables, the ~this~ keyword does not have a scope, and nested
functions do not inherit the ~this~ value of their caller.  If a nested
function is invoked as a method, its ~this~ value is the object it was invoked
on.  If a nested function is invoked as a function then its ~this~ value will
be either the global object (non-strict mode) or =undefined= (strict mode).

It is a common mistake to assume that a nested function invoked as a function
can use ~this~ to obtain the invocation context of the outer function.  If you
want to access the ~this~ value of the outer function, you need to store that
value into a variable that is in scope for the inner function.  It is common to
use the variable ~self~ for this purpose.

#+begin_src js
var o = {				// An object o.
    m: function() {			// Method m of the object.
        var self = this;		// Save the this value in a variable.
        console.log(this === o);	// Prints "true": this is the object o.
        f();				// Now call the helper function f().

        function f() {			// A nested function f
            console.log(this === o);	// "false": this is global or undefined
            console.log(self === o);	// "true": self is the outer this value.
        }
    }
};
o.m();					// Invoke the method m on the object o.
#+end_src

**** Constructor Invocation
#+cindex:constructor invocation
#+cindex:@code{new} keyword
#+cindex:invocation context
If a function or method invocation is preceded by the keyword ~new~, then it is
a /constructor invocation/.  Constructor invocations differ from regular
function and method invocations in their handling of arguments, invocation
context, and return value.  If a constructor has no parameters, then JavaScript
constructor invocation syntax allows the argument list and parentheses to be
omitted entirely.

: var o = new Object;

#+cindex:prototype property
A constructor invocation creates a new, empty object that inherits from the
prototype property of the constructor.  Constructor functions are intended to
initialize objects and this newly created object is used as the invocation
context, so the constructor function can refer to it with the ~this~ keyword.

Constructor functions do not normally use the ~return~ keyword.  They typically
initialize the new object and then return implicitly when they reach the end of
their body.  If, however, a constructor explicitly used the ~return~ statement
to return an object, then that object becomes the value of the invocation
expression.  If the constructor uses ~return~ with no value, or if it returns a
primitive value, that return value is ignored and the new object is used as the
value of the invocation.

**** Indirect Invocation
#+cindex:@code{call()}
#+cindex:@code{apply()}
JavaScript functions are objects and like all JavaScript objects, they have
methods.  Two of these methods, ~call()~ and ~apply()~, invoke the function
indirectly.  Both methods allow you to explicitly specify the ~this~ value for
the invocation, which means you can invoke any function as a method of any
object, even if it is not actually a method of that object.  Both methods also
allow you to specify the arguments for the invocation.  The ~call()~ method
uses its own argument list as arguments to the function and the ~apply()~
method expects an array of values to be used as arguments.
*** The call() and apply() Methods
#+cindex:@code{call()}
#+cindex:@code{apply()}
#+cindex:invocation context
~call()~ and ~apply()~ allow you to indirectly invoke a function as if it were
a method of some other object.  The first argument to both ~call()~ and
~apply()~ is the object on which the function is to be invoked; this argument
is the /invocation context/ and becomes the value of the ~this~ keyword within
the body of the function.  To invoke the function ~f()~ as a method of the
object ~o~ (passing no arguments), you could use either ~call()~ or ~apply()~:

: f.call(o);
: f.apply(o);

Any arguments to ~call()~ after the first invocation context argument are the
values that are passed to the function that is invoked.  The ~apply()~ method
is like the ~call()~ method, except that the arguments to be passed to the
function are specified as an array:

: f.call(o, 1, 2);
: f.apply(o, [1,2]);

If a function is defined to accept an arbitrary number of arguments, the
~apply()~ method allows you to invoke that function on the contents of an array
of arbitrary length.  Note that ~apply()~ works with array-like objects as well
as true arrays.  In particular, you can invoke a function with the same
arguments as the current function by passing the arguments array directly to
~apply()~.

#+cindex:ECMAScript 3
#+cindex:non-strict mode
#+cindex:global object
In ECMAScript 3 and non-strict mode, a value of ~null~ or ~undefined~ is
replaced with the global object and a primitive value is replaced with the
corresponding wrapper object.

#+cindex:ECMAScript 5
#+cindex:scrict mode
In ECMAScript 5 strict mode the first argument to ~call()~ or ~apply()~ becomes
the value of ~this~, even if it is a primitive value or ~null~ or ~undefined~.

**** Monkey Patching
This ~trace()~ function is passed an object and a method name.  It replaces the
specified method with a new method that “wraps” additional functionality around
the original method.  This kind of dynamic alteration of existing methods is
sometimes called “monkey-patching.”

Replace the method named ~m~ of the object ~o~ with a version that logs
messages before and after invoking the original method.

#+begin_src js
function trace(o, m) {
    var original = o[m]; // Remember original method in the closure.
    o[m] = function() { // Now define the new method.
        console.log(new Date(), "Entering:", m); // Log message.
        var result = original.apply(this, arguments); // Invoke original.
        console.log(new Date(), "Exiting:", m); // Log message.
        return result; // Return result.
    };
}
#+end_src

*** The bind() Method
#+cindex:ECMAScript 5
#+cindex:@code{bind()}
The ~bind()~ method was added in ECMAScript 5, but it is easy to simulate in
ECMAScript 3.  The primary purpose of ~bind()~ is to bind a function to an
object.  When you invoke the ~bind()~ method on a function ~f~ and pass an
object ~o~, the method returns a new function.  Invoking the new function (as a
function) invokes the original function ~f~ as a method of ~o~.  Any arguments
you pass to the new function are passed to the original function.

#+begin_src js
function f(y) { return this.x + y; } // This function needs to be bound
var o = { x : 1 };                   // An object we'll bind t
var g = f.bind(o);                   // Calling g(x) invokes o.f(x)
g(2);                                // => 3
#+end_src

It is easy to accomplish this kind of binding with code like the following:

#+begin_src js
// Return a function that invokes f as a method of o, passing all its arguments.
function bind(f, o) {
    if (f.bind) return f.bind(o);   // Use the bind method, if there is one
    else return function() {        // Otherwise, bind it like this
        return f.apply(o, arguments);
    };
}
#+end_src

**** Partial Application
#+cindex:currying
#+cindex:ECMAScript 5
#+cindex:@code{bind()} method
#+cindex:partial application
The ECMAScript 5 ~bind()~ method does more than just bind a function to an
object.  It also performs /partial application/: any arguments you pass to
~bind()~ after the first are bound along with the ~this~ value.  Partial
application is a common technique in functional programming and is sometimes
called /currying/.

#+begin_src js
var sum = function(x,y) { return x + y }; // Return the sum of 2 args
// Create a new function like sum, but with the this value bound to null
// and the 1st argument bound to 1. This new function expects just one arg.
var succ = sum.bind(null, 1);
succ(2) // => 3: x is bound to 1, and we pass 2 for the y argument
#+end_src

#+begin_src js
function f(y,z) { return this.x + y + z }; // Another function that adds
var g = f.bind({x:1}, 2); // Bind this and y
g(3) // => 6: this.x is bound to 1, y is bound to 2 and z is 3
#+end_src

***** Partial Application in ECMAScript 3
We can bind the ~this~ value and perform partial application in ECMAScript 3.
The standard ~bind()~ method can be simulated with code like:[fn:6]

#+caption:A @code{Function.bind()} method for ECMAScript 3
#+name:partial-application-ECMAScript 3
#+begin_src js
if (!Function.prototype.bind) {
    Function.prototype.bind = function(o /*, args */) {
        // Save the this and arguments values into variables so we can
        // use them in the nested function below.
        var self = this, boundArgs = arguments;

        // The return value of the bind() method is a function 
        return function() {
            // Build up an argument list, starting with any args passed
            // to bind after the first one, and follow those with all args
            // passed to this function.
            var args = [], i;
            for(i = 1; i < boundArgs.length; i++) args.push(boundArgs[i]);
            for(i = 0; i < arguments.length; i++) args.push(arguments[i]);

            // Now invoke self as a method of o, with those arguments
            return self.apply(o, args); 
        };
    };
}
#+end_src

#+cindex:closure
#+cindex:inner function
Notice that the function returned by this ~bind()~ method is a closure that
uses the variables ~self~ and ~boundArgs~ declared in the outer function, even
though that inner function has been returned from the outer function and is
invoked after the outer function has returned.

**** Advantages of ECMAScript 5 bind Method
The ~bind()~ method defined by ECMAScript 5 does have some features that cannot
be simulated with the ECMAScript 3 code shown above.

- First, the true ~bind()~ method returns a function object with its ~length~
  property properly set to the arity of the bound function minus the number of
  bound arguments (but not less than zero).

- Second, the ECMAScript 5 ~bind()~ method can be used for partial application
  of constructor functions.  If the function returned by ~bind()~ is used as a
  constructor, the ~this~ passed to ~bind()~ is ignored, and the original
  function is invoked as a constructor, with some arguments already bound.
  Functions returned by the ~bind()~ method do not have a prototype property
  (the prototype property of regular functions cannot be deleted) and objects
  created when these bound functions are used as constructors inherit from the
  prototype of the original, unbound constructor.  Also, a bound constructor
  works just like the unbound constructor for the purposes of the ~instanceof~
  operator.

** Inheritance and the Prototype Chain
JavaScript is prototype-based.  JavaScript has one construct---the object.
Each object has a private property which holds a link to another object called
its *prototype*.  That prototype object has a prototype of its own, and so on
until an object is reached with =null= as its prototype.  By definition, =null=
has no prototype, and acts as the final link in this prototype chain.  Nearly
all objects in JavaScript are instances of =Object= which sits on the top of a
prototype chain.

The prototypal inheritance model itself is, in fact, more powerful than the
classic model.  It is, for example, fairly trivial to build a classic model on
top of a prototypal model.

*** Accessing the Prototype
- ~Object.getPrototypeOf(<object>)~ :: get a reference to an object's prototype
     object.

- ~Object.setPrototypeOf(<object>)~ :: set a reference to an object's prototype
     object.

- ~<object>.__proto__~ :: non-stanard JavaScript pseudo-property referencing
     the object's prototype.  =__proto__= is a way to access =[ [Prototype] ]=,
     it is not =[ [Prototype] ]= itself.  That is, =__proto__= is not a
     property of an object, but an accessor property of =Object.prototype=:

     : Object.prototype == { get __proto__ : function() {}, set __proto__ : function() }

     So if =obj.__proto__= is read or set, the corresponding getter/setter is
     called from its prototype, and it gets/sets =[ [ Prototype ] ]=.

- ~<func>.prototype~ :: property of functions which specifies the prototype to be
     assigned to all instances of objects created by the given function when
     used as a constructor.

*** Inheriting Properties
JavaScript objects have properties, called *own properties*.  JavaScript
objects have a link to a prototype object.  When trying to access a property of
an object, the property will not only be sought on the object but on the
prototype of the object, the prototype of the prototype, and so on until either
a property with a matching name is found or the end of the prototype chain is
reached.

#+begin_src js
let f = function() {
    this.a = 1;
    this.b = 2;
}

let o = new f(); // {a: 1, b: 2}

f.prototype.b = 3;
f.prototype.c = 4;

/*
  Do not try to set the prototype as f.prototype = {b:3,c:4};
  this will break the prototype chain.
  
  o.[[Prototype]] has properties b and c.
  o.[[Prototype]].[[Prototype]] is Object.prototype.
  o.[[Prototype]].[[Prototype]].[[Prototype]] is null.
  This is the end of the prototype chain, as null, by definition, has no [[Prototype]].

  The full prototype chain looks like:
  {a: 1, b: 2} ---> {b: 3, c: 4} ---> Object.prototype ---> null
*/

console.log(o.a); // 1
console.log(o.b); // 2

/*
  The prototype also has a 'b' property, but it's not visited.
  This is called Property Shadowing
*/

console.log(o.c); // 4

/*
  Is there a 'c' own property on o? No, check its prototype.
  Is there a 'c' own property on o.[[Prototype]]? Yes, its value is 4.
*/

console.log(o.d); // undefined
#+end_src

Setting a property to an object creates an own property.

*** Inheriting Methods
JavaScript does not have "methods" in the form that class-based languages
define them.  Rather, any function can be added to an object in the form of a
property.  An inherited function acts just as any other property, including
property shadowing.  When an inherited function is executed, the value of
~this~ points to the inheriting object, not to the prototype object where the
function is an own property.

#+begin_src js
  var o = {
    a: 2,
    m: function() {
      return this.a + 1;
    }
  };

  console.log(o.m()); // 3; 'this' refers to 'o'

  var p = Object.create(o); // 'p' inherits from 'o'
  p.a = 4; // creates a property 'a' on 'p'
  console.log(p.m()); // 5

  /*
    When 'p.m' is called, 'this' refers to 'p'.  So when 'p' inherits
    the function 'm' of 'o', 'this.a' means 'p.a', the property 'a' of p
  */
#+end_src

* ECMAScript 5 Features
** ECMAScript 5 Specification Scope
The ECMAScript 5 specification contains the following description of its scope:

#+cindex:ECMA-262 5th edition
#+cindex:ECMAScript 5 new features
{{{heading(The fifth edition of ECMAScript (published as ECMA-262 5th
edition))}}}

#+cindex:de facto features
- codifies /de facto/ interpretations of the language specification that have
  become common among browser implementations and

  #+cindex:ES5 new features
- adds support for /new features/ that have emerged since the publication of the
  third edition.  Such features include:

    #+cindex:accessor properties, ES5
    #+cindex:ES5 accessor properties
  - accessor properties,

    - getters and
    - setters

    #+cindex:reflective creation and inspection of objects, ES5
    #+cindex:ES5 reflective creation and inspection of objects
  - reflective creation and inspection of objects,

    - Object.create()
    - Object.getPrototypeOf()
    - Object.getOwnPropertyDescriptor()
    - Object.getOwnPropertyNames()
    - Object.isExtensible()
    - Object.isSealed()
    - Object.isFrozen()

    #+cindex:property attributes, program control, ES5
    #+cindex:ES5 program control of property attributes
  - program control of property attributes,

    - Object.defineProperty()
    - Object.defineProperties()
    - Object.preventExtensions()
    - Object.seal()
    - Object.freeze()

    #+cindex:array manipulation functions, ES5
    #+cindex:ES5 array manipulation functions
  - additional array manipulation functions,

    - Array.isArray()
    - Array.prototype.every()
    - Array.prototype.filter()
    - Array.prototype.forEach()
    - Array.prototype.indexOf()
    - Array.prototype.lastIndexOf()
    - Array.prototype.map()
    - Array.prototype.reduce()
    - Array.prototype.some()

    #+cindex:JSON object encoding format, ES5
    #+cindex:ES5 JSON object encoding formation
  - support for the JSON object encoding format, and

    - JSON.parse()
    - JSON.stringify()

    #+cindex:strict mode, ES5
    #+cindex:ES5 strict mode
    #+cindex:strict code
  - a strict mode that provides enhanced error checking and program security.
    The purpose of a “use strict” directive is to indicate that the code that
    follows (in the script or function) is /strict code/.  Strict code is
    executed in /strict mode/.  The /strict mode/ of ECMAScript 5 is a
    restricted subset of the language that fixes a few important language
    deficiencies and provides stronger error checking and increased security.

** New Features in ES5

*** Strict Mode

#+cindex:strict mode, ES5
#+cindex:ES5 strict mode
Putting the following line first in a file or a function switches on the
so-called strict mode that makes JavaScript a cleaner language by forbidding
some features, performing more checks, and throwing more exceptions:
: 'use strict';

{{{heading(“use strict” is a Directive, not a Statement)}}}

#+cindex:directive
“use strict” is a /directive/ introduced in ECMAScript 5.  Directives are not
statements.  There are two important differences between the “use strict”
directive and regular statements:

1. It does not include any language keywords: the directive is just an
   expression statement that consists of a special string literal (in single or
   double quotes).

   JavaScript interpreters that do not implement ECMAScript 5 will simply see
   an expression statement with no side effects and will do nothing.  Future
   versions of the ECMAScript standard are expected to introduce =use= as a
   true keyword, allowing the quotation marks to be dropped.

   String literal expression statements that follow the first regular statement
   in a script or function are simply ordinary expression statements; they may
   not be interpreted as directives and they have no effect.

2. It can appear only at the start of a script or at the start of a function
   body, before any real statements have appeared.

   It need not be the very first thing in the script or function, however: a
   “use strict” directive may be followed or preceded by other string literal
   expression statements, and JavaScript implementations are allowed to
   interpret these other string literals as implementation-defined directives.


{{{heading(Strict Code)}}}

#+cindex:strict code
#+cindex:strict mode
Strict code is executed in /strict mode/.

{{{subheading(Top-Level Strict Code)}}}

- The top-level (nonfunction) code of a script is strict code if the script has
  a “use strict” directive.

{{{subheading(Function Body Strict Code)}}}

- A function body is strict code if it is defined within strict code or if it
  has a “use strict” directive.

{{{subheading(Eval Strict Code)}}}

- Code passed to the ~eval()~ method is strict code if ~eval()~ is called from
  strict code or if the string of code includes a “use strict” directive.


**** Features of Strict Mode

#+cindex:@code{with} statement, strict mode
#+cindex:strict mode, @code{with} sttement
- The =with= statement is not allowed in strict mode.

  #+cindex:@code{ReferenceError}
  #+cindex:variables declared, strict mode
  #+cindex:strict mode, variables declared
- In strict mode, all variables must be declared: a =ReferenceError= is thrown
  if you assign a value to an identifier that is not a declared variable,
  function, function parameter, catch clause parameter, or property of the
  global object.  In non-strict mode, this implicitly declares a global
  variable by adding a new property to the global object.

  #+cindex:functions invoked as functions, strict mode
  #+cindex:strict mode, functions invoked as functions
- In strict mode, functions invoked as functions (rather than as methods) have
  a ~this~ value of =undefined=.  In non-strict mode, functions invoked as
  functions are always passed the global object as their ~this~ value.

  This difference can be used to determine whether an implementation supports
  strict mode:

  : var hasStrictMode = (function() { "use strict"; return this===undefined}());

  #+cindex:@code{call} in strict mode
  #+cindex:@code{apply} in strict mode
  #+cindex:strict mode, @code{call} and @code{apply}
  In strict mode, when a function is invoked with ~call()~ or ~apply(),~ the
  ~this~ value is exactly the value passed as the first argument to ~call()~ or
  ~apply()~.  In nonstrict mode, =null= and =undefined= values are replaced
  with the global object and non-object values are converted to objects.

  #+cindex:assignment to nonwritable properties, strict mode
  #+cindex:new properties on nonextensible objects, strict mode
  #+cindex:strict mode, nonwritable and nonextensible
  #+cindex:strict mode, TypeError
  #+cindex:TypeError, strict mode
- In strict mode, assignments to nonwritable properties and attempts to create
  new properties on nonextensible objects throw a =TypeError=.  In non-strict
  mode, these attempts fail silently.

- In strict mode, code passed to ~eval()~ cannot declare variables or define
  functions in the caller’s scope.  Instead, variable and function definitions
  live in a new scope created for the ~eval()~.  This scope is discarded when
  the ~eval()~ returns.

  #+cindex:@code{arguments} object, strict mode
  #+cindex:strict mode @code{arguments} object
- In strict mode, the =arguments= object in a function holds a static copy of
  the values passed to the function.  In non-strict mode, the =arguments=
  object has “magical” behavior in which elements of the array and named
  function parameters both refer to the same value.

  #+cindex:@code{delete} operator, strict mode
  #+cindex:strict mode, @code{delete} operator
- In strict mode, a =SyntaxError= is thrown if the =delete= operator is
  followed by an unqualified identifier such as a variable, function, or
  function parameter.  In nonstrict mode, such a =delete= expression does
  nothing and evaluates to =false=.

  #+cindex:nonconfigurable property, strict mode
  #+cindex:strict mode, nonconfigurable property
  #+cindex:@code{TypeError}, strict mode
- In strict mode, an attempt to delete a nonconfigurable property throws a
  =TypeError=.  In non-strict mode, the attempt fails and the =delete=
  expression evaluates to =false=.

  #+cindex:strict mode, define multiple properties with same name
- In strict mode, it is a syntax error for an object literal to define two or
  more properties by the same name.  In non-strict mode, no error occurs.

  #+cindex:strict mode, defined multiple function properties
- In strict mode, it is a syntax error for a function declaration to have two
  or more parameters with the same name.  In non-strict mode, no error occurs.

  #+cindex:strict mode, octal integer literals
  #+cindex:octal integer literals, strict mode
- In strict mode, octal integer literals (beginning with a ‘0’ that is not
  followed by an ’x’) are not allowed.  In non-strict mode, some
  implementations allow octal literals.

  #+cindex:strict mode, @code{eval} and @code{arguments}
  #+cindex:@code{eval} as keyword, strict mode
  #+cindex:@code{arguments} as keyword, strict mode
- In strict mode, the identifiers =eval= and =arguments= are treated like
  keywords, and you are not allowed to change their value.  You cannot assign a
  value to these identifiers, declare them as variables, use them as function
  names, use them as function parameter names, or use them as the identifier of
  a catch block.

  #+cindex:strict mode, call stack, examine
  #+cindex:call stack, examine, strict mode
  #+cindex:@code{TypeError}, strict mode
- In strict mode, the ability to examine the call stack is restricted.
  ~arguments.caller~ and ~arguments.callee~ both throw a =TypeError= within a
  strict mode function.  Strict mode functions also have =caller= and
  =arguments= properties that throw =TypeError= when read.

*** Accessor Properties

#+cindex:accessor properties, ES5
#+cindex:getters, setters, ES5
#+cindex:ES5 getters and setters
Getters and setters allow you to implement the getting and setting of a
property via methods.  For example, the following object =obj= contains a
=getter= for the property =foo=:

#+begin_src js
var obj = {
  get foo() { 
    return 'abc'
  }
};
#+end_src

** Syntactic Changes in ES5
#+cindex:ES5 syntactic changes
ECMAScript 5 includes the following syntactic changes:

{{{heading(Reserved words as property keys)}}}

#+cindex:ES5 reserved words
You can use reserved words (such as =new= and =function=) after the =dot=
operator and as unquoted property keys in object literals:

: var obj = { new: 'abc' };
: obj.new // 'abc'

{{{heading(Legal Trailing Commas)}}}

#+cindex:ES5 trailing commas
Trailing commas in object literals and array literals are legal.

{{{heading(Multiline String Literals)}}}

#+cindex:ES5 multiline string literals
#+cindex:multiline string literals, ES5
#+cindex:string literals, multiline, ES5
String literals can span multiple lines if you escape the end of the line via a
backslash.

** ES5 Statements and Declarations
#+cindex:statements, ECMAScript 5
#+begin_example
Statement :
  Block
  VariableStatement
  EmptyStatement
  ExpressionStatement
  IfStatement
  IterationStatement
  ContinueStatement
  BreakStatement
  ReturnStatement
  WithStatement
  LabelledStatement
  SwitchStatement
  ThrowStatement
  TryStatement
  DebuggerStatement
#+end_example

** New Functionality in the Standard Library in ES5

#+cindex:standard library, new in ES5
#+cindex:ES5 new standard library functionality
ECMAScript 5 brought several additions to JavaScript’s standard library.  This
section lists them by category.

*** Metaprogramming

#+cindex:metaprogramming
#+cindex:prototpyes, get and set, new in ES5
#+cindex:ES5 get and set prototypes
{{{heading(Getting and setting prototypes)}}}

  #+cindex:Object.create()
- Object.create()

  #+cindex:Object.getPrototypeOf()
- Object.getPrototypeOf()


{{{heading(Managing property attributes via property descriptors)}}}

  #+cindex:property descriptors, property attributes
  #+cindex:property attributes, property descriptors
  #+cindex:Object.defineProperty()
- Object.defineProperty()

  #+cindex:Object.defineProperties()
- Object.defineProperties()

  #+cindex:Object.create()
- Object.create()

  #+cindex:Object.getOwnPropertyDescriptor()
- Object.getOwnPropertyDescriptor()


{{{heading(Listing properties)}}}

  #+cindex:list properties, new in ES5
  #+cindex:ES5 list properties
  #+cindex:Object.keys
- Object.keys()

  #+cindex:Object.getOwnPropertyNames()
- Object.getOwnPropertyNames()


{{{heading(Protecting objects)}}}

  #+cindex:protecting objects in ES5
  #+cindex:ES5 protecting objects
  #+cindex:Object.preventExtensions()
- Object.preventExtensions()

  #+cindex:Object.isExtensible()
- Object.isExtensible()

  #+cindex:Object.seal()
- Object.seal()

  #+cindex:Object.isSealed()
- Object.isSealed()

  #+cindex:Object.freeze()
- Object.freeze()

  #+cindex:Object.isFrozen()
- Object.isFrozen()


{{{heading(New Function method)}}}

  #+cindex:Function.prototype.bind()
- Function.prototype.bind()

*** New Methods

{{{heading(Strings)}}}

  #+cindex:String.prototype.trim()
- New method ~String.prototype.trim()~

  #+cindex:bracket operator
- Access characters via the bracket operator =[...]=


{{{heading(New Array methods)}}}

  #+cindex:Array methods, new in ES5
  #+cindex:ES5 new array methods
  #+cindex:Array.isArray()
- Array.isArray()

  #+cindex:Array.prototype.every()
- Array.prototype.every()

  #+cindex:Array.prototype.filter()
- Array.prototype.filter()

  #+cindex:Array.prototype.forEach()
- Array.prototype.forEach()

  #+cindex:Array.prototype.indexOf()
- Array.prototype.indexOf()

  #+cindex:Array.prototype.lastIndexOf()
- Array.prototype.lastIndexOf()

  #+cindex:Array.prototype.map()
- Array.prototype.map()

  #+cindex:Array.prototype.reduce()
- Array.prototype.reduce()

  #+cindex:Array.prototype.some()
- Array.prototype.some()


{{{heading(New Date methods)}}}

  #+cindex:Date methods, new in ES5
  #+cindex:ES5 new Date methods
  #+cindex:Date.now()
- Date.now()

  #+cindex:Date.prototype.toISOString()
- Date.prototype.toISOString()

*** JSON

{{{heading(Support for JSON)}}}

  #+cindex:JSON support in ES5
  #+cindex:ES5 JSON support
  #+cindex:JSON.parse()
- JSON.parse()

  #+cindex:JSON.stringify()
- JSON.stringify()

- Some built-in objects have special ~toJSON()~ methods:

    #+cindex:toJSON() methods, ES5
    #+cindex:ES5 toJSON() methods
    #+cindex:Boolean.prototype.toJSON()
  - Boolean.prototype.toJSON()

    #+cindex:Number.prototype.toJSON()
  - Number.prototype.toJSON()

    #+cindex:String.prototype.toJSON()
  - String.prototype.toJSON()

    #+cindex:Date.prototype.toJSON()
  - Date.prototype.toJSON()

** Object Constructor Methods added by ES5

*** ~Object.create()~
#+findex:@code{Object.create()}
#+cindex:prototype object
#+cindex:properties
Creates a new object with the specified prototype object and properties.

The ~Object.create()~ method creates a new object, using an existing object as
the prototype of the newly created object.

#+attr_texinfo: :options Object create ( proto, [propertiesObject] )
#+begin_defmethod
- {{{var(proto)}}} :: The object which should be the prototype of the
     newly-created object.

- {{{var(propertiesObject)}}} :: [Optional]

     #+cindex:enumerable own properties
     #+cindex:own properties, enumerable
     #+cindex:properties, enumerable own
     #+cindex:property descriptors
     #+cindex:@code{Object.defineProperties()}
     If specified and not =undefined=, an object whose enumerable own
     properties (that is, those properties defined upon itself and not
     enumerable properties along its prototype chain) specify property
     descriptors to be added to the newly-created object, with the
     corresponding property names.  These properties correspond to the second
     argument of ~Object.defineProperties()~.

- Return Value :: A new object with the specified prototype object and
                  properties.
#+end_defmethod

**** Classical Inheritance with ~Object.create()~

#+cindex:classical inheritance using @code{Object.create()}
#+cindex:inheritance, classical
#+cindex:@code{Object.create()} and classical inheritance
Below is an example of how to use Object.create() to achieve classical
inheritance.  This is for a single inheritance.

#+caption:Classical Inheritance using Object.create()
#+name:classical-inheritance-using-Object.create
#+begin_src js
  // Shape - superclass
  function Shape() {
    this.x = 0;
    this.y = 0;
  }

  // superclass method
  Shape.prototype.move = function(x, y) {
    this.x += x;
    this.y += y;
    console.info('Shape moved.');
  };

  // Rectangle - subclass
  function Rectangle() {
    Shape.call(this); // call super constructor.
  }

  // subclass extends superclass
  Rectangle.prototype = Object.create(Shape.prototype);

  //If you don't set Object.prototype.constructor to Rectangle,
  //it will take prototype.constructor of Shape (parent).
  //To avoid that, we set the prototype.constructor to Rectangle (child).
  Rectangle.prototype.constructor = Rectangle;

  var rect = new Rectangle();

  console.log('Is rect an instance of Rectangle?', rect instanceof Rectangle); // true
  console.log('Is rect an instance of Shape?', rect instanceof Shape); // true
  rect.move(1, 1); // Outputs, 'Shape moved.'
#+end_src

**** Properly extending EventEmitter in node.js
- https://jasonlebrun.info/2013/10/08/properly-extending-eventemitter-in-node-js/


#+cindex:prototype chain, set up
#+cindex:prototype field
To create a JavaScript object that is based on another object, you have to set
up its prototype chain.  This involves putting some kind of object into the
prototype field of your object.  So, the question then becomes: what do we put
in this field?

#+cindex:@code{new} keyword
#+cindex:@code{Object.create()}
#+cindex:@command{util} module
#+cindex:@code{util.inherits} method
Well, you want your object’s prototype to be an object that has a prototype
which is the object you’re trying to extend the functionality of.  One of the
ways we first learn to do something like this in JavaScript is with the ~new~
keyword.  However, more modern versions of JavaScript have introduced newer
ways to create objects based on a prototype.  So we also have
~Object.create()~.  Furthermore, ~node.js~ provides a utility function in the
~util~ module called ~inherits~.  However, under the hood, it’s based on
~Object.create~, and also sets up some constructor and superclass information.

So, what’s the difference in setting your prototype using ~new~ vs. using
~Object.create~?  It’s subtle, but important.  When you use ~new~, a new object
based on the prototype of the specified object is created, and the
initialization code is run.  When you use ~Object.create~, the new object is
created with the prototype chain set up, but the initialization code is not
run.

This is an important distinction in the case of setting up EventEmitter
functionality in ~node.js~.  When you call ~new EventEmitter~ some internal
state is initialized, but only if it did not exist yet.  This means, if you
initialize your custom ~EventEmitter~ prototype chain using ~new~, all
subsequent instances of your custom emitter will share some internal
structures.  One of those structures is a list of events to be emitted,
contained in the =_events= field of the object.  The code of interest in the
~EventEmitter~ initialization looks like this:

#+begin_src js
this._events = this._events || {};
#+end_src

If this initialization code is run, then any objects created further down the
initialization chain will see the already-created =_events= object, and not
create a new one.  So now a single =_event= queue is shared amongst all of the
objects.  This means that if you create multiple instances of your custom
EventEmitter, all of the instances with registered event listeners will fire
these listener for any event emitted from any instance.  This is most likely
not the behavior you are looking for.

To exhibit the difference, let’s look at a small code example.  We’ll create
two custom ~EventEmitter~ objects, one that sets up its prototype chain using
~new EventEmitter~ and one that sets up its prototype chain using
~Object.create(EventEmitter.prototype)~ via the ~util.inherits~ helper
function.

#+caption:Proper and Improper Subclassing of EventEmitter
#+name:proper-and-improper-subclassing-of-EventEmitter
#+begin_src js -n
var EventEmitter = require('events').EventEmitter;
var util = require('util');

function GoodEmitter() {
    EventEmitter.call(this);
}

util.inherits(GoodEmitter, EventEmitter);

function BadEmitter() {
    EventEmitter.call(this);
}

BadEmitter.prototype = new EventEmitter();

var good1 = new GoodEmitter();
good1.on('ev', function(msg) { console.log("Good Instance 1: "+msg); });
var good2 = new GoodEmitter();
good2.on('ev', function(msg) { console.log("Good Instance 2: "+msg); });
good1.emit('ev', 'GoodEmitter: Emitting from Instance 1');

var bad1 = new BadEmitter();
bad1.on('ev', function(msg) { console.log("Bad Instance 1: "+msg); });
var bad2 = new BadEmitter();
bad2.on('ev', function(msg) { console.log("Bad Instance 2: "+msg); });
bad1.emit('ev', 'BadEmitter: Emitting from Instance 1');
#+end_src

If you run this code using node.js, you will see:

#+begin_example
$ node ee.js
Good Instance 1: GoodEmitter: Emitting from Instance 1
Bad Instance 1: BadEmitter: Emitting from Instance 1
Bad Instance 2: BadEmitter: Emitting from Instance 1
#+end_example

So we see quite clearly: we have both instances of the bad emitter object
responding to an event published by just one of the bad emitter instances.  The
same pattern with the good emitter behaves as expected, only firing listeners
registered on the object that emitted the event.

** this and Accessor Properties
#+cindex:accessor properties
#+cindex:ECMAScript 5
#+cindex:getter
#+cindex:setter
An object property is a name, a value, and a set of attributes.  In ECMAScript
5 (and in recent ECMAScript 3 versions of major browsers other than IE) the
value may be replaced by one or two methods, known as a /getter/ and a
/setter/.  Properties defined by /getters/ and /setters/ are sometimes known as
/accessor properties/ to distinguish them from /data properties/ that have a
simple value.

#+cindex:getter method
- When a program queries the value of an accessor property, JavaScript invokes
  the getter method (passing no arguments). The return value of this method
  becomes the value of the property access expression.

  #+cindex:setter method
- When a program sets the value of an accessor property, JavaScript invokes the
  setter method, passing the value of the right-hand side of the assignment.
  This method is responsible for “setting,” in some sense, the property value.
  The return value of the setter method is ignored.

  #+cindex:get
  #+cindex:set
- Accessor properties are defined as one or two functions whose name is the
  same as the property name, and with the =function= keyword replaced with
  =get= and/or =set=.


#+cindex:2D Cartesian point
#+cindex:Cartesian point
As an example, consider the following object that represents a 2D Cartesian
point.  It has ordinary data properties to represent the X and Y coordinates of
the point, and it has accessor properties for the equivalent polar coordinates
of the point:

#+begin_src js -n
var p = {
    // x and y are regular read-write data properties.
    x: 1.0,
    y: 1.0,

    // r is a read-write accessor property with getter and setter. // Don't forget to put a comma after accessor methods.
    get r() { return Math.sqrt(this.x*this.x + this.y*this.y); },

    set r(newvalue) {
        var oldvalue = Math.sqrt(this.x*this.x + this.y*this.y);
        var ratio = newvalue/oldvalue;
        this.x *= ratio;
        this.y *= ratio;
    },

    // theta is a read-only accessor property with getter only.
    get theta() {
        return Math.atan2(this.y, this.x);
    }
};
#+end_src

#+cindex:@code{this} keyword, accessor property
Note the use of the keyword ~this~ in the getters and setter above.  JavaScript
invokes these functions as methods of the object on which they are defined,
which means that within the body of the function ~this~ refers to the =point=
object.  So the getter method for the =r= property can refer to the ~x~ and ~y~
properties as ~this.x~ and ~this.y~.
* ECMAScript 2015 (ES6) Features

  - http://es6-features.org/
  - https://github.com/rse/es6-features
  - [[https://leanpub.com/understandinges6/read/][Understanding ECMAScript 6 by Nicholas Zakas]]
  - [[https://node.green/][node.green]] --- Node.js ES2015 Support
  - [[https://kangax.github.io/compat-table/es6/][Kangax's compat-table]] and [[https://github.com/kangax/compat-table][kangax/compat-table on Github]]


#+cindex:ES2015 specification, new features
The introduction of the ES6 specification lists all new features:

#+begin_quote
Some of [ECMAScript 6’s] major enhancements include modules, class
declarations, lexical block scoping, iterators and generators, promises for
asynchronous programming, destructuring patterns, and proper tail calls.  The
ECMAScript library of built-ins has been expanded to support additional data
abstractions including maps, sets, and arrays of binary numeric values as well
as additional support for Unicode supplemental characters in strings and
regular expressions.  The built-ins are now extensible via subclassing.
#+end_quote

{{{heading(The Three Groups in Node.js)}}}

#+cindex:groups
#+cindex:shipping
#+cindex:staged
#+cindex:in-progress
All ECMAScript 2015 (ES6) features are split into three groups for:

- Shipping :: All shipping features, which V8 considers stable, are turned on
              by default on Node.js and do NOT require any kind of runtime
              flag.

- Staged :: Staged features, which are almost-completed features that are not
            considered stable by the V8 team, require a runtime flag:
            {{{option(--harmony)}}}.

- In Progress :: In progress features can be activated individually by their
                 respective harmony flag, although this is highly discouraged
                 unless for testing purposes. Note: these flags are exposed by
                 V8 and will potentially change without any deprecation notice.


#+cindex:node.green
#+cindex:kangax
#+cindex:compat-table
The website [[https://node.green/][node.green]] provides an excellent overview over supported ECMAScript
features in various versions of Node.js, based on [[https://kangax.github.io/compat-table/es6/][kangax's compat-table]].

** Three Categories of New ES 2015 Features

#+cindex:ES2015 better syntax
{{{heading(Better syntax for features that already exist)}}}

- Classes
- Modules


#+cindex:ES2015 standard library functionality
{{{heading(New functionality in the standard library)}}}

- New methods for strings and Arrays

- Promises

- Maps, Sets


#+cindex:ES2015 new features
{{{heading(Completely new features)}}}

  #+cindex:geneators, ES2015
  #+cindex:ES2015 generators
- Generators

  #+cindex:proxies, ES2015
  #+cindex:ES2015 proxies
- Proxies

  #+cindex:Weak maps, ES2015
  #+cindex:ES2015 weak maps
- Weak Maps

** Review of New Features in ECMAScript 2015
- [[https://hacks.mozilla.org/category/es6-in-depth/][ES2015 In Depth Articles]] by Jason Orendorff

*** ES2015 In Depth Introduction
:PROPERTIES:
:date:     2015-04-23
:END:
- https://hacks.mozilla.org/2015/04/es6-in-depth-an-introduction/


#+cindex:ES6 In Depth
#+cindex:ECMAScript 6, ES6
Welcome to ES6 In Depth!  In this new weekly series, we’ll be exploring
ECMAScript 6, the upcoming new edition of the JavaScript language.  ES6
contains many new language features that will make JS more powerful and
expressive, and we’ll visit them one by one in weeks to come.  But before we
start in on the details, maybe it’s worth taking a minute to talk about what
ES6 is and what you can expect.

**** What falls under the scope of ECMAScript?
The JavaScript programming language is standardized by ECMA (a standards body
like W3C) under the name ECMAScript.  Among other things, ECMAScript defines:

#+cindex:language syntax
#+cindex:parsing rules
- [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar][Language syntax]] :: parsing rules, keywords, statements, declarations,
     operators, etc.

#+cindex:types
- [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures][Types]] :: boolean, number, string, object, etc.

#+cindex:prototypes
#+cindex:inheritance
- [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain][Prototypes and inheritance]] ::

#+cindex:standard library
- [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects][The standard library]] of built-in objects and functions :: JSON, Math, Array
     methods, Object introspection methods, etc.


#+cindex:DOM, Document Object Model
#+cindex:Document Object Model (DOM)
#+cindex:node.js
What it doesn’t define is anything to do with HTML or CSS, or the Web APIs,
such as the DOM (Document Object Model).  Those are defined in separate
standards. ECMAScript covers the aspects of JS that are present not only in the
browser, but also in non-browser environments such as ~node.js~.

**** The New Standard
Last week, the final draft of the ECMAScript Language Specification, Edition 6,
was submitted to the Ecma General Assembly for review.  What does that mean?
It means that this summer, we’ll have a new standard for the core JavaScript
programming language.  This is big news.  A new JS language standard doesn’t
drop every day.  The last one, ES5, happened back in 2009.  The ES standards
committee has been working on ES6 ever since.

ES6 is a major upgrade to the language.  At the same time, your JS code will
continue to work.  ES6 was designed for maximum compatibility with existing
code.  In fact, many browsers already support various ES6 features, and
implementation efforts are ongoing.  This means all your JS code has already
been running in browsers that implement some ES6 features!  If you haven’t seen
any compatibility issues by now, you probably never will.

**** Promises resolved
#+cindex:ES5
ES5, the 2009 update to the language, introduced ~Object.create()~,
~Object.defineProperty()~, getters and setters, strict mode, and the JSON
object.  I’ve used all these features, and I like what ES5 did for the
language.  But it would be too much to say any of these features had a dramatic
impact on the way I write JS code.  The most important innovation, for me, was
probably the new Array methods: ~.map()~, ~.filter()~, and so on.

Well, ES6 is different.  It’s the product of years of harmonious work.  And
it’s a treasure trove of new language and library features, the most
substantial upgrade for JS ever.  The new features range from welcome
conveniences, like arrow functions and simple string interpolation, to
brain-melting new concepts like proxies and generators.

This series aims to show you how, by examining the new features ES6 offers to
JavaScript programmers.  We’ll start with a classic “missing feature” that I’ve
been eager to see in JavaScript for the better part of a decade.  So join us
next week for a look at ES6 iterators and the new for-of loop.

*** Iterators and the for-of loop
- https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/


How do you loop over the elements of an array?  When JavaScript was introduced,
twenty years ago, you would do it like this:

{{{subheading(for Statement)

#+cindex:@code{for} Statement
#+begin_src js
for (var index = 0; index < myArray.length; index++) {
  console.log(myArray[index]);
}
#+end_src

{{{subheading(forEach Method on Array.prototype)}}}

#+cindex:@code{forEach} method
Since ES5, you can use the built-in ~forEach~ method (on ~Array.prototype~):

#+begin_src myArray.forEach(function (value) {
  console.log(value);
});
#+end_src

#+cindex:@code{break} statement, @code{forEach}
#+cindex:@code{return} statement, @code{forEach}
This is a little shorter, but there is one minor drawback: you can’t break out
of this loop using a ~break~ statement or return from the enclosing function
using a ~return~ statement.

It sure would be nice if there were just a ~for-loop~ syntax that looped over
array elements.

{{{subheading(for-in Statement)}}}

#+cindex:@code{for-in} Statement
How about a ~for–in~ loop?

#+begin_src js
for (var index in myArray) {    // don't actually do this
  console.log(myArray[index]);
}
#+end_src

This is a bad idea for several reasons:

- The values assigned to ~index~ in this code are the strings "0", "1", "2" and
  so on, not actual numbers.  Since you probably don’t want string arithmetic
  ("2" + 1 == "21"), this is inconvenient at best.

- The loop body will execute not only for array elements, but also for any
  other expando properties someone may have added.  For example, if your array
  has an enumerable property ~myArray.name~, then this loop will execute one
  extra time, with index == "name".  Even properties on the array’s prototype
  chain can be visited.

- Most astonishing of all, in some circumstances, this code can loop over the
  array elements in an arbitrary order.


In short, ~for–in~ was designed to work on plain old Objects with string
keys.  For Arrays, it’s not so great.

{{{subheading(The mighty for-of loop)}}}

#+cindex:@code{for-of} loop statement
Remember last week I promised that ES6 would not break the JS code you’ve
already written.  Well, millions of Web sites depend on the behavior of
~for–in~ --- yes, even its behavior on arrays.  So there was never any question
of “fixing” ~for–in~ to be more helpful when used with arrays.  The only way
for ES6 to improve matters was to add some kind of new loop syntax.

And here it is: ~for-of~ statement:

#+begin_src js
for (var value of myArray) {
  console.log(value);
}
#+end_src

Hmm. After all that build-up, it doesn’t seem all that impressive, does it?
Well, we’ll see whether ~for–of~ has any neat tricks up its sleeve.  For now,
just note that:

- this is the most concise, direct syntax yet for looping through array
  elements

- it avoids all the pitfalls of ~for–in~

- unlike ~forEach(),~ it works with ~break~, ~continue~, and ~return~


The ~for–in~ loop is for looping over object properties.

The ~for–of~ loop is for looping over data --- like the values in an array.

But that’s not all.  ~for–of~ is not just for arrays.  It also works on most
array-like objects, like DOM NodeLists.  It also works on strings, treating the
string as a sequence of Unicode characters:

#+begin_src js
for (var chr of "😺😲") {
  alert(chr);
}
#+end_src

#+cindex:Maps
#+cindex:Sets
It also works on Map and Set objects.  Oh, I’m sorry.  You’ve never heard of
Map and Set objects?  Well, they are new in ES6.  We’ll do a whole post about
them at some point.  If you’ve worked with maps and sets in other languages,
there won’t be any big surprises.

For example, a Set object is good for eliminating duplicates:

#+begin_src js
// make a set from an array of words
var uniqueWords = new Set(words);
#+end_src

Once you’ve got a Set, maybe you’d like to loop over its contents. Easy:

#+begin_src js
for (var word of uniqueWords) {
  console.log(word);
}
#+end_src

A Map is slightly different: the data inside it is made of key-value pairs, so
you’ll want to use destructuring to unpack the key and value into two separate
variables:

#+begin_src js
for (var [key, value] of phoneBookMap) {
  console.log(key + "'s phone number is: " + value);
}
#+end_src

Destructuring is yet another new ES6 feature and a great topic for a future
blog post. I should write these down.

By now, you get the picture: JS already has quite a few different collection
classes, and even more are on the way.  ~for–of~ is designed to be the
workhorse loop statement you use with all of them.

~for–of~ does not work with plain old Objects, but if you want to iterate over
an object’s properties you can either use ~for–in~ (that’s what it’s for) or
the builtin ~Object.keys()~:

#+begin_src js
// dump an object's own enumerable properties to the console
for (var key of Object.keys(someObject)) {
  console.log(key + ": " + someObject[key]);
}
#+end_src

**** Under the Hood
A running theme in ES6 is that the new features being added to the language
didn’t come out of nowhere.  Most have been tried and proven useful in other
languages.  The ~for–of~ loop, for example, resembles similar loop statements
in C++, Java, C#, and Python.  Like them, it works with several different data
structures provided by the language and its standard library.  But it’s also an
extension point in the language.

#+cindex:method calls
#+cindex:@code{iterator} method
Like the =for/foreach= statements in those other languages, =for–of= works
entirely in terms of method calls.  What Arrays, Maps, Sets, and the other
objects we talked about all have in common is that they have an ~iterator~
method.

#+cindex:@code{[Symbol.iterator]} method
And there’s another kind of object that can have an ~iterator~ method too: any
object you want.  Just as you can add a ~myObject.toString()~ method to any
object and suddenly JS knows how to convert that object to a string, you can
add the ~myObject[Symbol.iterator]()~ method to any object and suddenly JS will
know how to loop over that object.

For example, suppose you’re using jQuery, and although you’re very fond of
~.each(),~ you would like jQuery objects to work with =for–of= as well.  Here’s
how to do that:

#+begin_src js
// Since jQuery objects are array-like,
// give them the same iterator method Arrays have
jQuery.prototype[Symbol.iterator] =
  Array.prototype[Symbol.iterator];
#+end_src

#+cindex:@code{[Symbol.iterator]} syntax
OK, I know what you’re thinking.  That ~[Symbol.iterator]~ syntax seems weird.
What is going on there?  It has to do with the method’s name.  The standard
committee could have just called this method ~.iterator()~, but then, your
existing code might already have some objects with ~.iterator()~ methods, and
that could get pretty confusing.  So the standard uses a symbol, rather than a
string, as the name of this method.

#+cindex:symbols
Symbols are new in ES6, and we’ll tell you all about them in---you guessed
it---a future blog post.  For now, all you need to know is that the standard
can define a brand-new symbol, like ~Symbol.iterator~, and it’s guaranteed not
to conflict with any existing code.  The trade-off is that the syntax is a
little weird.  But it’s a small price to pay for this versatile new feature and
excellent backward compatibility.

An object that has a ~[Symbol.iterator]()~ method is called =iterable=.  In
coming weeks, we’ll see that the concept of iterable objects is used throughout
the language, not only in =for–of= but in the Map and Set constructors,
destructuring assignment, and the new ~spread~ operator.

**** Iterator Objects
#+cindex:iterator object
Now, there is a chance you will never have to implement an iterator object of
your own from scratch.  We’ll see why next week.  But for completeness, let’s
look at what an iterator object looks like.  (If you skip this whole section,
you’ll mainly be missing crunchy technical details.)

A =for–of= loop starts by calling the ~[Symbol.iterator]()~ method on the
collection.  This returns a new iterator object.  An iterator object can be any
object with a ~.next()~ method; the =for–of= loop will call this method
repeatedly, once each time through the loop.  For example, here’s the simplest
iterator object I can think of:

#+begin_src js
var zeroesForeverIterator = {
  [Symbol.iterator]: function () {
    return this; // the `iterator' object
  },
  next: function () { // with a `next' method
    return {done: false, value: 0};
  }
};
#+end_src

Every time this ~.next()~ method is called, it returns the same result, telling
the =for–of= loop (a) we’re not done iterating yet; and (b) the next value
is 0.  This means that ~for (value of zeroesForeverIterator) {}~ will be an
infinite loop.  Of course, a typical iterator will not be quite this trivial.

This iterator design, with its =.done= and =.value= properties, is
superficially different from how iterators work in other languages.  In Java,
iterators have separate ~.hasNext()~ and ~.next()~ methods.  In Python, they
have a single ~.next()~ method that throws =StopIteration= when there are no
more values.  But all three designs are fundamentally returning the same
information.

#+cindex:@code{.return()} method
#+cindex:@code{.throw(exc)} method
An iterator object can also implement optional ~.return()~ and ~.throw(exc)~
methods.  The =for–of= loop calls ~.return()~ if the loop exits prematurely,
due to an =exception= or a =break= or =return= statement.  The iterator can
implement ~.return()~ if it needs to do some cleanup or free up resources it
was using.  Most iterator objects won’t need to implement it. ~.throw(exc)~ is
even more of a special case: =for–of= never calls it at all.  But we’ll hear
more about it next week.

Now that we have all the details, we can take a simple =for–of= loop and
rewrite it in terms of the underlying method calls.

First the for–of loop:

#+begin_src js
for (VAR of ITERABLE) {
  STATEMENTS
}
#+end_src

Here is a rough equivalent, using the underlying methods and a few temporary
variables:

#+begin_src js
var $iterator = ITERABLE[Symbol.iterator]();
var $result = $iterator.next();
while (!$result.done) {
  VAR = $result.value;
  STATEMENTS
  $result = $iterator.next();
}
#+end_src

This code doesn’t show how ~.return()~ is handled.  We could add that, but I
think it would obscure what’s going on rather than illuminate it.  =for–of= is
easy to use, but there is a lot going on behind the scenes.

{{{heading(Generators)}}}

Well, we’re done for today, but we’re still not done with the =for–of= loop.

There is one more new kind of object in ES6 that works beautifully with for–of.
I didn’t mention it because it’s the topic of next week’s post.  I think this
new feature is the most magical thing in ES6.  If you haven’t already
encountered it in languages like Python and C#, you’ll probably find it
mind-boggling at first.  But it’s the easiest way to write an iterator, it’s
useful in refactoring, and it might just change the way we write asynchronous
code, both in the browser and on the server.  So join us next week as we look
at ES6 generators in depth.
*** In Depth Generators
I’m excited about today’s post. Today, we’re going to discuss the most magical
feature in ES6.  What do I mean by “magical”?  For starters, this feature is so
different from things that already existed in JS that it may seem completely
arcane at first.  In a sense, it turns the normal behavior of the language
inside out!  If that’s not magic, I don’t know what is.  Not only that: this
feature’s power to simplify code and straighten out “callback hell” borders on
the supernatural.  Am I laying it on a bit thick? Let’s dive in and you can
judge for yourself.

**** Introducing ES6 Generators
#+cindex:generator
What are generators?  Let’s start by looking at one.

#+begin_src js
function* quips(name) {
  yield "hello " + name + "!";
  yield "i hope you are enjoying the blog posts";
  if (name.startsWith("X")) {
    yield "it's cool how your name starts with X, " + name;
  }
  yield "see you later!";
}
#+end_src

#+cindex:generator function
This is some code for a talking cat. It looks sort of like a function, right?
This is called a generator-function and it has a lot in common with
functions. But you can see two differences right away:

#+cindex:@code{function*}
- Regular functions start with ~function~.  Generator-functions start with
  ~function*~.

  #+cindex:@code{yield}
- Inside a generator-function, ~yield~ is a keyword, with syntax rather like
  return.  The difference is that while a function (even a generator-function)
  can only return once, a generator-function can yield any number of times.
  The ~yield~ expression suspends execution of the generator so it can be
  resumed again later.


So that’s it, that’s the big difference between regular functions and
generator-functions.  Regular functions can’t pause
themselves.  Generator-functions can.

**** What Generators Do
What happens when you call the ~quips()~ generator-function?

#+begin_src sh
> var iter = quips("jorendorff");
  [object Generator]
> iter.next()
  { value: "hello jorendorff!", done: false }
> iter.next()
  { value: "i hope you are enjoying the blog posts", done: false }
> iter.next()
  { value: "see you later!", done: false }
> iter.next()
  { value: undefined, done: true }
#+end_src

#+cindex:generator, call
#+cindex:generator object, paused
Calling a generator looks just the same: ~quips("jorendorff")~. But when you
call a generator, it doesn’t start running yet.  Instead, it returns a paused
Generator object (called ~iter~ in the example above).  You can think of this
Generator object as a function call, frozen in time.  Specifically, it’s frozen
right at the top of the generator-function, just before running its first line
of code.

#+cindex:@code{next()} method
#+cindex:@code{yield}
Each time you call the Generator object’s ~.next()~ method, the function call
thaws itself out and runs until it reaches the next ~yield~ expression.  That’s
why each time we called iter.next()~ above, we got a different string value.
Those are the values produced by the ~yield~ expressions in the body of
~quips()~.

#+cindex:@code{done} field
#+cindex:@code{value} field
On the last ~iter.next()~ call, we finally reached the end of the
generator-function, so the =.done= field of the result is =true=.  Reaching the
end of a function is just like returning =undefined=, and that’s why the
=.value= field of the result is =undefined=.

#+cindex:stack frame, generator
In technical terms, each time a generator yields, its stack frame---the local
variables, arguments, temporary values, and the current position of execution
within the generator body---is removed from the stack.  However, the Generator
object keeps a reference to (or copy of) this stack frame, so that a later
~.next()~ call can reactivate it and continue execution.

All right.  We know what generators are.  We’ve seen a generator run, pause
itself, then resume execution.  Now for the big question.  How could this weird
ability possibly be useful?

**** Generators are Iterators
Last week, we saw that ES6 iterators are not just a single built-in class.
They’re an extension point of the language.  You can create your own iterators
just by implementing two methods: ~[Symbol.iterator]()~ and ~.next()~.

#+cindex:range iterator
But implementing an interface is always at least a little work.  Let’s see what
an iterator implementation looks like in practice.  As an example, let’s make a
simple ~range~ iterator that simply counts up from one number to another, like
an old-fashioned C ~for~ (=;;)= loop.

#+begin_src js
// This should "ding" three times
for (var value of range(0, 3)) {
  alert("Ding! at floor #" + value);
}
#+end_src

Here’s one solution, using an ES6 class.

#+caption:Implementing a range Iterator
#+name:class-RangeIterator
#+begin_src js -n
class RangeIterator {
  constructor(start, stop) {
    this.value = start;
    this.stop = stop;
  }

  [Symbol.iterator]() { return this; }

  next() {
    var value = this.value;
    if (value < this.stop) {
      this.value++;
      return {done: false, value: value};
    } else {
      return {done: true, value: undefined};
    }
  }
}

// Return a new iterator that counts up from 'start' to 'stop'.
function range(start, stop) {
  return new RangeIterator(start, stop);
}
#+end_src

[[https://codepen.io/anon/pen/mJewga][See this code in action.]]

The above 4-line generator is a drop-in replacement for the previous 23-line
implementation of ~range()~, including the entire =RangeIterator= class.  This
is possible because generators are iterators.  All generators have a built-in
implementation of ~.next()~ and ~[Symbol.iterator]()~.  You just write the
looping behavior.

{{{heading(Uses of Generators)}}}

How else can we use the ability of generators to act as iterators?

- Making any object iterable. ::

     Just write a generator-function that traverses ~this~, yielding each value
     as it goes.  Then install that generator-function as the
     ~[Symbol.iterator]~ method of the object.

- Simplifying array-building functions. ::

     Suppose you have a function that returns an array of results each time
     it’s called, like this one:

     #+begin_src js
	// Divide the one-dimensional array 'icons'
	// into arrays of length 'rowLength'.
	function splitIntoRows(icons, rowLength) {
            var rows = [];
            for (var i = 0; i < icons.length; i += rowLength) {
                rows.push(icons.slice(i, i + rowLength));
            }
            return rows;
        }
     #+end_src

     Generators make this kind of code a bit shorter:

     #+begin_src js
	function* splitIntoRows(icons, rowLength) {
            for (var i = 0; i < icons.length; i += rowLength) {
                yield icons.slice(i, i + rowLength);
            }
        }
     #+end_src

     The only difference in behavior is that instead of computing all the
     results at once and returning an array of them, this returns an iterator,
     and the results are computed one by one, on demand.

- Results of unusual size. ::

     You can’t build an infinite array.  But you can return a generator that
     generates an endless sequence, and each caller can draw from it however
     many values they need.

- Refactoring complex loops. ::

     Do you have a huge ugly function?  Would you like to break it into two
     simpler parts?  Generators are a new knife to add to your refactoring
     toolkit.  When you’re facing a complicated loop, you can factor out the
     part of the code that produces data, turning it into a separate
     generator-function.  Then change the loop to say:
     : for (var data of myNewGenerator(args))

- Tools for working with iterables. ::

     ES6 does not provide an extensive library for filtering, mapping, and
     generally hacking on arbitrary iterable data sets.  But generators are
     great for building the tools you need with just a few lines of code.

     For example, suppose you need an equivalent of ~Array.prototype.filter~
     that works on DOM NodeLists, not just Arrays.  Piece of cake:

     #+begin_src js
	function* filter(test, iterable) {
            for (var item of iterable) {
                if (test(item))
                    yield item;
            }
        }
     #+end_src

So are generators useful?  Sure.  They are an astonshingly easy way to
implement custom iterators, and iterators are the new standard for data and
loops throughout ES6.

** Core ES2015 Features

*** From ~var~ to ~let~ and ~const~

*** From IIFEs to Blocks

*** From Concatenating Strings to Tempalate Literals

*** From Function Expressions to Arrow Functions

*** Handling Multiple Return Values

*** From ~for~ to ~forEach~ to ~for-of~

*** Handling Parameter Default Values

*** Handling Named Parameters

*** From ~arguments~ to rest Parameters

*** From ~apply~ to the Spread Operator =...=

*** From ~concat~ to the Spread Operator

*** From Function Expressions in Object Literals to Method Definitions

*** From Constructors to Classes

*** From Custom Error Constructors to Subclasses of =Error=

*** From Objects to Maps

*** New String Methods

*** New Array Methods

*** From CommonJS Modules to ES2015 Modules

** ECMAScript 2015 Statements and Declarations
#+begin_example
Statement[Yield, Return] :
   BlockStatement[?Yield, ?Return]
   VariableStatement[?Yield]
   EmptyStatement
   ExpressionStatement[?Yield]
   IfStatement[?Yield, ?Return]
   BreakableStatement[?Yield, ?Return]
   ContinueStatement[?Yield]
   BreakStatement[?Yield]
   [+Return] ReturnStatement[?Yield]
   WithStatement[?Yield, ?Return]
   LabelledStatement[?Yield, ?Return]
   ThrowStatement[?Yield]
   TryStatement[?Yield, ?Return]
   DebuggerStatement

Declaration[Yield] :
   HoistableDeclaration[?Yield]
   ClassDeclaration[?Yield]
   LexicalDeclaration[In, ?Yield]

HoistableDeclaration[Yield, Default] :
   FunctionDeclaration[?Yield,?Default]
   GeneratorDeclaration[?Yield, ?Default]

BreakableStatement[Yield, Return] :
   IterationStatement[?Yield, ?Return]
   SwitchStatement[?Yield, ?Return]
#+end_example

*** =let= and =const= Declarations
=let= declares a block scope local variable, optionally initializing it to a
value.

=const= declares a read-only named constant.

*** =for...of= Statement

*** =function*= Declaration
=function*= declaration defines a generator Function, which returns a
=generator= object, enabling the writing of iterators more easily.

*** =yield= Keyword
Used to pause and resume a generator function; it can be thought of as a
generator-based version of the =return= keyword.

*** =class= Declaration
Declares a class.

** constants

** Scoping

** Arrow Functions

** Extended Parameter Handling
*** Default Parameter Values
*** Rest Parameter

#+cindex:rest parameter
#+cindex:ECMAScript 2015
#+cindex:variadic function
Aggregation of remaining arguments into single parameter of variadic functions.

#+caption:Example of the rest Parameter
#+name:rest-parameter
#+begin_src js
function f (x, y, ...a) {
    return (x + y) * a.length
}
f(1, 2, "hello", true, 7) === 9;
#+end_src

#+cindex:ECMAScript 3
#+caption:Example of rest Parameter in ES5
#+name:ES5-rest-parameter
#+begin_src js
function f (x, y) {
    var a = Array.prototype.slice.call(arguments, 2);
    return (x + y) * a.length;
};
f(1, 2, "hello", true, 7) === 9;
#+end_src

*** Spread Syntax---Operator
#+cindex:spread syntax
#+cindex:spread operator
#+cindex:iterable collection

/Spread syntax/ (=...=) allows an *iterable* (such as an array expression or
string) to be EXPANDED in places where zero or more arguments (for function
calls) or elements (for array literals) are expected, or an *object expression*
to be EXPANDED in places where zero or more key-value pairs (for object
literals) are expected.

: myFunction(...iterableObj); // function call

: [...iterableObj, '4', 'five', 6]; // array literals or strings

: let objClone = { ...obj }; // For object literals

Spreading of elements of an iterable collection (like an array or even a
string) into both literal elements and individual function parameters.

#+caption:Example of spread Operator
#+name:spread-operator
#+begin_src js
var params = [ "hello", true, 7 ];
var other = [ 1, 2, ...params ]; // [ 1, 2, "hello", true, 7 ]

function f (x, y, ...a) {
    return (x + y) * a.length
}
f(1, 2, ...params) === 9;

var str = "foo";
var chars = [ ...str ]; // [ "f", "o", "o" ]
#+end_src

#+caption:Example of spread Operator in ES3
#+name:ES3-spread-operator
#+begin_src js
var params = [ "hello", true, 7 ];
var other = [ 1, 2 ].concat(params); // [ 1, 2, "hello", true, 7 ]

function f (x, y) {
    var a = Array.prototype.slice.call(arguments, 2);
    return (x + y) * a.length;
};
f.apply(undefined, [ 1, 2 ].concat(params)) === 9;

var str = "foo";
var chars = str.split(""); // [ "f", "o", "o" ]
#+end_src

** Template Literals

** Extended Literals

** Enhanced Regular Expression

** Enhanced Object Properties
#+cindex:Object global
One of the design goals of ECMAScript beginning with ECMAScript 5 was to avoid
creating new global functions or methods on =Object.prototype=, and instead try
to find objects on which new methods should be available.  As a result, the
=Object= global has received an increasing number of methods when no other
objects are more appropriate.  ECMAScript 6 introduces a couple new methods on
the =Object= global that are designed to make certain tasks easier.

*** ~Object.assign~
The ~Object.assign()~ method is used to copy the values of all =enumerable own
properties= from one or more source objects to a target object.  It will return
the target object.

#+caption:Object.assign() Demo
#+name:Object.assign-demo
#+begin_src js
const target = { a: 1, b: 2 };
const source = { b: 4, c: 5 };

const returnedTarget = Object.assign(target, source);

console.log(target);
// expected output: Object { a: 1, b: 4, c: 5 }

console.log(returnedTarget);
// expected output: Object { a: 1, b: 4, c: 5 }
#+end_src

#+attr_texinfo: :options Object assign ( target, ...sources )
#+begin_defmethod
- {{{var(target)}}} :: The target object.

- {{{var(sources)}}} :: The source object(s).

- Return Value :: The target object.
#+end_defmethod

**** Description of ~Object.assign()~
The ~Object.assign()~ method only copies =enumerable and own= properties from a
source object to a target object.  It uses [[Get]] on the source and [[Set]] on the
target, so it will invoke getters and setters.  Therefore it /assigns/
properties versus just copying or defining new properties.  This may make it
unsuitable for merging new properties into a prototype if the merge sources
contain getters.

For copying property definitions, including their enumerability, into
prototypes, ~Object.getOwnPropertyDescriptor()~ and ~Object.defineProperty()~
should be used instead.

Both =String= and =Symbol= properties are copied.

**** Cloning an Object

#+name:clone-an-object
#+begin_src js
var obj = { a: 1 };
var copy = Object.assign({}, obj);
console.log(copy); // { a: 1 }
#+end_src

*WARNING*: For deep cloning, we need to use other alternatives because
~Object.assign()~ copies property values.  If the source value is a reference
to an object, it only copies that reference value.

**** Merging Objects

#+name:merge-objects
#+begin_src js
var o1 = { a: 1 };
var o2 = { b: 2 };
var o3 = { c: 3 };

var obj = Object.assign(o1, o2, o3);
console.log(obj); // { a: 1, b: 2, c: 3 }
console.log(o1);  // { a: 1, b: 2, c: 3 }, target object itself is changed.
#+end_src

*WARNING*: The properties are overwritten by other objects that have the same
properties later in the parameters order.

**** Copying Symbol-Typed Properties

#+name:copying-symbol-typed-properties
#+begin_src js
var o1 = { a: 1 };
var o2 = { [Symbol('foo')]: 2 };

var obj = Object.assign({}, o1, o2);
console.log(obj); // { a : 1, [Symbol("foo")]: 2 } (cf. bug 1207182 on Firefox)
Object.getOwnPropertySymbols(obj); // [Symbol(foo)]
#+end_src

**** Properties on Prototype Chain and Non-Enumerable Properties

Properties on the prototype chain and non-enumerable properties cannot be
copied:

#+name:properties-prototype-non-enumeable
#+begin_src js
  var obj = Object.create({ foo: 1 }, { // foo is on obj's prototype chain.
    bar: {
      value: 2  // bar is a non-enumerable property.
    },
    baz: {
      value: 3,
      enumerable: true  // baz is an own enumerable property.
    }
  });

  var copy = Object.assign({}, obj);
  console.log(copy); // { baz: 3 }
#+end_src

**** Copying Accessors

Accessors are not assigned:

#+name:accessors-not-assigned
#+begin_src js
var obj = {
  foo: 1,
  get bar() {
    return 2;
  }
};

var copy = Object.assign({}, obj);
console.log(copy);
// { foo: 1, bar: 2 }, the value of copy.bar is obj.bar's getter's return value.
#+end_src

This is an assign function that copies full descriptors:

#+name:assign-function-to-copy-full-descriptors
#+begin_src js
function completeAssign(target, ...sources) {
  sources.forEach(source => {
    let descriptors = Object.keys(source).reduce((descriptors, key) => {
      descriptors[key] = Object.getOwnPropertyDescriptor(source, key);
      return descriptors;
    }, {});
    // by default, Object.assign copies enumerable Symbols too
    Object.getOwnPropertySymbols(source).forEach(sym => {
      let descriptor = Object.getOwnPropertyDescriptor(source, sym);
      if (descriptor.enumerable) {
        descriptors[sym] = descriptor;
      }
    });
    Object.defineProperties(target, descriptors);
  });
  return target;
}

var copy = completeAssign({}, obj);
console.log(copy);
// { foo:1, get bar() { return 2 } }
#+end_src

*** ~Object.assign()~ and Mixins

#+cindex:mixins
#+cindex:mixin method
*Mixins* are among the most popular patterns for object composition in
JavaScript.  In a /mixin/, one object receives properties and methods from
another object.  Many JavaScript libraries have a /mixin method/ similar to
this:

#+caption:Mixin Method
#+name:mixin-method
#+begin_src js
function mixin(receiver, supplier) {
    Object.keys(supplier).forEach(function(key) {
        receiver[key] = supplier[key];
    });

    return receiver;
}
#+end_src

The ~mixin()~ function iterates over the =own properties= of ~supplier~ and
copies them onto ~receiver~ (a shallow copy, where object references are shared
when property values are objects).  This allows the ~receiver~ to gain new
properties without inheritance, as in this code:

#+name:mixin-method-example
#+begin_src js
function EventTarget() { /*...*/ }
EventTarget.prototype = {
    constructor: EventTarget,
    emit: function() { /*...*/ },
    on: function() { /*...*/ }
};

var myObject = {};
mixin(myObject, EventTarget.prototype);

myObject.emit("somethingChanged");
#+end_src

Here, ~myObject~ receives behavior from the ~EventTarget.prototype~ object.
This gives ~myObject~ the ability to publish events and subscribe to them using
the ~emit()~ and ~on()~ methods, respectively.

This pattern became popular enough that ECMAScript 6 added the
~Object.assign()~ method, which behaves the same way, accepting a receiver and
any number of suppliers, and then returning the receiver.  The name change from
~mixin()~ to ~assign()~ reflects the actual operation that occurs.  Since the
~mixin()~ function uses the assignment operator (=), it cannot copy accessor
properties to the receiver as accessor properties.  The name ~Object.assign()~
was chosen to reflect this distinction.[fn:7]

You can use Object.assign() anywhere the mixin() function would have been
used. Here’s an example:

#+name:Object.assign-example
#+begin_src js
function EventTarget() { /*...*/ }
EventTarget.prototype = {
    constructor: EventTarget,
    emit: function() { /*...*/ },
    on: function() { /*...*/ }
}

var myObject = {}
Object.assign(myObject, EventTarget.prototype);

myObject.emit("somethingChanged");
#+end_src

The ~Object.assign()~ method accepts any number of suppliers, and the receiver
receives the properties in the order in which the suppliers are specified.
That means the second supplier might overwrite a value from the first supplier
on the receiver, which is what happens in this snippet:

#+name:Object.assign-overwriting-example
#+begin_src js
var receiver = {};

Object.assign(receiver,
    {
        type: "js",
        name: "file.js"
    },
    {
        type: "css"
    }
);

console.log(receiver.type);     // "css"
console.log(receiver.name);     // "file.js"
#+end_src

** Destructuring Assignment

** Modules

** Classes

** Symbol Type

{{{heading(Specification at §6.1.5)}}}

- [[https://tc39.es/ecma262/#sec-ecmascript-language-types-symbol-type][Symbol type]]

  “The Symbol type is the set of all non-String values that may be used as the
  key of an Object property.  Each possible Symbol value is unique and
  immutable.  Each Symbol value immutably holds an associated value called
  =[[Description]== that is either =undefined= or a String value.”

- [[https://www.ecma-international.org/ecma-262/6.0/#sec-symbol-objects][Symbol Objects]]


{{{heading(Symbol Type---Symbol Value---Description)}}}

#+cindex:symbol type
#+cindex:symbol value
A =Symbol= is a primitive type first defined in ECMAScript 2015 (there is no
ECMAScript 5 equivalent for symbol.).  A value having the data type =Symbol= is
referred to as a “symbol value”.  A =Symbol= value represents a unique
identifier (for object properties).

In a JavaScript run-time environment, a symbol value is created by invoking the
function =Symbol=, which dynamically produces an anonymous, unique value.  A
symbol may be used as an object property.  =Symbol= can have an optional
description, but for debugging purposes only.  Symbols do not auto-convert to
strings.  To do so, you must explicitly call the symbol’s ~toString~ method.
You can also reference a symbol’s ~description~ property.

{{{heading(Symbols are Guaranteed to be Unique)}}}

#+begin_src js
// here are two symbols with the same description,
let Sym1 = Symbol("Sym");
let Sym2 = Symbol("Sym");
  
console.log(Sym1 == Sym2); // returns "false"
// Symbols are guaranteed to be unique.
// Even if we create many symbols with the same description,
// they are different values.
#+end_src

{{{heading(Some Properties of Symbols)}}}

#+begin_src js
Symbol("foo") !== Symbol("foo");
const foo = Symbol();
const bar = Symbol();
typeof foo === "symbol";
typeof bar === "symbol";
let obj = {};
obj[foo] = "foo";
obj[bar] = "bar";
JSON.stringify(obj); // {}
Object.keys(obj); // []
Object.getOwnPropertyNames(obj); // []
Object.getOwnPropertySymbols(obj); // [ foo, bar ]
#+end_src

*** Symbol Constants

- [[https://tc39.es/ecma262/#table-1][Well-Known Symbols]]


The Symbol class has constants for so-called well-known symbols.  These symbols
let you configure how JS treats an object, by using them as property keys.

{{{heading(=Symbol.iterator=)}}}

=Symbol.iterator= is an example.  This symbol specifies the default iterator
for an object, i.e., the iterator used by =for...of=:

{{{heading(Description)}}}

Whenever an object needs to be iterated (such as at the beginning of a
=for..of= loop), its =@@iterator= method is called with no arguments, and the
returned iterator is used to obtain the values to be iterated.

#+caption:Demo of Well-Known Symbol Symbol.iterator
#+name:demo-well-known-symbol-Symbol.iterator
#+begin_src js -n
const iterable1 = new Object();

iterable1[Symbol.iterator] = function* () {
  yield 1;
  yield 2;
  yield 3;
};

console.log([...iterable1]);
// expected output: Array [1, 2, 3]
#+end_src

Some built-in types have a default iteration behavior, while other types (such
as =Object=) do not.  The built-in types with a =@@iterator= method are:

- ~Array.prototype[@@iterator]()~

- ~TypedArray.prototype[@@iterator]()~

- ~String.prototype[@@iterator]()~

- ~Map.prototype[@@iterator]()~

- ~Set.prototype[@@iterator]()~


{{{heading(User-Defined Iterables)}}}

We can make our own iterables like this:

#+begin_src js -n
var myIterable = {}
myIterable[Symbol.iterator] = function* () {
    yield 1;
    yield 2;
    yield 3;
};
[...myIterable] // [1, 2, 3]
#+end_src

Or iterables can be defined directly inside a class or object using a computed
property:

#+begin_src js -n
class Foo {
  *[Symbol.iterator] () {
    yield 1;
    yield 2;
    yield 3;
  }
}

const someObj = {
  *[Symbol.iterator] () {
    yield 'a';
    yield 'b';
  }
}

[...new Foo] // [ 1, 2, 3 ]
[...someObj] // [ 'a', 'b' ]
#+end_src

** Iterators

*** The for-of Statement
The =for...of= statement creates a loop iterating over /iterable objects/,
including: built-in String, Array, Array-like objects (e.g., arguments or
NodeList), TypedArray, Map, Set, and user-defined iterables.  It invokes a
/custom iteration hook/ with statements to be executed for the value of each
distinct property of the object.

#+caption:Basic Example of a for-of Statement
#+name:example-for-of-statement
#+begin_src js
function* foo(){
  yield 1;
  yield 2;
}

for (let o of foo()) {
  console.log(o);
  // expected output: 1

  break; // closes iterator, triggers return
}
#+end_src

{{{heading(Syntax of for-of Statement)}}}

#+begin_example
for (variable of iterable) {
  statement
}
#+end_example

- variable :: On each iteration a value of a different property is assigned to
              ~variable~.  ~variable~ may be declared with ~const~, ~let~, or
              ~var~.

- iterable :: Object whose iterable properties are iterated.


{{{heading(Difference Between for-of and for-in Statements)}}}

Both =for...in= and =for...of= statements iterate over something.  The main
difference between them is in what they iterate over.

{{{subheading(The for-in Statement)}}}

The =for...in= statement iterates over the enumerable properties of an object,
in an arbitrary order.

{{{subheading(The for-of Statement)}}}

The ~for...of~ statement iterates over values that the iterable object defines
to be iterated over.

{{{heading(Example of Difference between for-in and for-of Statements)}}}

The following example shows the difference between a ~for...of~ loop and a
~for...in~ loop when used with an Array.

#+caption:Difference between ~for...in~ and ~for...of~ statements
#+begin_src js
Object.prototype.objCustom = function() {}; 
Array.prototype.arrCustom = function() {};

let iterable = [3, 5, 7];
iterable.foo = 'hello';

for (let i in iterable) {
  console.log(i); // logs 0, 1, 2, "foo", "arrCustom", "objCustom"
}

for (let i in iterable) {
  if (iterable.hasOwnProperty(i)) {
    console.log(i); // logs 0, 1, 2, "foo"
  }
}

for (let i of iterable) {
  console.log(i); // logs 3, 5, 7
}
#+end_src

Every object will inherit the =objCustom= property and every object that is an
Array will inherit the =arrCustom= property since these properties have been
added to ~Object.prototype~ and ~Array.prototype~, respectively.  The object
iterable inherits the properties =objCustom= and =arrCustom= because of
inheritance and the prototype chain.

{{{subheading(The First =for...in= Loop)}}}

This loop logs only enumerable properties of the iterable object, in arbitrary
order.  It doesn't log array elements 3, 5, 7 or 'hello' because those are not
enumerable properties; in fact they are not properties at all --- they are
values.  It logs array indexes as well as =arrCustom= and =objCustom, which
are. If you're not sure why these properties are iterated over, there's a more
thorough [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in#Array_iteration_and_for...in][explanation]] of how array iteration and =for...in= work.

{{{subheading(The Second =for...in= Loop)}}}

This loop is similar to the first one, but it uses ~hasOwnProperty()~ to check
if the found enumerable property is the object's own, i.e. not inherited.  If
it is, the property is logged.  Properties 0, 1, 2 and =foo= are logged because
they are own properties (not inherited).  Properties =arrCustom= and
=objCustom= are not logged because they are inherited.

{{{subheading(The =for...of= Loop)}}}

This loop iterates and logs /values/ that are *iterable*, as an iterable
object, defines to be iterated over.  The object's elements 3, 5, 7 are shown,
but none of the object's properties.

** Generators
*** New in ES2015
**** Generator Function Iterator Protocol
Support for generators, a special case of Iterators containing a generator
function, where the control flow can be paused and resumed, in order to produce
sequence of values (either finite or infinite).

#+caption:Example of a Generator in ES2015
#+name:fibonacci-generator-ES2015
#+begin_src js -n
let fibonacci = {
    *[Symbol.iterator]() {
        let pre = 0, cur = 1;
        for (;;) {
            [ pre, cur ] = [ cur, pre + cur ];
            yield cur;
        }
    }
}

for (let n of fibonacci) {
    if (n > 1000)
        break;
    console.log(n);
}
#+end_src

#+caption:Example of ES5 Code for Fibonacci
#+namee:fibonacci-ES5
#+begin_src js -n
var fibonacci = {
    next: (function () {
        var pre = 0, cur = 1;
        return function () {
            tmp = pre;
            pre = cur;
            cur += tmp;
            return cur;
        };
    })()
};

var n;
for (;;) {
    n = fibonacci.next();
    if (n > 1000)
        break;
    console.log(n);
}
#+end_src

**** Generator Function Direct Use
Support for generator functions, a special variant of functions where the
control flow can be paused and resumed, in order to produce sequence of values
(either finite or infinite).

#+caption:Generator function, direct use
#+name:generator-function-direct-use
#+begin_src js -n
function* range (start, end, step) {
    while (start < end) {
        yield start;
        start += step;
    }
}

for (let i of range(0, 10, 2)) {
    console.log(i); // 0, 2, 4, 6, 8
}
#+end_src

#+caption:Generator function direct use in ES5
#+name:generator-function-direct-use-ES5
#+begin_src js -n
function range (start, end, step) {
    var list = [];
    while (start < end) {
        list.push(start);
        start += step;
    }
    return list;
}

var r = range(0, 10, 2);
for (var i = 0; i < r.length; i++) {
    console.log(r[i]); // 0, 2, 4, 6, 8
}
#+end_src

**** Generator Matching
Support for generator functions, a special variant of functions where the
control flow can be paused and resumed, in order to produce sequence of values
(either finite or infinite).

#+caption:Generator matching
#+name:generator-matching-ES2015
#+begin_src js -n
let fibonacci = function* (numbers) {
    let pre = 0, cur = 1;
    while (numbers-- > 0) {
        [ pre, cur ] = [ cur, pre + cur ];
        yield cur;
    }
};

for (let n of fibonacci(1000))
    console.log(n);

let numbers = [ ...fibonacci(1000) ];

let [ n1, n2, n3, ...others ] = fibonacci(1000);
#+end_src
*** function* --- Generator Function

{{{function* Declaration)}}}

#+cindex:generator function
#+cindex:@code{function*} declaration
#+cindex:Generator object
The ~function*~ declaration (~function~ keyword followed by an asterisk)
defines a generator function, which returns a Generator object.

#+caption:Demo of the Statement function*
#+name:demo-statement-function*
#+begin_src js -n
function* generator(i) {
  yield i;
  yield i + 10;
}

var gen = generator(10);

console.log(gen.next().value);
// expected output: 10

console.log(gen.next().value);
// expected output: 20
#+end_src

You can also define generator functions using the =GeneratorFunction=
constructor, or the function expression syntax.

{{{heading(function* Expression)}}}

#+cindex:@code{function*} keyword
The ~function*~ keyword can be used to define a generator function inside an
expression.

#+caption:Demo of function* as an Expression
#+name:demo-function*-as-expression
#+begin_src js -n
function* foo() {
  yield 'a';
  yield 'b';
  yield 'c';
}

var str = "";
for (let val of foo()) {
  str = str + val;
}

console.log(str);
// expected output: "abc"
#+end_src

**** function* Syntax

{{{heading(function* Declaration or Statement)}}}

#+begin_src js
function* <name> ([<param>[, <param>[, ... <param>]]]) {
    <statements>
}
#+end_src

- <name> :: The function name.

- <param> :: The name of a formal parameter for the function.

- <statements> :: The statements comprising the body of the function.


{{{heading(function* Expression or Keyword)}}}

#+begin_src js
function* [name]([param1[, param2[, ..., paramN]]]) {
   statements
}
#+end_src

- name :: The function name. Can be omitted, in which case the function is
          anonymous.  The name is only local to the function body.

- paramN :: The name of an argument to be passed to the function.  A function
            can have up to 255 arguments.

- statements :: The statements which comprise the body of the function.

**** function* Declaration or Statement Description
#+cindex:Generator
Generators are functions which can be exited and later re-entered.  Their
context (variable bindings) will be saved across re-entrances.

#+cindex:Promises
#+cindex:asynchronous programming
#+cindex:callbacks
#+cindex:Callback Hell
#+cindex:Inversion of Control
Generators in JavaScript --- especially when combined with Promises --- are a
very powerful tool for asynchronous programming as they mitigate -- if not
entirely eliminate -- the problems with callbacks, such as Callback Hell and
Inversion of Control.

#+cindex:generator function, call
#+cindex:iterator object
#+cindex:@code{yield} expression
#+cindex:@code{done} property
#+cindex:@code{value} property
#+cindex:@code{next(<argument>)}
Calling a generator function does not execute its body immediately; an iterator
object for the function is returned instead.  When the iterator's ~next()~
method is called, the generator function's body is executed until the first
~yield~ expression, which specifies the value to be returned from the iterator
or, with ~yield*~, delegates to another generator function.  The ~next()~
method returns an object with a =value= property containing the yielded value
and a =done= property which indicates whether the generator has yielded its
last value, as a =boolean=.  Calling the ~next()~ method with an argument will
resume the generator function execution, replacing the ~yield~ expression where
execution was paused with the argument from ~next()~.

{{{subheading(return Statement)}}}

A ~return~ statement in a generator, when executed, will make the generator
finish (i.e. the =done= property of the object returned by it will be set to
=true=).  If a value is returned, it will be set as the =value= property of the
object returned by the generator.

{{{subheading(Thrown Error)}}}

#+cindex:finished
Much like a return statement, an error thrown inside the generator will make
the generator finished --- unless caught within the generator's body.

{{{subheading(Finished Generator)}}}

When a generator is finished, subsequent next calls will not execute any of
that generator's code, they will just return an object of this form: ={value:
undefined, done: true}=.

**** function* Expression or Keyword Description
#+cindex:@code{function*} expression
A ~function*~ expression is very similar to and has almost the same syntax as a
~function*~ statement.  The main difference between a ~function*~n expression
and a ~function*~ statement is the function name, which can be omitted in
~function*~ expressions to create anonymous generator functions.

**** Examples of the Generator Function

***** Simple Example

#+caption:Simple Generator Function
#+name:simple-generator-function
#+begin_src js -n
function* idMaker() {
  var index = 0;
  while (index < index+1)
    yield index++;
}

var gen = idMaker();

console.log(gen.next().value); // 0
console.log(gen.next().value); // 1
console.log(gen.next().value); // 2
console.log(gen.next().value); // 3
// ...
#+end_src

***** Example with Yielding to Another Generator Function

#+caption:Example with yielding to another Generator Function
#+name:example-with-yield
#+begin_src js -n
function* anotherGenerator(i) {
  yield i + 1;
  yield i + 2;
  yield i + 3;
}

function* generator(i) {
  yield i;
  yield* anotherGenerator(i);
  yield i + 10;
}

var gen = generator(10);

console.log(gen.next().value); // 10
console.log(gen.next().value); // 11
console.log(gen.next().value); // 12
console.log(gen.next().value); // 13
console.log(gen.next().value); // 20
#+end_src

***** Passing Arguments into Generators

#+caption:Example of Passing Arguments into Generators
#+name:passing-arguments-into-generators
#+begin_src js -n
function* logGenerator() {
  console.log(0);
  console.log(1, yield);
  console.log(2, yield);
  console.log(3, yield);
}

var gen = logGenerator();

// the first call of next executes from the start of the function
// until the first yield statement
gen.next();             // 0
gen.next('pretzel');    // 1 pretzel
gen.next('california'); // 2 california
gen.next('mayonnaise'); // 3 mayonnaise
#+end_src

***** Return Statement in a Generator

#+caption:Example of the return statement in a Generator
#+name:return-statement-in-generator
#+begin_src js -n
function* yieldAndReturn() {
  yield "Y";
  return "R";
  yield "unreachable";
}

var gen = yieldAndReturn()
console.log(gen.next()); // { value: "Y", done: false }
console.log(gen.next()); // { value: "R", done: true }
console.log(gen.next()); // { value: undefined, done: true }
#+end_src

***** Generator as an Object Property

#+caption:Example of a Generator as an Object Property
#+name:generator-as-an-object-property
#+begin_src js -n
const someObj = {
  *generator () {
    yield 'a';
    yield 'b';
  }
}

const gen = someObj.generator()

console.log(gen.next()); // { value: 'a', done: false }
console.log(gen.next()); // { value: 'b', done: false }
console.log(gen.next()); // { value: undefined, done: true }
#+end_src

***** Generator as an object method

#+caption:Example of a Generator as an Object Method
#+name:generator-as-an-object-method
#+begin_src js -n
class Foo {
  *generator () {
    yield 1;
    yield 2;
    yield 3;
  }
}

const f = new Foo ();
const gen = f.generator();

console.log(gen.next()); // { value: 1, done: false }
console.log(gen.next()); // { value: 2, done: false }
console.log(gen.next()); // { value: 3, done: false }
console.log(gen.next()); // { value: undefined, done: true }
#+end_src

***** Generator as a Computed Property

#+caption:Example of a Generator as a Computed Property
#+name:generator-as-a-computed-proptery
#+begin_src js -n
class Foo {
  *[Symbol.iterator] () {
    yield 1;
    yield 2;
  }
}

const SomeObj = {
  *[Symbol.iterator] () {
    yield 'a';
    yield 'b';
  }
}

console.log(Array.from(new Foo)); // [ 1, 2 ]
console.log(Array.from(SomeObj)); // [ 'a', 'b' ]
#+end_src

***** Generators are not Constructable

#+caption:Generators are not constructable
#+name:generators-are-not-constructable
#+begin_src js -n
function* f() {}
var obj = new f; // throws "TypeError: f is not a constructor
#+end_src

***** Generator Defined in an Expression

#+caption:Example of a Generator defined in an expression
#+name:generator-defined-in-an-expression
#+begin_src js -n
const foo = function* () {
  yield 10;
  yield 20;
};

const bar = foo();
console.log(bar.next()); // {value: 10, done: false}
#+end_src
***** Unnamed Generator Function
The following example defines an unnamed generator function and assigns it to
~x~.  The function yields the square of its argument:

#+caption:Example of function* Expression
#+name:unnamed-generator-function
#+begin_src js -n
var x = function*(y) {
   yield y * y;
};
#+end_src
** Map/Set & WeakMap/WeakSet

** Typed Arrays

** New Built-In Methods

** Asynchronous Programming in JavaScript
#+cindex:asynchronous programming
#+cindex:Promises
The following is some background information on asynchronous programming in
JavaScript, and provides needed background information on Promises.

*** The JavScript Call Stack
#+cindex:call stack
When a function ~f~ calls a function ~g~, ~g~ needs to know where to return to
(inside ~f~) after it is done.  This information is usually managed with a stack,
the /call stack/.

#+name:print-call-stack
#+begin_src js -n :tangle src/async/stack_trace.js :mkdirp yes
function h(z) {
    // Print stack trace
    console.log(new Error().stack); // (A)
}
function g(y) {
    h(y + 1); // (B)
}
function f(x) {
    g(x + 1); // (C)
}
f(3); // (D)
return; // (E)
#+end_src

Initially, when the program above is started, the call stack is empty.  After
the function call ~f(3)~ in line D, the stack has one entry:

: Location in global scope

After the function call ~g(x + 1)~ in line C, the stack has two entries:

: Location in f
: Location in global scope

After the function call ~h(y + 1)~ in line B, the stack has three entries:

: Location in g
: Location in f
: Location in global scope

The stack trace printed in line A shows you what the call stack looks like:

#+begin_example
Error
    at h (stack_trace.js:2:17)
    at g (stack_trace.js:6:5)
    at f (stack_trace.js:9:5)
    at <global> (stack_trace.js:11:1)
#+end_example

Next, each of the functions terminates and each time the top entry is removed
from the stack.  After function ~f~ is done, we are back in global scope and
the call stack is empty.  In line E we return and the stack is empty, which
means that the program terminates.

*** The Browser Event Loop

*** Receiving Results Asynchronously

*** Looking Ahead

** Promises
#+cindex:promises
First class representation of a value that may be made asynchronously and be
available in the future.

Promises can be vaguely defined as “a proxy for a value that will eventually
become available.”

*** Traditional Callback Method

#+cindex:callback
Traditionally JavaScript relied on /callbacks/ instead of /promises and
chaining/.  If the ~fetch~ function asked for a /callback/, you’d have to add
one that would then get executed whenever the fetch operation ended.

#+cindex:asynchronous code flow
#+cindex:best practice
Typical asynchronous code flow conventions in Node.js established a best
practice of reserving the first parameter in the callback for errors---that may
or may not occur---during the ~fetch~‐ing process.  The rest of the parameters
could be used to read the results of the asynchronous operation.

#+cindex:callback-based API
#+cindex:traditional asynchronous code
The following shows how ~fetch()~ would look if it had a callback-based API:

#+begin_src js
fetch('/items', (err, res) => {
    if (err) {
        // handle err
    } else {
        // handle response
    }
});
#+end_src

The callback would not be invoked until the =/items= resource had been
retrieved, or an error arose from the fetch operation.  Execution would remain
asynchronous and nonblocking.

*Note* that in this model you could only specify /a single callback/.  That
callback would be responsible for /all/ functionality derived from the
response, and it would be up to the consumer to come up with a mechanism to
compose different aspects of handling the response into that single callback.

*** An Event-Driven Model
#+cindex:event-driven model
#+cindex:events
Besides traditional callbacks, another API design choice might have been to use
an event-driven model.  If this model were implemented by ~fetch~, ~fetch~
would be able to register callbacks for different kinds of events, binding as
many event handlers as needed for any events.  Typically there would be an
=error= event that's raised when things go awry, and other events are raised
when notable things happen.

Here is some code that would be used if ~fetch~ were based upon events:

#+begin_src js
fetch('/items')
    .on('error', err => {
        // handle error
    })
    .on('data', res => {
        // handle response
    })
#+end_src

*Note* that binding several listeners for each type of event would eliminate
the concern we had earlier about having to centralize response handling in a
single callback.

Events, however, make it hard to chain callbacks and have them fire when
another asynchronous task is fulfilled, and that’s where promises come in.
Moreover, events are better suited to handle streams of values, making them
somewhat inappropriate in this particular use case.

*** Asynchronous Fetch Example

#+cindex:@code{fetch()}
: fetch('/items')
makes a "fire and forget" =GET= request against =/items=, meaning you ignore
the response and whether the request succeeded.

#+cindex:Promise
#+cindex:@code{then()} method
#+cindex:@code{response} parameter
The ~fetch()~ method returns a =Promise=.  You can chain the ~then()~ method on
that =Promise=, and the callback will be executed once the =/items= resource
finishes loading, receiving a ~response~ parameter.

: fetch('/items').then(response => {
:     // do something with the response
: })

Here is how ~fetch()~ might be implemented in a browser:

#+begin_src js
const p = fetch('/items');

p.then(res => {
    // handle response
});

p.catch(err => {
    // handle error
});
#+end_src

#+cindex:reaction
#+cindex:fulfillment
#+cindex:fulfillment value
#+cindex:@code{then()} method
#+cindex:@code{catch()} method
#+cindex:rejection
/Reactions/ passed to ~then()~ can be used to handle the /fulfillment/ of a
promise, which is accompanied by a /fulfillment value/; and /reactions/ passed
to ~catch()~ are executed with a /rejection reason/ that can be used when
handling rejections.

#+cindex:register reaction
You can also /register/ a /reaction/ to rejections in the /second/ argument
passed to ~then()~.

#+begin_src js
const p = fetch('/items');
p.then(
    res => {
    // handle response
},
    err => {
    // handle error
});
#+end_src

Another alternative is to omit the /fulfillment reaction/ in ~then(fulfillment,
rejection)~ (use =null= instead).  Using ~then(null, rejection)~ is equivalent
to ~catch(rejection)~.

#+begin_src js
const p = fetch('/items');
p.then(res => {
    // handle response
});
p.then(null, err => {
    // handle error
});
#+end_src

*** Chaining of Promises
#+cindex:chaining of promises
The ~then()~ and ~catch()~ methods return a new =Promise= every time, creating
a tree-like data structure.  That’s important because chaining can have wildly
different results depending on where you append a ~then()~ or a ~catch()~ call.

Assume you have a ~p1~ promise, and ~p1.then()~ returns a ~p2~ promise.  The
~p1~ and ~p2~ promises are nodes connected by the ~p1.then()~ reaction
handler.

Reactions create new promises that are attached to the tree as children of the
promise they are reacting to.

~p1.then(r1).then(r2)~ creates two new promises ~p2~ and ~p3~.  Reaction ~r2~
is going to fire if ~p2~ fulfills, while reaction ~r1~ will fire when ~p1~ is
fulfilled.

Figuring out the tree-like nature of promises is the key to unlocking a deep
understanding of how promises behave.  See the tool [[https://bevacqua.github.io/promisees/][Promisees]] to play around
with promise chains while visualizing the tree structure they leave behind.
Promisees lets you write a piece of code and visualize how the underlying graph
evolves as promises are settled in fulfillment or rejection.

*** Creating Promises

**** Using the Promise Constructor

#+cindex:promise creation
#+cindex:Promise constructor
#+cindex:resolver
#+cindex:@code{resolve()} method
#+cindex:@code{reject()} method
#+cindex:settle
#+cindex:pending state
#+cindex:reactions
A promise is created by passing the ~Promise~ constructor a /resolver/ that
decides how and when the promise is settled, by calling either a ~resolve~
method that will /settle the promise in fulfillment/ or a ~reject~ method that
will /settle the promise as a rejection/.  Until the promise is settled by
calling either function, it’ll be in a /pending state/ and any /reactions/
attached to it won’t be executed.

The following snippet of code creates a promise from scratch where we’ll wait
for a second before randomly settling the promise with a fulfillment or
rejection result.

#+begin_src js
new Promise (function (resolve, reject) {
    setTimeout (function () {
        if (Math.random() > 0.5) {
            resolve('random success')
        } else {
            reject(new Error ('random failure'))
        }
    }, 1000)
})
#+end_src

**** Using the ~resolve()~ and ~reject()~ Methods

Promises can also be created using ~Promise.resolve~ and ~Promise.reject~.
These methods create promises that will immediately settle with a /fulfillment
value/ and a /rejection reason/, respectively.

#+begin_src js
Promise.resolve({ result: 123 }).then(data => console.log(data.result))
// 123
#+end_src

**** Looking at Reactions
When a promise is fulfilled, reactions registered with its ~then()~ method are
executed.  When a promise is rejected, reactions registered with its ~catch()~
method are executed.  Those reactions can, in turn, result in three different
situations depending on whether they
- return a value,
- a ~Promise~,
- a =thenable=, or
- throw an error.


=Thenables= are objects considered promise-like that can be cast into a
~Promise~ using ~Promise.resolve()~.

A reaction may return a /value/, which would cause the promise returned by
~then()~ to become fulfilled with that value.  Promises can be chained to
transform the fulfillment value of the previous promise over and over:

#+begin_src js
Promise
  .resolve(2)
  .then(x => x * 7)
  .then(x => x - 3)
  .then(x => console.log(x))
// 7
#+end_src

A reaction may return a promise.

#+begin_src js
Promise
  .resolve(2)
  .then(x => new Promise(function (resolve) {
      setTimeout(() => resolve(x * 1000), x * 1000)
  }))
  .then(x => console.log(x))
// 2000
#+end_src

A reaction may throw an error, which would cause the promise returned by
~then()~ to become rejected and thus follow the ~catch()~ branch, using said
error as the rejection reason.

#+begin_src js
const p = fetch('/items')
  .then(res => { throw new Error('unexpectedly') })
  .catch(err =>  console.error(err))
#+end_src
*** Promise Continuation and Chaining

#+cindex:@code{catch()} method
When an error happens in a promise resolver, you can catch that error using the
~catch()~ method:

#+begin_src js
new Promise((resolve, reject) => reject(new Error('oops')))
    .catch(err => console.error(err));
#+end_src

#+cindex:exception in resolver
A promise will settle as a rejection when the resolver calls ~reject()~ or if
an exception is thrown inside the resolver.

#+begin_src js
new Promise((resolve, reject) => {
    throw new Error('oops');
}).catch(err => console.error(err));
#+end_src

Errors that occur while executing a fulfillment or rejection reaction result in
a promise being rejected.

#+begin_src js
Promise
    .resolve(2)
    .then(x => { throw new Error('failed') })
    .catch(err => console.error(err));
#+end_src

Decompose the series of chained method calls into variables.

#+begin_src js :results output
const p1 = Promise.resolve(2);
const p2 = p1.then(x => { throw new Error('failed') });
const p3 = p2.catch(err => console.log(err));
#+end_src

#+RESULTS:
: Error: failed

If you attached the ~catch()~ reaction to ~p1~, you wouldn't be able to catch
the error originated in the ~then()~ reaction.

As long as an error remains uncaught in a promise chain, a rejection handler
will be able to capture it.  In the following example we’ve introduced an
intermediary ~then()~ call in between ~p2~, where the error originated, and
~p4~, where we attach the rejection reaction.  When ~p2~ settles with a
rejection, ~p3~ becomes settled with a rejection, as it depends on ~p2~
directly.  When ~p3~ settles with a rejection, the rejection handler in ~p4~
fires.

#+begin_src js :results output
const p1 = Promise.resolve(2)
const p2 = p1.then(x => { throw new Error('failed') })
const p3 = p2.then(x => x * 2)
const p4 = p3.catch(err => console.log(err))
#+end_src

#+RESULTS:
: Error: failed

The following example shows how you could print a statement to the browser con‐
sole by creating a ~p4~ fulfillment handler that depends on ~p3~ to settle
successfully with fulfillment.

#+begin_src js :results output
const p1 = Promise.resolve(2)
const p2 = p1.then(x => { throw new Error('failed') })
const p3 = p2.catch(err => console.log(err))
const p4 = p3.then(() => console.log('crisis averted'))
#+end_src

#+RESULTS:
: Error: failed
: crisis averted

Similarly, if an error occurred in the ~p3~ rejection handler, we could capture
that one as well using ~catch()~.  The next piece of code shows how an
exception being thrown in ~p3~ could be captured using ~p3.catch()~ just like
with any other errors arising in previous examples.

#+begin_src js :results output
const p1 = Promise.resolve(2)
const p2 = p1.then(x => { throw new Error('failed') })
const p3 = p2.catch(err => { throw new Error('oops') })
const p4 = p3.catch(err => console.log(err))
#+end_src

#+RESULTS:
: Error: oops

The following example prints ~err.message~ once instead of twice.  That’s
because no errors happened in the first ~catch()~, so the rejection branch for
that promise wasn’t executed.

#+begin_src js
fetch('/items')
    .then(res => res.a.prop.that.does.not.exist)
    .catch(err => console.error(err.message))
    .catch(err => console.error(err.message))
// <- 'Cannot read property "prop" of undefined'
#+end_src

In contrast, the next snippet will print ~err.message~ twice.  It works by
saving a reference to the promise returned by ~then()~, and then tacking two
~catch()~ reactions onto it.  The second ~catch()~ in the previous example was
capturing errors produced in the promise returned from the first ~catch()~, while
in this case both rejection handlers branch off of ~p~.

#+begin_src js
const p = fetch('/items')
  .then(res => res.a.prop.that.does.not.exist)
p.catch(err => console.error(err.message))
p.catch(err => console.error(err.message))
// <- 'Cannot read property "prop" of undefined'
// <- 'Cannot read property "prop" of undefined'
#+end_src

We should observe, then, that promises can be chained arbitrarily.  As we just
saw, you can save a reference to any point in the promise chain and then append
more promises on top of it.  This is one of the fundamental points to
understanding promises.

#+begin_src js
const p1 = fetch('/items')
const p2 = p1.then(res => res.a.prop.that.does.not.exist)
const p3 = p2.catch(err => {})
const p4 = p3.catch(err => console.error(err.message))
#+end_src

Here is an enumeration of what is going on as that piece of code is executed:

1. ~fetch()~ returns a brand new ~p1~ promise.

2. ~p1.then()~ returns a brand new ~p2~ promise, which will react if ~p1~ is
   fulfilled.

3. ~p2.catch()~ returns a brand new ~p3~ promise, which will react if ~p2~ is
   rejected.

4. ~p3.catch()~ returns a brand new ~p4~ promise, which will react if ~p3~ is
   rejected.

5. When ~p1~ is fulfilled, the ~p1.then()~ reaction is executed.

6. Afterwards, ~p2~ is rejected because of an error in the ~p1.then()~
   reaction.

7. Since ~p2~ was rejected, ~p2.catch()~ reactions are executed, and the
   ~p2.then()~ branch is ignored.

8. The ~p3~ promise from ~p2.catch()~ is fulfilled, because it doesn’t produce
   an error or result in a rejected promise.

9. Because ~p3~ was fulfilled, the ~p3.catch()~ is never followed.  The
   ~p3.then()~ branch would’ve been used instead.
*** Creating a Promise
#+cindex:promise creation
A promise can be created by:
- using a function that returns a promise, such as ~fetch()~
- calling ~Promise.resolve()~ or ~Promise.reject()~
- using the Promise constructor function


#+cindex:Promise constructor function
#+cindex:promise resolver function
#+cindex:promise settlement
#+cindex:settle
#+cindex:@code{resolve} function
#+cindex:@code{reject} function
Promises can be created from scratch by using ~new Promise(resolver)~.  The
~resolver~ parameter is a function that will be used to settle the promise.
The ~resolver~ takes two arguments: a ~resolve~ function and a ~reject~
function.

The pair of promises shown in the next snippet are settled in fulfillment and
rejection, respectively.

#+cindex:fulfillment value
- settling the first promise with a fulfillment value of 'result',
- rejecting the second promise with an Error object, specifying 'reason' as its
  message.

#+begin_src js
new Promise(resolve => resolve('result'))
new Promise((resolve, reject) => reject(new Error('reason')))
#+end_src

#+cindex:fulfill a promise
#+cindex:fulfillment value
#+cindex:result fulfillment value
Usually promises will fulfill with a /result/ such as the response from an Ajax
call, as we’ve seen with ~fetch~.  You’ll definitely want to state the reason
for your rejections---typically wrapping them in an ~Error~ object so that you
can report back a stack trace.  Note that only the first call made to one of
these functions (~resolve()~ or ~reject()~) will have an impact---once a
promise is settled its outcome can’t change.
** Meta-Programming

** Internationalization & Localization

** Protocols
#+cindex:protocols, new to ES2015
A couple of additions to ECMAScript 2015 aren't new built-ins or syntax, but
protocols.  These protocols can be implemented by any object respecting some
conventions.

{{{heading(The Two New Protocols)}}}

There are two protocols: The /iterable protocol/ and the /iterator protocol/.

#+caption:The Iterable and Iterator Protocols
#+name:the-iterable-and-iterator-protocols
[[file:figs/iterable_and_iterator_protocols.png]]

An object that conforms to the /iterable/ protocol has a method
~[Symbol.iterator]~ that returns an object that convorms to the /iteration/
protoocol.  An object that conforms to the /iteration/ protocol has a ~next()~
method that returns an object containing a =done= property (which returns a
=boolean=) which returns =false= so long as there are more values to iterate
over, and =true= at the completion of all the values; and a =value= property,
which returns some value (the next iterated value) or =undefined= (when all
done iterating).

- Iterable ::

              A data structure that wants to make its elements accessible to
              the public. It does so by implementing a method whose key is
              ~Symbol.iterator~.  That method is a factory for iterators.  That
              is, it will create iterators.

- Iterator ::

              A pointer for traversing the elements of a data structure.


#+caption:Outline of the Iterable and Iteration protocols
#+name:outline-of-iterable-and-iteration-protocols
#+begin_src js
const iterable = {
    [Symbol.iterator]() {
        const iterator = {
            <Statements>...
            next() {
                <Statements>...
                {done: ..., value: ...}
            }
        };
        return iterator;
    }
};

var iterator = iterable[Symbole.iterator]();
iterator.next();
...
#+end_src

For example, the =for-of= loop takes an iterable, and creates its iterator.  It keeps on
calling the ~next()~ method until =done= is =true=.

{{{heading(Iterables in JavaScript)}}}

- Arrays and TypedArrays

- Strings

- Maps

- Sets

- ~arguments~

- DOM elements


{{{heading(Things that Take Iterables)}}}


- =for...of= loop

- destructuring of Arrays

- =spread= operator

- Maps and Sets

- Promise.all and Promise.race

*** Iterable Protocol
#+cindex:iterable protocol
#+cindex:protocol, iterable
#+cindex:iteration beehavior
The /iterable protocol/ allows JavaScript objects to define or customize their
iteration behavior, such as what values are looped over in a =for..of=
construct.  Some built-in types are built-in iterables with a default iteration
behavior, such as Array or Map, while other types (such as Object) are not.

In order to be /iterable/, an object must implement the ~@@iterator~ method,
meaning that the object (or one of the objects up its prototype chain) must
have a property with a ~@@iterator~ key which is available via constant
~Symbol.iterator~:

| Property            | Value                                                                                    |
|---------------------+------------------------------------------------------------------------------------------|
| ~[Symbol.iterator]~ | A zero arguments function that returns an object, conforming to the /iterator protocol/. |
|---------------------+------------------------------------------------------------------------------------------|

Whenever an object needs to be iterated (such as at the beginning of a
=for..of= loop), its ~@@iterator~ method is called with no arguments, and the
returned iterator is used to obtain the values to be iterated.

*** Iterator Protocol
#+cindex:iterator protocol
#+cindex:protocol, iterator
The /iterator protocol/ defines a standard way to produce a sequence of values
(either finite or infinite), and potentially a return value when all values
have been generated.

#+cindex:iterator object
An object is an iterator when it implements a ~next()~ method with the
following semantics:

- next ::

          A zero arguments function that returns an object with at least the
          following two properties:

  - done (boolean) ::

    - Has the value =true= if the iterator is past the end of
      the iterated sequence.  In this case =value= optionally
      specifies the return value of the iterator.

    - Has the value =false= if the iterator was able to produce the next value
      in the sequence.  This is equivalent of not specifying the =done=
      property altogether.

  - value ::

             any JavaScript value returned by the iterator.  Can be omitted
             when =done= is true.

  The ~next~ method always has to return an object with appropriate properties
          including =done= and =value=.  If a non-object value gets returned
          (such as =false= or =undefined=), a =TypeError= ("iterator.next()
          returned a non-object value") will be thrown.


It is not possible to know reflectively whether a particular object implements
the iterator protocol; however it is easy to create an object that satisfies
both the /iterator/ and /iterable/ protocols (as shown in the example below).
Doing so allows an iterator to be consumed by the various syntaxes expecting
iterables.  *Thus it is rarely desirable to implement the iterator protocol
without also implementing iterable*.

#+caption:Example of Implementing both iterable and iterator
#+name:implementing-both-iterable-and-iterator
#+begin_src js -n
var myIterator = {
    next: function() {
        // ...
    },
    [Symbol.iterator]: function() { return this }
};
#+end_src

*** Examples of the Iterator and Iterable Protocols
**** Examples using the Iteration Protocols

A =String= is an example of a built-in iterable object:

#+begin_src js -n
var someString = 'hi';
typeof someString[Symbol.iterator];          // "function"
#+end_src

String's default iterator returns the string's code points one by one:

#+begin_src js -n
var iterator = someString[Symbol.iterator]();
iterator + '';                               // "[object String Iterator]"

iterator.next();                             // { value: "h", done: false }
iterator.next();                             // { value: "i", done: false }
iterator.next();                             // { value: undefined, done: true }
#+end_src

#+cindex:@code{spread} operator
Some built-in constructs, such as the =spread= syntax, use the same iteration
protocol under the hood:

: [...someString]                              // ["h", "i"]

We can redefine the iteration behavior by supplying our own ~@@iterator~:

#+caption:Example of redefining the iteration behavior
#+name:redefine-iteration-behavior
#+begin_src js -n
var someString = new String('hi');           // need to construct a String object explicitly to avoid auto-boxing

someString[Symbol.iterator] = function() {
  return { // this is the iterator object, returning a single element, the string "bye"
    next: function() {
      if (this._first) {
        this._first = false;
        return { value: 'bye', done: false };
      } else {
        return { done: true };
      }
    },
    _first: true
  };
};
#+end_src

Notice how redefining ~@@iterator~ affects the behavior of built-in constructs
that use the iteration protocol:

#+begin_src js -n
[...someString];                             // ["bye"]
someString + '';                             // "hi"
#+end_src

**** Examples using the Iterable Protocol

***** Built-in Iterables
#+cindex:iterable, built-in
String, Array, TypedArray, Map and Set are all built-in iterables, because each
of their prototype objects implements an ~@@iterator~ method.

***** User-defined Iterables
#+cindex:iterable, user-defined
We can make our own iterables like this:

#+caption:Example of Making a User-defined Iterable
#+name:making-a-user-defined-iterable
#+begin_src js -n
var myIterable = {};
myIterable[Symbol.iterator] = function* () {
    yield 1;
    yield 2;
    yield 3;
};
[...myIterable]; // [1, 2, 3]
#+end_src

***** Built-in APIs Accepting Iterables
#+cindex:iterable API
There are many APIs that accept iterables, for example:
- Map([iterable]),
- WeakMap([iterable]),
- Set([iterable])
- WeakSet([iterable])


#+caption:Example of APIs accepting and iterable
#+name:apis-accepting-iterable
#+begin_src js -n
var myObj = {};
new Map([[1, 'a'], [2, 'b'], [3, 'c']]).get(2);               // "b"
new WeakMap([[{}, 'a'], [myObj, 'b'], [{}, 'c']]).get(myObj); // "b"
new Set([1, 2, 3]).has(3);                               // true
new Set('123').has('2');                                 // true
new WeakSet(function* () {
    yield {};
    yield myObj;
    yield {};
}()).has(myObj);                                         // true
#+end_src

Also see
- Promise.all(iterable),
- Promise.race(iterable)
- Array.from()

***** Syntaxes Expecting Iterables
Some statements and expressions expect iterables, for example the =for-of=
loops, =spread= syntax, =yield*=, and destructuring assignment:

#+caption:Examples of Syntaxes Expecting Iterables
#+name:syntaxes-expecting-iterables
#+begin_src js -n
for(let value of ['a', 'b', 'c']){
    console.log(value);
}
// "a"
// "b"
// "c"

[...'abc']; // ["a", "b", "c"]

function* gen() {
  yield* ['a', 'b', 'c'];
}

gen().next(); // { value:"a", done:false }

[a, b, c] = new Set(['a', 'b', 'c']);
a // "a"
#+end_src
**** Examples of Iterators
***** Simple iterator
***** Infinite iterator
***** With a generator
***** With ES2015 class
**** Is a Generator Object an Iterator or an Iterable
#+cindex:generator object
A generator object is both, iterator and iterable:

#+caption:Generator Object is both iterator and iterable
#+name:generator-object-both-iterator-and-iterable
#+begin_src js -n
var aGeneratorObject = function* () {
    yield 1;
    yield 2;
    yield 3;
}();
typeof aGeneratorObject.next;
// "function", because it has a next method, so it's an iterator
typeof aGeneratorObject[Symbol.iterator];
// "function", because it has an @@iterator method, so it's an iterable
aGeneratorObject[Symbol.iterator]() === aGeneratorObject;
// true, because its @@iterator method returns itself (an iterator), so it's an well-formed iterable
[...aGeneratorObject];
// [1, 2, 3]
#+end_src
**** Turning a Random Object into an Iterable and Iterator
Given the following object, implement code so that it conforms to the Iterable
and Iterator protocols.

#+caption:The Object 'myFavoriteAuthors'
#+name:myFavoriteAuthors
#+header: :mkdirp yes :noweb tangle
#+begin_src js -n :tangle examples/protocols/myFavoriteAuthors.js
exports.myFavoriteAuthors = {
    allAuthors: {
        fiction: [
            'Agatha Christie',
            'J. K. Rowling',
            'Dr. Seuss',
        ],
        scienceFiction: [
            'Neal Stephenson',
            'Arthur C. Clark',
            'Isaac Asimov',
            'Robert Heinlein',
        ],
        fantapsy: [
            'J. R. R. Tolkien',
            'J. K. Rowling',
            'Terry Pratchett',
        ],
    },
    <<myFavoriteAuthorsIterable>>,
}
#+end_src

{{{heading(for-of Iterates over the Authors in the Object)}}}

Given an implemented Iterable and Iterator, the following statement works
without throwing an Error (currently, you would get a =TypeError= saying that
the object is not iterable).

#+caption:Iterate over the object 'myFavoriteAuthors'
#+name:iterate-over-myFavoriteAuthors
#+begin_src js
for (let author of myFavouriteAuthors) {
  console.log(author)
}
#+end_src

{{{heading(Implement the Iterable Protocol)}}}

The first thing that must happen is to make the object an Iterable (by adding a
~[Symbol.iterator]~ method).  This method must return an object that is an
Iterator, that is, that implements a ~next()~ method that returns an object
that includes a =value= property and a =done= property: ={value:
<value>, done: <boolean>}=.

The ~Object.values(<obj>)~ class method returns an array of an object's own
enumerable property values (no properties from the prototype chain are
included) in the same order as that provided by a =for...in= loop.

#+caption:Implement an Iterable
#+name:myFavoriteAuthorsIterable
#+header: :noweb yes
#+begin_src js -n
[Symbol.iterator]() {
    // Get all the authors in an array
    const genres = Object.values(this.allAuthors);

    // Store the current genre and author index
    let currentAuthorIndex = 0;
    let currentGenreIndex = 0;

    return {
        <<myFavoriteAuthorsIterator>>
    }
}
#+end_src

The Iterator is implemented as follows:

#+caption:Create an Iterator
#+name:myFavoriteAuthorsIterator
#+begin_src js -n
// Implementation of next()
next () {
    // authors according to current genre index
    const authors = genres[currentGenreIndex];

    // doNotHaveMoreAuthors is true when the authors array is exhausted.
    // That is, all items are consumed.
    const doNothaveMoreAuthors = !(currentAuthorIndex < authors.length);
    if (doNothaveMoreAuthors) {
      // When that happens, we move the genre index to the next genre
      currentGenreIndex++;
      // and reset the author index to 0 again to get new set of authors
      currentAuthorIndex = 0;
    }

    // if all genres are over, then we need tell the iterator that we
    // can not give more values.
    const doNotHaveMoreGenres = !(currentGenreIndex < genres.length);
    if (doNotHaveMoreGenres) {
      // Hence, we return done as true.
      return {
        value: undefined,
        done: true
      };
    }

    // if everything is correct, return the author from the
    // current genre and incerement the currentAuthorindex
    // so next time, the next author can be returned.
    return {
      value: genres[currentGenreIndex][currentAuthorIndex++],
      done: false
    }
}
#+end_src
* EMCAScript 2016
* ECMAScript 2017
ECMAScript 2017 introduced
- Async Functions :: Async functions improve the asynchronous programming
     experience by providing syntax for promise-returning functions.
- Shared Memory :: Shared Memory and Atomics introduce a new [[https://tc39.es/ecma262/#sec-memory-model][memory model]] that
                   allows multi-agent programs to communicate using atomic
                   operations that ensure a well-defined execution order even
                   on parallel CPUs.
- Atomics :: introduce a new [[https://tc39.es/ecma262/#sec-memory-model][memory model]]


along with smaller language and library enhancements, bug fixes, and editorial
updates.

This specification also includes new static methods on Object:

- Object.values
- Object.entries
- Object.getOwnPropertyDescriptors

* ECMAScript 2018
ECMAScript 2018 introduced support for asynchronous iteration via the
- AsyncIterator protocol and
- async generators.


It also included four new regular expression features:
- the dotAll flag,
- named capture groups,
- Unicode property escapes, and
- look-behind assertions.


Lastly it included object
- rest and
- spread properties.
* ECMAScript 2019
- [[https://www.ecma-international.org/ecma-262/10.0/index.html#Title][ECMAScript® 2019 Language Specification]]
- [[https://github.com/tc39/ecma262][tc39 / ecma262 on GitHub]]
  - This repository contains the source for the current draft of ECMA-262, the
    ECMAScript® Language Specification.
- [[https://tc39.es/ecma262/][Draft ECMA-262 / August 7, 2019]]
  - Currently at ECMAScript 2020
  - This Ecma Standard defines the ECMAScript 2020 Language. It is the tenth
    edition of the ECMAScript Language Specification.


ECMA-262, 10th Edition, June 2019

This specification, the 10th edition, introduces a few new built-in functions:
- Array.prototype.flat
- Array.prototype.flatMap

  for flattening arrays

- Object.fromEntries

  for directly turning the return value of ~Object.entries~ into a new Object

- String.prototype.trimStart
- String.prototype.trimEnd

  as better-named alternatives to the widely implemented but non-standard
  ~String.prototype.trimLeft~ and ~trimRight~ built-ins.


In addition, this specification includes a few minor updates to syntax and
semantics.  Updated syntax includes:
- optional catch binding parameters and
- allowing U+2028 (LINE SEPARATOR) and U+2029 (PARAGRAPH SEPARATOR) in string
  literals to align with JSON.


Other updates include:
- requiring that Array.prototype.sort be a stable sort,
- requiring that JSON.stringify return well-formed UTF-8 regardless of input,
  and
- clarifying Function.prototype.toString by requiring that it either return the
  corresponding original source text or a standard placeholder.

** Object.fromEntries
#+cindex:@code{Object.fromEntries}
A proposal[fn:8] for a new static method ~Object.fromEntries~ in ECMAScript for
transforming a list of key-value pairs into an object.

~Object.fromEntries~ is proposed to perform the reverse of ~Object.entries~: it
accepts an iterable of key-value pairs and returns a new object whose own keys
and corresponding values are given by those pairs.

: obj = Object.fromEntries([['a', 0], ['b', 1]]); // { a: 0, b: 1 }

There is no inverse of ~Object.entries~ for constructing objects from key-value
pairs, so to do so one typically must write a helper or inline reducer:

: obj = Array.from(map).reduce((acc, [ key, val ]) => Object.assign(acc, { [key]: val }), {});

This can be written many different ways, and potentially adds noise because
it's not likely to be obviously related to the outward purpose of the function
doing it.
** String.prototype.trimStart and String.prototype.trimEnd
ES5 standardized ~String.prototype.trim~.  All major engines have also
implemented corresponding ~trimLeft~ and ~trimRight~ functions---without any
standard specification.  For consistency with ~padStart~/~padEnd~ we
propose[fn:9] ~trimStart~ and ~trimEnd~ and ~trimLeft~/~trimRight~ as aliases
required for web compatibility.
** Array.prototype.flatMap and Array.prototype.flat

#+attr_texinfo: :indic code
- Array.prototype.flat :: returns a new array with all sub-array elements
     concatenated into it recursively up to the specified depth.

  #+attr_texinfo: :options Array.prototype flat ( [ depth ] )
  #+begin_defmethod
  When the flat method is called with zero or one arguments, the following
  steps are taken:

  1. Let O be ? ToObject(this value).
  2. Let sourceLen be ? ToLength(? Get(O, "length")).
  3. Let depthNum be 1.
  4. If depth is not undefined, then
     a. Set depthNum to ? ToInteger(depth).
  5. Let A be ? ArraySpeciesCreate(O, 0).
  6. Perform ? FlattenIntoArray(A, O, sourceLen, 0, depthNum).
  7. Return A.
  #+end_defmethod

- Array.prototype.flatMap :: first maps each element using a mapping function,
     then flattens the result into a new array.  It is identical to a map
     followed by a flatten of depth 1, but ~flatMap~ is quite often useful and
     merging both into one method is slightly more efficient.

  #+attr_texinfo: :options Array.prototype flatMap ( mapperFunction [, thisArg] )
  #+begin_defmethod
  When the ~flatMap~ method is called with one or two arguments, the following
  steps are taken:

  1. Let O be ? ToObject(this value).
  2. Let sourceLen be ? ToLength(? Get(O, "length")).
  3. If IsCallable(mapperFunction) is false, throw a TypeError exception.
  4. If thisArg is present, let T be thisArg; else let T be undefined.
  5. Let A be ? ArraySpeciesCreate(O, 0).
  6. Perform ? FlattenIntoArray(A, O, sourceLen, 0, 1, mapperFunction, T).
  7. Return A.
  #+end_defmethod
** Optional Catch Binding
This proposal[fn:8] makes a grammatical change to ECMAScript, allowing the
omission of a catch binding in cases where the binding would not be used.  The
grammar change introduced by this proposal allows for the catch binding and its
surrounding parentheses to be omitted, as in

#+caption:Grammar change for optional catch binding
#+name:optional-catch-binding
#+begin_src js
try {
  // ...
} catch {
  // ...
}
#+end_src
** Symbol.prototype.description
Proposal[fn:8] to add ~Symbol.prototype.description~ to ECMAScript.

Goal is to expose the =[[Description]]= internal slot of a symbol directly
instead of just indirectly through ~Symbol.prototype.toString~.

- Symbol.prototype.description :: is an accessor property whose ~set~ accessor
     function is undefined.  Its ~get~ accessor function performs the following
     steps:

  1. Let s be the this value.
  2. Let sym be ? thisSymbolValue(s).
  3. Return sym. =[[Description]]=
** Function.prototype.toString Revision
 ECMA-262 proposal[fn:8] to update ~Function.prototype.toString~

- https://tc39.es/Function-prototype-toString-revision/

** JSON Superset
Proposal[fn:8] to make all JSON text valid ECMA-262, i.e., to extend ECMA-262
syntax into a superset of JSON.

{{{heading(Motivation)}}}

ECMAScript claims JSON as a subset in JSON.parse, but (as has been
well-documented) that is not true because JSON strings can contain unescaped
=U+2028 LINE SEPARATOR= and =U+2029 PARAGRAPH SEPARATOR= characters while
ECMAScript strings cannot.

These exceptions add unnecessary complexity to the specification and increase
the cognitive burden on both implementers and users, allowing for the
introduction of subtle bugs.  Also, as a lesser but concrete corrolary problem,
certain source concatenation and construction tasks currently require
additional steps to process valid JSON into valid ECMAScript before embedding
it.

{{{heading(Proposed Solution)}}}

JSON syntax is defined by [[http://www.ecma-international.org/publications/standards/Ecma-404.htm][ECMA-404]] and permanently fixed by [[https://tools.ietf.org/html/rfc7159][RFC 7159]], but the
=DoubleStringCharacter= and =SingleStringCharacter= productions of ECMA-262 can
be extended to allow unescaped =U+2028 LINE SEPARATOR= and =U+2029 PARAGRAPH
SEPARATOR= characters.

** Well-Formed JSON Stringify
A proposal[fn:8] to prevent ~JSON.stringify~ from returning ill-formed Unicode
strings.

Rather than return unpaired surrogate code points as single UTF-16 code units,
represent them with JSON escape sequences.

** Article---All the New ES2019 Tips and Tricks
- by Laurie Barth, August 14. 2019
- https://css-tricks.com/all-the-new-es2019-tips-and-tricks/

*** Object.fromEntries

{{{heading(Object.entries)}}}

#+cindex:@code{Object.entries}
In ES2017, we were introduced to ~Object.entries~.  This was a function that
translated an object into its array representation.  Something like this:

#+begin_src js
let students = {
  amelia: 20,
  beatrice: 22,
  cece: 20,
  deirdre: 19,
  eloise: 21
}

Object.entries(students) 
// [
//  [ 'amelia', 20 ],
//  [ 'beatrice', 22 ],
//  [ 'cece', 20 ],
//  [ 'deirdre', 19 ],
//  [ 'eloise', 21 ]
// ]
#+end_src

{{{heading(Manual Conversion Back to an Object)}}}

This was a wonderful addition because it allowed objects to make use of the
numerous functions built into the ~Array prototype~.  Things like ~map~,
~filter~, ~reduce~, etc.  Unfortunately, it required a somewhat manual process
to turn that result back into an object.

#+begin_src js
let students = {
  amelia: 20,
  beatrice: 22,
  cece: 20,
  deirdre: 19,
  eloise: 21
}

// convert to array in order to make use of .filter() function
let overTwentyOne = Object.entries(students).filter(([name, age]) => {
  return age >= 21
}) // [ [ 'beatrice', 22 ], [ 'eloise', 21 ] ]

// turn multidimensional array back into an object
let DrinkingAgeStudents = {}
for (let [name, age] of overTwentyOne) {
    DrinkingAgeStudents[name] = age;
}
// { beatrice: 22, eloise: 21 }
#+end_src

{{{heading(Object.fromEntries)}}}

#+cindex:@code{Object.fromEntries}
~Object.fromEntries~ is designed to remove that loop!  It gives you much more
concise code that invites you to make use of array prototype methods on
objects.

#+begin_src js
let students = {
  amelia: 20,
  beatrice: 22,
  cece: 20,
  deirdre: 19,
  eloise: 21
}

// convert to array in order to make use of .filter() function
let overTwentyOne = Object.entries(students).filter(([name, age]) => {
  return age >= 21
}) // [ [ 'beatrice', 22 ], [ 'eloise', 21 ] ]

// turn multidimensional array back into an object
let DrinkingAgeStudents = Object.fromEntries(overTwentyOne);
// { beatrice: 22, eloise: 21 }
#+end_src

{{{heading(Caveat About Losing Entries)}}}

It is important to note that arrays and objects are different data structures
for a reason. There are certain cases in which switching between the two will
cause data loss. The example below of array elements that become duplicate
object keys is one of them.

#+begin_src js
let students = [
  [ 'amelia', 22 ], 
  [ 'beatrice', 22 ], 
  [ 'eloise', 21], 
  [ 'beatrice', 20 ]
]

let studentObj = Object.fromEntries(students); 
// { amelia: 22, beatrice: 20, eloise: 21 }
// dropped first beatrice!
#+end_src
*** Array.prototype.flat
#+cindex:multi-dimensional arrays
#+cindex:array, multi-dimensional
#+cindex:flatten multi-dimensional array
#+cindex:@code{flat}
Multi-dimensional arrays are a pretty common data structure to come across,
especially when retrieving data.  The ability to flatten it is necessary.  It
was always possible, but not exactly pretty.

{{{heading(Using map to Obtain a Multi-dimensional Array)}}}

Let’s take the following example where our map leaves us with a
multi-dimensional array that we want to flatten.

#+begin_src js
let courses = [
  {
    subject: "math",
    numberOfStudents: 3,
    waitlistStudents: 2,
    students: ['Janet', 'Martha', 'Bob', ['Phil', 'Candace']]
  },
  {
    subject: "english",
    numberOfStudents: 2,
    students: ['Wilson', 'Taylor']
  },
  {
    subject: "history",
    numberOfStudents: 4,
    students: ['Edith', 'Jacob', 'Peter', 'Betty']
  }
]

let courseStudents = courses.map(course => course.students)
// [
//   [ 'Janet', 'Martha', 'Bob', [ 'Phil', 'Candace' ] ],
//   [ 'Wilson', 'Taylor' ],
//   [ 'Edith', 'Jacob', 'Peter', 'Betty' ]
// ]

[].concat.apply([], courseStudents) // we're stuck doing something like this
#+End_src

{{{heading(Flattening with flat)}}}

In comes ~Array.prototype.flat~.  It takes an optional argument of =depth=.

#+begin_src js
let courseStudents = [
  [ 'Janet', 'Martha', 'Bob', [ 'Phil', 'Candace' ] ],
  [ 'Wilson', 'Taylor' ],
  [ 'Edith', 'Jacob', 'Peter', 'Betty' ]
]

let flattenOneLevel = courseStudents.flat(1)
console.log(flattenOneLevel)
// [
//   'Janet',
//   'Martha',
//   'Bob',
//   [ 'Phil', 'Candace' ],
//   'Wilson',
//   'Taylor',
//   'Edith',
//   'Jacob',
//   'Peter',
//   'Betty'
// ]

let flattenTwoLevels = courseStudents.flat(2)
console.log(flattenTwoLevels)
// [
//   'Janet',   'Martha',
//   'Bob',     'Phil',
//   'Candace', 'Wilson',
//   'Taylor',  'Edith',
//   'Jacob',   'Peter',
//   'Betty'
// ]
#+end_src

Note that if no argument is given, the default depth is one.  The justification
for this decision is that the function is not greedy by default and requires
explicit instructions to operate as such. For an unknown depth with the
intention of fully flattening the array the argument of =Infinity= can be used.

*** Array.prototype.flatMap
With the addition of flat we also got the combined function of
~Array.prototype.flatMap~.  We've actually already seen an example of where
this would be useful above, but let's look at another one.

{{{heading(Manual Flatmapping)}}}

What about a situation where we want to insert elements into an array?  Prior
to the additions of ES2019, what would that look like?

#+begin_src js
let grades = [78, 62, 80, 64]

let curved = grades.map(grade => [grade, grade + 7])
// [ [ 78, 85 ], [ 62, 69 ], [ 80, 87 ], [ 64, 71 ] ]

let flatMapped = [].concat.apply([], curved) // now flatten, could use flat but that didn't exist before either
// [
//  78, 85, 62, 69,
//  80, 87, 64, 71
// ]
#+end_src

{{{heading(Flatmapping with map and flat)}}}

Now that we have ~Array.prototype.flat~ we can improve this example slightly.

#+begin_src js
let grades = [78, 62, 80, 64]

let flatMapped = grades.map(grade => [grade, grade + 7]).flat()
// [
//  78, 85, 62, 69,
//  80, 87, 64, 71
// ]
#+end_src

{{{heading(flatMap)}}}

#+cindex:@code{flatMap}
But still, this is a relatively popular pattern, especially in functional
programming.  So having it built into the ~array prototype~ is great.  With
~flatMap~ we can do this:

#+begin_src js
let grades = [78, 62, 80, 64]

let flatMapped = grades.flatMap(grade => [grade, grade + 7]);
// [
//  78, 85, 62, 69,
//  80, 87, 64, 71
// ]
#+end_src

Now, remember that the default argument for ~Array.prototype.flat~ is one.  And
~flatMap~ is the equivalent of combining ~map~ and ~flat~ with no argument.  So
~flatMap~ will only flatten one level.
*** String.trimStart and String.trimEnd
#+cindex:@code{trimStart}
#+cindex:@code{trimEnd}
#+cindex:@code{trimRight}
#+cindex:@code{trimLeft}
Another nice addition in ES2019 is an alias that makes some string function
names more explicit.  Previously, ~String.trimRight~ and ~String.trimLeft~ were
available.  These are great functions, but it was also beneficial to give them
names that more aligned with their purpose.  Removing starting space and ending
space.

#+begin_src js
let message = "   Welcome to CS 101    "
message.trimEnd()
// '   Welcome to CS 101'
message.trimStart()
// 'Welcome to CS 101   '
message.trimEnd().trimStart()
// 'Welcome to CS 101'
#+end_src

*** Optional Catch Binding
#+cindex:catch binding, optional
Another nice feature in ES2019 is making an argument in =try-catch= blocks
optional.  Previously, all =catch= blocks passed in the exception as a
parameter.  That meant that it was there even when the code inside the =catch=
block ignored it.  This is no longer the case. If the exception is not used in
the =catch= block, then nothing needs to be passed in at all.

#+begin_src js
try {
  let parsed = JSON.parse(obj)
} catch {
  console.log(obj)
}
#+end_src

*** Function.toString() changes
#+cindex:@code{Function.toString()}
ES2019 also brought changes to the way ~Function.toString()~ operates.
Previously, it stripped white space entirely.

#+begin_src js
function greeting() {
  const name = 'CSS Tricks'
  console.log(`hello from ${name}`)
}

greeting.toString()
//'Function greeting() {\nconst name = \'CSS Tricks\'\nconsole.log(`hello from ${name} //`)\n}'
#+end_src

Now it reflects the true representation of the function in source code.

#+begin_src js
function greeting() {
  const name = 'CSS Tricks'
  console.log(`hello from ${name}`)
}

greeting.toString()
// 'function greeting() {\n' +
//  "  const name = 'CSS Tricks'\n" +
//  '  console.log(`hello from ${name}`)\n' +
//  '}'
#+end_src

*** Other Changes
There are also a handful of other additions that you may want to explore. Those
include:

- Symbol description
- Sort stability
- ECMAScript as JSON superset
- JSON.stringify
* ECMAScript 2020
- https://tc39.es/ecma262/

** String.prototype.matchAll
If I have a string, and either a sticky or a global regular expression which
has multiple capturing groups, I often want to iterate through all of the
matches.

~String#matchAll~ would solve this use case by both providing access to all of
the capturing groups, and not visibly mutating the regular expression object in
question.

Performs a regular expression match of the String representing the this value
against regexp and returns an iterator.  Each iteration result’s value is an
Array object containing the results of the match, or =null= if the String did
not match.

** Promise.allSettled
~Promise.allSettled~ returns a promise that is fulfilled with an array of
promise state snapshots, but only after all the original promises have settled,
i.e. become either fulfilled or rejected.

* ECMAScript Proposals
- [[https://github.com/tc39/proposals][tc39/proposals]]

* ECMAScript compatibility table

  - http://kangax.github.io/compat-table/es6/

  Notice the column "Babel + core-js" as this is what can be achieved today
  with transpiling (and that's fully sufficient for practice).

* ECMAScript Variants
** TypeScript

- http://www.typescriptlang.org
- https://github.com/Microsoft/TypeScript

- http://jonathancreamer.com/why-would-you-not-use-typescript/

- https://medium.jonasbandi.net/here-is-why-you-might-not-want-to-use-typescript-part-1-alternatives-ec1248bb6dc
- https://medium.jonasbandi.net/here-is-why-you-might-not-want-to-use-typescript-part-2-typescript-adds-overhead-20b670b9105a
- https://medium.jonasbandi.net/here-is-why-you-might-not-want-to-use-typescript-50ab0d225bdd

- https://medium.jonasbandi.net/hidden-features-of-create-react-app-52db3a17acc0

** PureScript

- http://www.purescript.org
- https://github.com/purescript


#+begin_quote
"A small strongly, statically typed language which compiles to Javascript"
#+end_quote

- https://survivejs.com/blog/purescript-interview/

** TypeScript vs Purescript

- https://blog.logrocket.com/typescript-vs-purescript-not-all-compilers-are-created-equal-c16dadaa7d3e/

- https://www.slant.co/versus/378/389/~typescript_vs_purescript

** Elm

- https://elm-lang.org
- https://github.com/elm


#+begin_quote
"Elm is a domain-specific programming language for declaratively creating web
browser-based graphical user interfaces.  Elm is purely functional, and is
developed with emphasis on usability, performance, and robustness.  It
advertises "no runtime exceptions in practice", made possible by the Elm
compiler's static type checking."
#+end_quote

- Designed By :: Evan Czaplicki
- First Appeared :: 2012
- Influenced By :: Haskell, Standard ML, OCaml, F#

** Reason---Facebook

"Reason lets you write simple, fast and quality type safe code while leveraging
both the JavaScript & OCaml ecosystems."

- https://reasonml.github.io
- https://github.com/facebook/reason


#+begin_quote
"Reason, also known as ReasonML, is a syntax extension and toolchain for OCaml
created by Jordan Walke at Facebook.  Reason offers a syntax familiar to
JavaScript programmers, and transpiles to OCaml.  Statically typed Reason (or
OCaml) code may be compiled to dynamically typed JavaScript using the
BuckleScript compiler."
#+end_quote

- Designed By :: Jordan Walke
- First Appeared :: May 16, 2016
- Influenced By :: OCaml

** Flow

"Flow is a static type checker for JavaScript."

- https://flow.org
- https://github.com/facebook/flow

** Dart---Google---Ecma TC52

"Dart is a client-optimized language for fast apps on any platform."

- https://dart.dev
- https://github.com/dart-lang
- https://www.dartlang.org/guides/language/spec


#+begin_quote
Dart is a client-optimized programming language for fast apps on multiple
platforms.  It is developed by Google and is used to build mobile, desktop,
backend and web applications.

Dart is an object-oriented, class defined, garbage-collected language using a
C-style syntax that transcompiles optionally into JavaScript.  It supports
interfaces, mixins, abstract classes, reified generics, static typing, and a
sound type system.
#+end_quote

- Designed By :: Lars Bak and Kasper Lund
- First Appeared :: October 10, 2011
- Influenced By :: C#, Erlang, JavaScript, Smalltalk, Strongtalk

* ECMAScript Books

  - *[[http://speakingjs.com/es5/index.html][Speaking JavaScript: An In-Depth Guide for Programmers]]* by Dr. Axel
    Rauschmayer March 2014

    This book covers JavaScript up to and including ECMAScript 5.  The book’s
    target audience is programmers who want to learn JavaScript quickly and
    properly, and JavaScript programmers who want to deepen their skills and/or
    look up specific topics.

  - *[[http://exploringjs.com/impatient-js/toc.html][JavaScript for impatient programmers]]* by Dr. Axel Rauschmayer 2019

    This book makes JavaScript less challenging to learn for newcomers, by
    offering a modern view that is as consistent as possible.

    - Test-driven exercises and quizzes available for most chapters.
    - Covers all essential features of JavaScript, up to and including ES2019.
    - Optional advanced sections let you dig deeper.

  - *[[http://exploringjs.com/es6/index.html][Exploring ES6]]* by Dr. Axel Rauschmayer 2018-05-11

    The most comprehensive book on ECMAScript 6 (ECMAScript 2015); a book for
    people who already know JavaScript.

  - *Setting up ES6* by Dr. Axel Rauschmayer 

    This book explains how to set up ES6 projects that are compiled to ES5 via
    Babel 6.  You should already know ES6. It covers the following scenarios:

    - Deploying ES6 in browsers via Babel and webpack.
    - Deploying ES6 in Node.js, by statically or dynamically compiling it via
      Babel.

  - *[[http://exploringjs.com/es2016-es2017/index.html][Exploring ES2016 and ES2017]]* by Dr. Axel Rauschmayer 2018

    Covers what’s new in ECMAScript 2016 and ECMAScript 2017.

  - *[[http://exploringjs.com/es2018-es2019/toc.html][Exploring ES2018 and ES2019]]* by Dr. Axel Rauschmayer 2019

    Covers what’s new in ECMAScript 2018 and ECMAScript 2019.

  - *[[https://github.com/getify/You-Dont-Know-JS][You Don't Know JavaScript]]* by Kyle Simpson 2018

    - [[https://github.com/getify/You-Dont-Know-JS/blob/master/up%2520&%2520going/README.md#you-dont-know-js-up--going][Up and Going]]

    - [[https://github.com/getify/You-Dont-Know-JS/blob/master/scope%2520&%2520closures/README.md#you-dont-know-js-scope--closures][Scope and Closures]]

    - [[https://github.com/getify/You-Dont-Know-JS/blob/master/this%2520&%2520object%2520prototypes/README.md#you-dont-know-js-this--object-prototypes][this and Object Prototypes]]

    - [[https://github.com/getify/You-Dont-Know-JS/blob/master/types%2520&%2520grammar/README.md#you-dont-know-js-types--grammar][Types and Grammar]]

    - [[https://github.com/getify/You-Dont-Know-JS/blob/master/async%2520&%2520performance/README.md#you-dont-know-js-async--performance][Async and Performance]]

    - [[https://github.com/getify/You-Dont-Know-JS/blob/master/es6%2520&%2520beyond/README.md#you-dont-know-js-es6--beyond][ES6 and Beyond]]

* ECMAScript Guide
** Enumeration
#+cindex:ES5
#+cindex:enumerate object properties
#+cindex:iterate object properties
#+cindex:object, enumerate properties
#+cindex:properties, enumerte
#+cindex:object properties, enumerate
Starting with ECMAScript 5, there are three native ways to list/traverse object
properties:

#+cindex:@code{for-in} loop
- =for...in= loops ::

     #+cindex:bracket notation
     This method traverses all /enumerable/ properties of an object and its
     /prototype chain/.  You use the bracket notation with =for...in= to
     iterate over all the enumerable properties of an object.

     The following function displays the properties of the object when you pass
     the object and the object's name as arguments to the function:

     #+caption:Display the properties of an object
     #+name:display-the-properties-of-an-object
     #+begin_src js -n
     function showProps(obj, objName) {
       var result = ``;
       for (var i in obj) {
         // obj.hasOwnProperty() is used to filter out properties from the object's prototype chain
         if (obj.hasOwnProperty(i)) {
           result += `${objName}.${i} = ${obj[i]}\n`;
         }
       }
       return result;
     }
     #+end_src

- ~Object.keys(obj) ::

     This method returns an array with all the own (not in the prototype chain)
     enumerable properties' names ("keys") of an object /obj/.

- ~Object.getOwnPropertyNames(obj) ::

     This method returns an array containing all own properties' names
     (enumerable or not) of an object /obj/.


Before ECMAScript 5, there was no /native/ way to list all properties
(enumerable and not) of an object (own and on the prototype chain).  However,
this can be achieved with the following function:

#+caption:Enumerate All Object Properties in ES3
#+name:enumerate-all-object-properties-in-es3
#+begin_src js -n
function listAllProperties(o) {
	var objectToInspect;
	var result = [];

	for(objectToInspect = o; objectToInspect !== null;
           objectToInspect = Object.getPrototypeOf(objectToInspect)) {
        result = result.concat(
            Object.getOwnPropertyNames(objectToInspect)
        );
    }

	return result;
}
#+end_src

#+cindex:hidden properties
This can be useful to reveal "hidden" properties (properties in the prototype
chain which are not accessible through the object, because another property has
the same name earlier in the prototype chain).  Listing accessible properties
only can easily be done by removing duplicates in the array.
* ECMAScript Parsing
** Esprima
“ECMAScript parsing infrastructure for multipurpose analysis”

Esprima is a high performance, standard-compliant ECMAScript parser written in
ECMAScript (also popularly known as JavaScript).

- https://esprima.org
- https://github.com/jquery/esprima

{{{heading(Features)}}}

- Full support for ECMAScript 2016 ([[http://www.ecma-international.org/publications/standards/Ecma-262.htm][ECMA-262 7th Edition]])

- Sensible syntax tree format, with optional node location info

- Experimental support for JSX, a syntax extension for React

- Heavily tested (~1500 tests with full code coverage)


{{{heading(API)}}}

Esprima can be used to perform lexical analysis (tokenization) or syntactic
analysis (parsing) of a JavaScript program.

Once the full syntax tree is obtained, various static code analysis can be
applied to give an insight to the code: syntax visualization, code validation,
editing autocomplete (with type inferencing) and many others.

Regenerating the code from the syntax tree permits a few different types of
code transformation, from a simple rewriting (with specific formatting) to a
more complicated minification.

Esprima runs on many popular web browsers, as well as other ECMAScript
platforms such as Rhino, Nashorn, and Node.js. It is distributed under the BSD
license.

{{{heading(A simple example on Node.js REPL)}}}

#+begin_example
> var esprima = require('esprima');
> var program = 'const answer = 42';

> esprima.tokenize(program);
[ { type: 'Keyword', value: 'const' },
  { type: 'Identifier', value: 'answer' },
  { type: 'Punctuator', value: '=' },
  { type: 'Numeric', value: '42' } ]

> esprima.parse(program);
{ type: 'Program',
  body:
   [ { type: 'VariableDeclaration',
       declarations: [Object],
       kind: 'const' } ],
  sourceType: 'script' }
#+end_example

*** Esprima Documentation
- https://esprima.org/doc/index.html
** Acorn
“A small, fast, JavaScript-based JavaScript parser”

- https://github.com/acornjs/acorn

** Espree
“An Esprima-compatible JavaScript parser”

- https://github.com/eslint/espree


Espree started out as a fork of Esprima v1.2.2, the last stable published
released of Esprima before work on ECMAScript 6 began.  Espree is now built on
top of [[https://github.com/ternjs/acorn][Acorn]], which has a modular architecture that allows extension of core
functionality.  The goal of Espree is to produce output that is similar to
Esprima with a similar API so that it can be used in place of Esprima.

{{{heading(Espree’s primary goal)}}}

The primary goal is to produce the exact same AST structure and tokens as
Esprima, and that takes precedence over anything else.  (The AST structure
being the [[https://github.com/estree/estree][ESTree]] API with JSX extensions.) Separate from that, Espree may
deviate from what Esprima outputs in terms of where and how comments are
attached, as well as what additional information is available on AST nodes.
That is to say, Espree may add more things to the AST nodes than Esprima does
but the overall AST structure produced will be the same.

Espree may also deviate from Esprima in the interface it exposes.

{{{heading(Why Another Parser?)}}}

ESLint had been relying on Esprima as its parser from the beginning.  While that
was fine when the JavaScript language was evolving slowly, the pace of
development increased dramatically and Esprima had fallen behind.  ESLint, like
many other tools reliant on Esprima, has been stuck in using new JavaScript
language features until Esprima updates, and that caused our users frustration.

We decided the only way for us to move forward was to create our own parser,
bringing us inline with JSHint and JSLint, and allowing us to keep implementing
new features as we need them.  We chose to fork Esprima instead of starting
from scratch in order to move as quickly as possible with a compatible API.

With Espree 2.0.0, we are no longer a fork of Esprima but rather a translation
layer between Acorn and Esprima syntax.  This allows us to put work back into a
community-supported parser (Acorn) that is continuing to grow and evolve while
maintaining an Esprima-compatible parser for those utilities still built on
Esprima.

Acorn is a great JavaScript parser that produces an AST that is compatible with
Esprima.  Unfortunately, ESLint relies on more than just the AST to do its job.
It relies on Esprima's tokens and comment attachment features to get a complete
picture of the source code.  We investigated switching to Acorn, but the
inconsistencies between Esprima and Acorn created too much work for a project
like ESLint.

*** ECMAScript Feature Support

{{{heading(ECMAScript 6)}}}

All of them.

{{{heading(ECMAScript 7/2016)}}}

There is only one ECMAScript 2016 syntax change: the exponentiation
operator. Espree supports this.

{{{heading(ECMAScript 2017)}}}

There are two ECMAScript 2017 syntax changes: async functions, and trailing
commas in function declarations and calls.  Espree supports both of them.

{{{heading(ECMAScript 2018)}}}

There are seven ECMAScript 2018 syntax changes:

- nvalid escape sequences in tagged template literals
- Rest/spread properties
- Async iteration
- RegExp s flag
- RegExp named capture groups
- RegExp lookbehind assertions
- RegExp Unicode property escapes


Espree supports all of them.

{{{heading(ECMAScript 2019)}}}

Because ECMAScript 2019 is still under development, we are implementing
features as they are finalized. Currently, Espree supports:

- Optional catch binding
- JSON superset (\u2028 and \u2029 in string literals)

*** Espree Installation
: npm i espree

*** Espree Usage
#+begin_src js -n
const espree = require("espree");
const ast = espree.parse(code);
#+end_src

There is a second argument to ~parse()~ that allows you to specify various
options:

#+begin_src js -n
  const espree = require("espree");

  // Optional second options argument with the following default settings
  const ast = espree.parse(code, {

      // attach range information to each node
      range: false,

      // attach line/column location information to each node
      loc: false,

      // create a top-level comments array containing all comments
      comment: false,

      // create a top-level tokens array containing all tokens
      tokens: false,

      // Set to 3, 5 (default), 6, 7, 8, 9, or 10 to specify the version of ECMAScript syntax you want to use.
      // You can also set to 2015 (same as 6), 2016 (same as 7), 2017 (same as 8), 2018 (same as 9), 2019 (same as 10), or 2020 (same as 11) to use the year-based naming.
      ecmaVersion: 5,

      // specify which type of script you're parsing ("script" or "module")
      sourceType: "script",

      // specify additional language features
      ecmaFeatures: {

          // enable JSX parsing
          jsx: false,

          // enable return in global scope
          globalReturn: false,

          // enable implied strict mode (if ecmaVersion >= 5)
          impliedStrict: false
      }
  });
#+end_src

** ESTree
- https://github.com/estree/estree
* ECMAScript Static Code Analysis
** JSHint
“A Static Code Analysis Tool for JavaScript”

JSHint is a community-driven tool that detects errors and potential problems in
JavaScript code.  Since JSHint is so flexible, you can easily adjust it in the
environment you expect your code to execute.  JSHint is open source and will
always stay this way.

- https://jshint.com/about/

* Module Systems---CommonJS • AMD •  ES2015
#+cindex:module systems
JavaScript was originally designed to be read from top to bottom in a
simplistic manner by a web browser, and files were loaded using =<script>=
tags.  As larger and larger applications have been written in JavaScript, two
module systems (AMD and CommonJS) have been developed.  Two patterns exist
because the browser and server offer different challenges in terms of
module-loading latency (network requests vs. file system).

{{{heading(Encapsulation and Dependency Management)}}}

#+cindex:namespace
#+cindex:dependency management
#+cindex:encapsulation
As JavaScript development gets more and more common, namespaces and depedencies
get much more difficult to handle.[fn:10]  Different solutions were developed to deal
with this problem in the form of module systems.  Modules were developed around
the concepts of /encapsulation/ and /dependency/.  At the moment that another
piece of software is brought into a project, a /dependency/ is created between
it and the new piece of code.  Since these pieces of software need to work
together, it is of importance that no conflicts arise between them.  Without
some sort of /encapsulation/ it is a matter of time before two modules conflict
with each other.  /Encapsulation/ is essential to prevent conflicts and ease
development.

#+cindex:dependencies
#+cindex:refactoring
Dependencies in traditional client-side JavaScript development are
/implicit/---it is the job of the developer to make sure dependencies are
satisfied at the point any block of code is executed.  Developers also need to
make sure dependencies are satisfied in the right order.  As JavaScript
development gets more and more complex, dependency management can get
cumbersome.  Refactoring is also impaired: where should newer dependencies be
put to maintain proper order of the load chain?

JavaScript module systems attempt to deal with these problems and others.  They
were born out of necessity to accommodate the ever growing JavaScript
landscape.

{{{heading(The Revealing Module Pattern)}}}

#+cindex:the revealing module pattern
In the beginning, before the modern module systems were developed, there was
=The Revealing Module Pattern=.

#+caption:The Revealing Module Pattern
#+name:the-revealing-module-pattern
#+begin_src js
var myRevealingModule = (function () {
    var privateVar = "Ben Cherry",
        publicVar = "Hey there!";

    function privateFunction() {
        console.log( "Name:" + privateVar );
    }

    function publicSetName( strName ) {
        privateVar = strName;
    }

    function publicGetName() {
        privateFunction();
    }

    // Reveal public pointers to
    // private functions and properties
    return {
        setName: publicSetName,
        greeting: publicVar,
        getName: publicGetName
    };
})();

myRevealingModule.setName( "Paul Kinlan" );
#+end_src

See [[https://addyosmani.com/resources/essentialjsdesignpatterns/book/][Addy Osmani's JavaScript Design Patterns book]].

The revealing module pattern relies on functions, or function scoping, to
encapsulate private contents: whatever binding is declared inside a function
cannot escape its scope.  In the example above, public symbols are exposed in
the returned dictionary. All other declarations are protected by the function
scope enclosing them.  This pattern has been in use for quite some time in
JavaScript projects and deals fairly nicely with the encapsulation matter.  It
does not do much about the dependencies issue.  Another limitation lies in the
fact that including other modules cannot be done in the same source.

{{{subheading(Pros)}}}

- Simple enough to be implemented anywhere (no libraries, no language support
  required).

- Multiple modules can be defined in a single file.

{{{subheading(Cons)}}}

- No way to programmatically import modules (except by using eval).

- Dependencies need to be handled manually.

- Asynchronous loading of modules is not possible.

- Circular dependencies can be troublesome.

- Hard to analyze for static code analyzers.


{{{heading(CommonJS)}}}

#+cindex:CommonJS
#+cindex:server-side JavaScript
#+cindex:Node.js
CommonJS is a project that aims to define a series of specifications to help in
the development of server-side JavaScript applications.  One of the areas the
CommonJS team attempts to address are modules.  Node.js developers originally
intended to follow the CommonJS specification but later decided against it.
When it comes to modules, however, Node.js's implementation is very influenced
by the CommonJS specification.

#+caption:CommonJS Modules in Node.js
#+name:commonjs-nodejs
#+begin_src js
// In circle.js
const PI = Math.PI;

exports.area = (r) => PI * r * r;

exports.circumference = (r) => 2 * PI * r;

// In some file
const circle = require('./circle.js');
console.log( `The area of a circle of radius 4 is ${circle.area(4)}`);
#+end_src

{{{subheading(Require and Exports)}}}

In both Node's and CommonJS's modules there are essentially two elements to
interact with the module system: ~require~ and ~exports~.

~require~ is a function that can be used to import symbols from another module
to the current scope.  The parameter passed to ~require~ is the =id= of the
module.  In Node's implementation, it is the name of the module inside the
~node_modules~ directory (or, if it is not inside that directory, the path to
it).

~exports~ is a special object: anything put in it will get exported as a public
element.  Names for fields are preserved.

A peculiar difference between Node and CommonJS arises in the form of the
~module.exports~ object.  In Node, ~module.exports~ is the real special object
that gets exported, while ~exports~ is just a variable that gets bound by
default to ~module.exports~.  CommonJS, on the other hand, has no
~module.exports~ object.  The practical implication is that in Node it is not
possible to export a fully pre-constructed object without going through
~module.exports~:

#+begin_src js
// This won't work, replacing exports entirely breaks the binding to
// modules.exports.
exports =  (width) => {
  return {
    area: () => width * width
  };
}

// This works as expected.
module.exports = (width) => {
  return {
    area: () => width * width
  };
}
#+end_src

#+cindex:server-side development
#+cindex:synchronous API
CommonJS modules were designed with server development in mind.  Naturally, the
API is synchronous.  In other words, modules are loaded at the moment and in
the order they are required inside a source file.

{{{subheading(Pros)}}}

- Simple: a developer can grasp the concept without looking at the docs.

- Dependency management is integrated: modules require other modules and get
  loaded in the needed order.

- require can be called anywhere: modules can be loaded programmatically.

- Circular dependencies are supported.


{{{subheading(Cons)}}}

- Synchronous API makes it not suitable for certain uses (client-side).

- One file per module.

- Browsers require a loader library or transpiling.

- No constructor function for modules (Node supports this though).

- Hard to analyze for static code analyzers.


{{{heading(CommonJS Implementations)}}}

On the server, there is Node.js (partially).

#+cindex:webpack
#+cindex:browserify
For the client there are currently two popular options: webpack and browserify.

/Browserify/ was explicitly developed to parse Node-like module definitions
(many Node packages work out-of-the-box with it!) and bundle your code plus the
code from those modules in a single file that carries all dependencies.

/Webpack/ on the other hand was developed to handle creating complex pipelines
of source transformations before publishing.  This includes bundling together
CommonJS modules.

{{{heading(Asynchronous Module Definition (AMD))}}}

#+cindex:Asynchronous Module Definition (AMD)
#+cindex:AMD, Asynchronous Module Definition
AMD was born out of a group of developers that were displeased with the
direction adopted by CommonJS.  In fact, AMD was split from CommonJS early in
its development.  The main difference between AMD and CommonJS lies in its
support for asynchronous module loading.

#+caption:Example of asynchronous module loading in AMD
#+name:asynchronous-module-loading-in-amd
#+begin_src js
//Calling define with a dependency array and a factory function
define(['dep1', 'dep2'], function (dep1, dep2) {

    //Define the module value by returning a value.
    return function () {};
});

// Or:
define(function (require) {
    var dep1 = require('dep1'),
        dep2 = require('dep2');

    return function () {};
});
#+end_src

#+cindex:closure idiom
Asynchronous loading is made possible by using JavaScript's traditional closure
idiom: a function is called when the requested modules are finished loading.
Module definitions and importing a module is carried by the same function: when
a module is defined its dependencies are made explicit.  An AMD loader can
therefore have a complete picture of the dependency graph for a given project
at runtime.  Libraries that do not depend on each other for loading can thus be
loaded at the same time.  This is particularly important for browsers, where
startup times are essential to a good user experience.

{{{subheading(Pros)}}}

- Asynchronous loading (better startup times).

- Circular dependencies are supported.

- Compatibility for require and exports.

- Dependency management fully integrated.

- Modules can be split in multiple files if necessary.

- Constructor functions are supported.

- Plugin support (custom loading steps).


{{{subheading(Cons)}}}

- Slightly more complex syntactically.

- Loader libraries are required unless transpiled.

- Hard to analyze for static code analyzers.


{{{heading(AMD Implementations)}}}

#+cindex:require.js
#+cindex:Dojo
Currently the most popular implementations of AMD are {{{command(require.js)}}}
and =Dojo=.  Using {{{command(require.js)}}} is pretty straightforward: include
the library in your HTML file and use the =data-main= attribute to tell
{{{command(require.js)}}} which module should be loaded first.  Dojo has a
similar setup.

#+cindex:RequireJS
RequireJS is a JavaScript file and module loader.  It is optimized for
in-browser use, but it can be used in other JavaScript environments, like Rhino
and Node.  Using a modular script loader like RequireJS will improve the speed
and quality of your code.

#+cindex:Asynchronous Module Definition (AMD)
#+cindex:AMD, Asynchronous Module Definition
#+cindex:asynchronous module loading
The Asynchronous Module Definition (AMD) API specifies a mechanism for defining
modules such that the module and its dependencies can be asynchronously loaded.
This is particularly well suited for the browser environment where synchronous
loading of modules incurs performance, usability, debugging, and cross-domain
access problems.

{{{heading(ES2015 Module System)}}}

The ECMA team behind the standardization of JavaScript decided to tackle the
issue of modules.  The result can be seen in the latest release of the
JavaScript standard: ECMAScript 2015 (previously known as ECMAScript 6).  The
result is syntactically pleasing and compatible with both synchronous and
asynchronous modes of operation.

#+caption:ES2015 Module System
#+name:es2015-module-system
#+begin_src js
//------ lib.js ------
export const sqrt = Math.sqrt;
export function square(x) {
    return x * x;
}
export function diag(x, y) {
    return sqrt(square(x) + square(y));
}

//------ main.js ------
import { square, diag } from 'lib';
console.log(square(11)); // 121
console.log(diag(4, 3)); // 5
#+end_src

#+cindex:@code{import} directive
#+cindex:@code{export} directive
The ~import~ directive can be used to bring modules into the namespace.  This
directive, in contrast with ~require~ and ~define~, is not dynamic.  The
~export~ directive, on the other hand, can be used to explicitly make elements
public.  The static nature of the ~import~ and ~export~ directive allows static
analyzers to build a full tree of dependencies without running code.  There is
a now a specification for dynamic loading of modules.

In truth, ES2015 only specifies the /syntax/ for static module loaders.  In
practice, ES2015 implementations are not required to do anything after parsing
these directives.  Module loaders such as ~System.js~ are still required.  This
solution, by virtue of being integrated in the language, lets runtimes pick the
best loading strategy for modules.  In other words, when asynchronous loading
gives benefits, it can be used by the runtime.

{{{subheading(Pros)}}}

- Synchronous and asynchronous loading supported.

- Syntactically simple.

- Support for static analysis tools.

- Integrated in the language (eventually supported everywhere, no need for libraries).

- Circular dependencies supporte.


{{{subheading(Cons)}}}

- Still not supported everywhere.


{{{heading(Implementations)}}}

#+cindex:babel
Unfortunately none of the major JavaScript runtimes support ES2015 modules in
their current stable branches.  Fortunately many transpilers do support modules
and a polyfill is also available.  Currently, the ES2015 preset for Babel can
handle modules with no trouble.

{{{heading(System.js---The all-in-one Solution)}}}

#+cindex:System.js
#+cindex:universal loader
System.js is a universal module loader that supports CommonJS, AMD and ES2015
modules.  It can work in tandem with transpilers such as Babel or Traceur and
can support Node and IE8+ environments.  Using it is a matter of loading
System.js in your code and then pointing it to your base URL:

#+caption:Example of System.js
#+name:system.js-example
#+begin_src html
<script src="system.js"></script>
<script>
  // set our baseURL reference path
  System.config({
    baseURL: '/app',
    // or 'traceur' or 'typescript'
    transpiler: 'babel',
    // or traceurOptions or typescriptOptions
    babelOptions: {

    }
  });

  // loads /app/main.js
  System.import('main.js');
</script>
#+end_src

As System.js does all the job on-the-fly, using ES2015 modules should generally
be left to a transpiler during the build step in production mode.  When not in
production mode, System.js can call the transpiler for you, providing seamless
transition between production and debugging environments.

#+cindex:import statement
#+cindex:export statement
#+cindex:ES2015
Within JavaScript itself, beginning with ES2015, modern browsers have started
to support module functionality natively.  Use of native JavaScript modules is
dependent on the ~import~ and ~export~ statements

** CommonJS (CJS)
#+cindex:CommonJS module system
#+cindex:CJS
#+cindex:Dongaoor, Kevin
#+cindex:ecosystem for JavaScript modules on the server
Kevin Dongaoor created CommonJS in 2009 with the goal to specify an ecosystem
for JavaScript modules on the server.  Node.js follows the CommonJS module
specification.  Following are a few salient points of the module system:

- Each file is its own module.

  #+cindex:module definition
  #+cindex:@code{module} variable
- Each file has access to the current module definition using the ~module~
  variable.

  #+cindex:@code{module.exports} variable
- The export of the current module is determined by the ~module.exports~
  variable.

  #+cindex:@code{require} function
  #+cindex:import a module
  #+cindex:module import
- To import a module, use the globally available ~require~ function.

*** Wiring Modules

#+cindex:modules, wiring
One of its biggest advantages is the ability to link these modules together
using the ~require()~ function.  However, many developers new to Node.js might
find this confusing; one of the most frequently asked questions is in fact:
/what's the best way to pass an instance of component X into module Y?/

It should not be surprising that the art of module wiring is one of the most
controversial and opinionated topics in Node.js.  There are many schools of
thought influencing this area, but none of them can be considered to possess
the undisputed truth.  Every approach, in fact, has its pros and cons and they
often end up mixed together in the same application, adapted, customized, or
used in disguise under other names.

#+cindex:CommonJS module system
Node.js provides a great tool for organizing and wiring the components of an
application together: it's the CommonJS module system.  However, the module
system alone is not a guarantee of success; if on the one hand, it adds a
convenient level of indirection between the client module and the dependency,
then on the other, it might introduce a tighter coupling if not used properly.
In this section, we will discuss some fundamental aspects of dependency wiring
in Node.js.

** Asynchronous Module Definition (AMD)
#+cindex:Asynchronous Module Definition (AMD)
#+cindex:AMD
Node.js follows the CommonJS module specification.  This module system is great
for the server environment when we have immediate access to the file system.
Loading a module from the file system in Node.js is a blocking call for the
first time.

However, if the same module system is used in the browser, each ~require~
statement would need to trigger an HTTP request to the server.  This is an
order of magnitude slower and less reliable than a file system access call.
Loading a large number of modules can quickly degrade the user experience in
the browser.  The solution is async, in-parallel, and upfront loading of
modules.

To support this async loading, we need a way to declare that this file will
depend upon ~./foo~ and ~./bar~ upfront and continue code execution using a
callback.  There is already a specification for exactly this called /async
module definition (AMD)/.

#+caption[Asynchronous Module Definition (AMD)]:code snippet to show loading two modules using AMD
#+name: async-module-definition-example
#+begin_src js -n
define(['./foo', './bar'], function(foo, bar){
        // continue code here
});
#+end_src

#+cindex:@code{define} function
#+cindex:RequireJS library
The ~define~ function is not native to the browser.  These must be provided by
a third-party library.  The most popular of these for the browser is [[https://requirejs.org][RequireJS]].
The different nature of the ~require~ call is what makes reusing Node.js code
in the browser slightly more involved.

#+begin_quote
{{{heading(RequireJS)}}}

RequireJS is a JavaScript file and module loader. It is optimized for
in-browser use, but it can be used in other JavaScript environments, like Rhino
and Node. Using a modular script loader like RequireJS will improve the speed
and quality of your code.
#+end_quote

#+cindex:export from AMD module
To export something from a module, you can simply return it from the ~define~
callback.

#+caption[Export from AMD]:export from an AMD module
#+name:amd-export
#+begin_src define([], function () {
    var foo = function () {
        console.log('foo was called');
    };
    return foo; // function foo is exported
});
#+end_src

The root of the file contains a call to ~define~.  To load modules ~./foo~ and
~./bar~ in ~app.js~ in the same folder, the ~define~ call will be as shown:

#+caption:App.js Root define
#+name:root-define
#+begin_src js -n
define(['./foo', './bar'], function (foo, bar) {
        // use foo and bar here
});
#+end_src

~define~ can take a special argument called ~exports~, which behaves similar to
the ~exports~ variable in Node.js.  Let’s create the module ~bar.js~ using this
syntax, as shown:

#+caption:Bar.js exports
#+name:AMD-exports
#+begin_src js -n
define(['exports'], function (exports) {
    var bar = exports.log = function () {
        console.log('bar.log was called');
    };
});
#+end_src

Note that you can only use ~exports~ to attach variables you want to export
(for example, ~exports.log =~ =/*something*/=), but you cannot assign it to
something else (~exports =~ =/*something*/=) as that would break the reference
to the ~exports~ variable monitored by RequireJS.  This is conceptually quite
similar to the exports variable in Node.js.

Let’s complete ~app.js~ and consume both of these modules, as shown:

#+caption: App.js consuming foo.js and bar.js
#+name:app.js-foo.js-bar.js
#+begin_src js -n
define(['./foo', './bar'], function (foo, bar) {
    foo();
    bar.log();
});
#+end_src

The real benefit of using this alternate (AMD) syntax for modules becomes
evident when we look at the network tab within the chrome debug tools.
~foo.js~ and ~bar.js~ were downloaded in parallel as soon as ~app.js~ was
downloaded, and RequireJS found that ~app.js~ needs ~foo.js~ and ~bar.js~ to
function because of the call to ~define~.

*** Facts about AMD

- Modules are cached.  This is similar to how modules are cached in
  Node.js---that is, the same object is returned every time.

- Many of these arguments to ~define~ are optional and there are various ways
  to configure how modules are scanned in RequireJS.

  #+cindex:@code{require}, AMD function
- You can still do conditional loading of specific modules using a ~require~
  call, which is another function provided by RequireJS.  This function is also
  async and is different from the Node.js version of ~require~.

#+caption[AMD ~require~ function]:how you can conditionally load a module in AMD
#+name:AMD-require
#+begin_src js -n
define(['./foo', './bar'], function(foo, bar){
        if(iReallyNeedThisModule){
                require(['./bas'], function(bas){
                        // continue code here.
                }); 
        }
});
#+end_src

** ES2015 Import and Export Statements
#+cindex:ES2015
The definition of /imports/ was first standardized in ES2015.

*** Export Statement
#+cindex:@code{export} statement
#+cindex:JasvaScript modules
#+cindex:strict mode, modules exported
The ~export~ statement is used when creating JavaScript modules to export
functions, objects, or primitive values from the module so they can be used by
other programs with the ~import~ statement.  Exported modules are in =strict=
mode whether you declare them as such or not.  The ~export~ statement cannot be
used in embedded scripts.

{{{heading(Export Types)}}}

There are two different types of export, named and default.  You can have
multiple named exports per module but only one default export.

There is also a hybrid export.

#+cindex:named export
#+cindex:export, named
1. Named Exports (Zero or more exports per module), the names of which may be
   renamed.  During the import, it is mandatory to use the same name of the
   corresponding object.

   #+caption:Named Exports
   #+name:named-exports
   #+begin_src js
   // Exporting individual (named) features
   export let name1, name2, …, nameN; // also var, const
   export let name1 = …, name2 = …, …, nameN; // also var, const
   export function functionName(){...}
   export class ClassName {...}
   /* Can export:
      - var, let, const
      - function
      - class
   */

   // Export list of expressions declared earlier
   export { name1, name2, …, nameN };

   // Renaming exports
   export { variable1 as name1, variable2 as name2, …, nameN };

   // Exporting destructured assignments with renaming
   export const { name1, name2: bar } = o;
   #+end_src

   #+cindex:default export
   #+cindex:export, default
2. Default Exports (One per module); a default export can be imported with any
   name

   #+caption:Default Exports
   #+name:default-exports
   #+begin_src js
   // Default export of a feature or previously declared expression
   export default expression;
   export default function (…) { … } // also class, function*
   export default function name1(…) { … } // also class, function*
   export { name1 as default, … }; // previously declared
   #+end_src

   #+cindex:hybrid export
   #+cindex:export, hybrid
3. Hybrid Exports; submodules can be aggregated and exported from a parent
   module;

   #+caption:Hybrid Exports
   #+name:hybrid-exports
   #+begin_src js
   // Aggregating modules
   export * from …;
   export { name1, name2, …, nameN } from …;
   export { import1 as name1, import2 as name2, …, nameN } from …;
   export { default } from …;
   #+end_src

   #+caption:Parent Module Example
   #+name:parent-module-example
   #+begin_src js
   // In parentModule.js
   export { myFunction, myVariable } from 'childModule1.js';
   export { myClass } from 'childModule2.js';

   // In top-level module
   import { myFunction, myVariable, myClass } from 'parentModule.js'
   #+end_src

*** Import Statement
#+cindex:@code{import} static statement
#+cindex:strict mode
#+cindex:@code{type="module"}
#+cindex:script, import
#+cindex:static import
The static ~import~ statement is used to import bindings which are exported by
another module.  Imported modules are in =strict mode whether you declare them
as such or not.  The ~import~ statement cannot be used in embedded scripts
unless such script has a =type="module"=.

#+cindex:@code{import()} dynamic function
There is also a function-like dynamic ~import()~, which does not require
scripts of =type="module"=.[fn:11]

#+cindex:dynamic import
#+cindex:static import
#+cindex:tree shaking
/Dynamic import/ is useful in situations where you wish to load a module
conditionally, or on demand.  The /static form/ is preferable for loading
initial dependencies, and can benefit more readily from static analysis tools
and tree shaking.

{{{heading(Import Syntax Forms)}}}

#+begin_src js
import defaultExport from "module-name";
import * as name from "module-name";
import { export1 } from "module-name";
import { export1 as alias1 } from "module-name";
import { export1 , export2 } from "module-name";
import { foo , bar } from "module-name/path/to/specific/un-exported/file";
import { export1 , export2 as alias2 , [...] } from "module-name";

/* The following two examples create namespace or named imports from a
 ,* default export */
import defaultExport, { export1 [ , [...] ] } from "module-name";
import defaultExport, * as name from "module-name";

import "module-name"; /* Import an entire module for side effects
                       ,* only, without importing anything. This runs
                       ,* the module's global code, but doesn't
                       ,* actually import any values. */

/* The import keyword may be called as a function to dynamically
 ,* import a module.  When used this way, it returns a promise. */
var promise = import("module-name");

import('/modules/my-module.js')
  .then((module) => {
    // Do something with the module.
  });

let module = await import('/modules/my-module.js');
#+end_src

#+attr_texinfo: :indic code
- module-name :: The module to import from.  This is often a relative or
                 absolute path name to the ~.js~ file containing the module.
                 Certain bundlers may permit or require the use of the
                 extension; check your environment.  Only single quoted and
                 double quoted Strings are allowed.

- name :: Name of the module object that will be used as a kind of namespace
          when referring to the imports.  The =name= parameter is the name of
          the "module object" which will be used as a kind of namespace to
          refer to the exports.  The export parameters specify individual named
          exports, while the ~import * as name~ syntax imports all of them.

- exportN :: Name of the exports to be imported.

- aliasN :: Names that will refer to the named imports.


{{{heading(Examples)}}}

{{{subheading(Standard Static Import)}}}

#+cindex:import, static
#+cindex:static import
The code below shows how to import from a secondary module to assist in
processing an AJAX JSON request.

#+caption:A Standard Module in ~file.js~
#+name:example-static-import-file.js
#+begin_src js
function getJSON(url, callback) {
  let xhr = new XMLHttpRequest();
  xhr.onload = function () { 
    callback(this.responseText) 
  };
  xhr.open('GET', url, true);
  xhr.send();
}

export function getUsefulContents(url, callback) {
  getJSON(url, data => callback(JSON.parse(data)));
}
#+end_src

#+caption:The Main Program in ~main.js~
#+name:example-static-import-main.js
#+begin_src js
import { getUsefulContents } from '/modules/file.js';

getUsefulContents('http://www.example.com',
    data => { doSomethingUseful(data); });
#+end_src

{{{subheading(Dynamic Import)}}}

This example shows how to load functionality on to a page based on a user
action, in this case a =button click, and then call a function within that
module.  This is not the only way to implement this functionality.  The
~import()~ function also supports ~await~.

#+cindex:import, dynamic
#+cindex:dynamic import
#+caption:Example Dynamic Import based upon user action
#+name:example-dynamic-import-main.js
#+begin_src js
const main = document.querySelector("main");
for (const link of document.querySelectorAll("nav > a")) {
  link.addEventListener("click", e => {
    e.preventDefault();

    import('/modules/my-module.js')
      .then(module => {
        module.loadPageInto(main);
      })
      .catch(err => {
        main.textContent = err.message;
      });
  });
}
#+end_src

* JavaScript---The Definitive Guide
:PROPERTIES:
:author:   David Flanagan
:published: 2011
:publisher: O'Reilly Media
:END:
- http://shop.oreilly.com/product/9780596805531.do
- [[https://resources.oreilly.com/examples/9780596805531/][Example Code]]
- [[https://www.oreilly.com/catalog/errata.csp?isbn=9780596805531][Errata]]

Since 1996, /JavaScript: The Definitive Guide/ has been the bible for
JavaScript programmers---a programmer's guide and comprehensive reference to the
core language and to the client-side JavaScript APIs defined by web browsers.

The 6th edition covers HTML5 and ECMAScript 5.  Many chapters have been
completely rewritten to bring them in line with today's best web development
practices.  New chapters in this edition document jQuery and server side
JavaScript.  It's recommended for experienced programmers who want to learn the
programming language of the Web, and for current JavaScript programmers who
want to master it.

This book covers the JavaScript language and the JavaScript APIs implemented by
web browsers.  It was written for programmers who already use JavaScript but
want to take their understanding to a new level and really master the language
and the web platform.  The goal with this book is to document the JavaScript
language and platform comprehensively and definitively.  It will reward careful
study, and that the time you spend reading it will be easily recouped in the
form of higher programming productivity.

{{{heading(How This Book Is Organized)}}}
This book is divided into four parts.

- Part I covers the JavaScript language itself.
- Part II covers client-side JavaScript: the JavaScript APIs defined by HTML5
  and related standards and implemented by web browsers.
- Part III is the reference section for the core language,
- Part IV is the reference for client-side JavaScript.


{{{subheading(The Sixth Edition)}}}
This sixth edition of the book covers both:

- ECMAScript 5 (the latest version of the core language) and
- HTML5 (the latest version of the web platform)

** Introduction to JavaScript
:PROPERTIES:
:chapter:  One
:END:
JavaScript is part of the triad of technologies that all Web developers must
learn:

- HTML to specify the /content/ of web pages
- CSS to specify the /presentation/ of web pages, and
- JavaScript to specify the /behavior/ of web pages.


JavaScript is:

- a high-level,
- dynamic,
- untyped
- interpreted
- programming language

that is well-suited to:

- /object-oriented/ and
- /functional/

programming styles.  JavaScript derives:

- its /syntax/ from *Java*,
- its /first-class functions/ from *Scheme*, and
- its /prototype-based inheritance/ from *Self*.


JavaScript has long since outgrown its scripting-language roots to become a
robust and efficient general-purpose language.  The latest version of the
language defines new features for serious large-scale software development.

*** Some History of JavaScript the Name
JavaScript is completely different from the Java programming language.  “Java-
Script” is a trademark licensed from Sun Microsystems (now Oracle) used to
describe Netscape’s (now Mozilla’s) implementation of the language.

Netscape submitted the language for standardization to ECMA---the European
Computer Manufacturer’s Association---and because of trademark issues, the
standardized version of the language was stuck with the awkward name
“ECMAScript.”  Microsoft’s version of the language is formally known as
“JScript.”  This book uses the name “ECMAScript” only to refer to the language
standard.

*** About Versions
#+cindex:version 3
#+cindex:ECMAScript 3
#+cindex:ES3
For the last decade[fn:12], all web browsers have implemented version 3 of the
ECMAScript standard and there has really been no need to think about version
numbers: the language standard was stable and browser implementations of the
language were, for the most part, interoperable.

#+cindex:version 5
#+cindex:ECMAScript 5
#+cindex:ES5
Recently, an important new version of the language has been defined as
ECMAScript version 5 and, at the time of this writing, browsers are beginning
to implement it.  This book covers all the new features of ECMAScript 5 as well
as all the long-standing features of ECMAScript 3.  You’ll sometimes see these
language versions abbreviated as ES3 and ES5, just as you’ll sometimes see the
name JavaScript abbreviated as JS.

#+cindex:version 4
#+cindex:ECMAScript 4
#+cindex:versino 1.5
#+cindex:V8
The only version numbers that are relevant are ECMAScript versions 3 or 5.
Version 4 was never released.  Sometimes, however, you’ll also see a JavaScript
version number, such as JavaScript 1.5 or JavaScript 1.8.  These are Mozilla’s
version numbers: version 1.5 is basically ECMAScript 3, and later versions
include nonstandard language extensions.  there are also version numbers
attached to particular JavaScript interpreters or “engines.” Google calls its
JavaScript interpreter V8, for example, and at the time of this writing the
current version of the V8 engine is 3.0.

*** About JavaScript's Minimal Standard Library
#+cindex:standard library
#+cindex:input output functionality
#+cindex:host environment
To be useful, every language must have a platform or /standard library/ or API
of functions for performing things like basic input and output.  The core
JavaScript language defines a minimal API for working with /text/, /arrays/,
/dates/, and /regular expressions/ but does not include any /input/ or /output/
functionality.  Input and output (as well as more sophisticated features, such
as /networking/, /storage/, and /graphics/) are the responsibility of the “host
environment” within which JavaScript is embedded.  Usually that host
environment is a web browser, but it can be something else.

*** What This Book Covers
#+cindex:coverage, book
#+cindex:book coverage
This book covers low-level fundamentals first, and then builds on those to more
advanced and higher-level abstractions.

- [[*Core JavaScript][Part I]] of this book covers the language itself and its minimal built-in API.
- [[*Client-Side JavaScript][Part II]] explains how JavaScript is used in web browsers and covers the
  sprawling browser-based APIs loosely known as “client-side JavaScript.”
- [[*Core API Reference][Part III]] is the reference section for the core API.
- [[*Client-Side JavaScript Reference][Part IV]] is the reference section for client-side JavaScript.

#+cindex:Chapter 1
Chapter 1 makes a quick first pass through the core language and the
client-side API, introducing key features that will make it easier to
understand the in-depth treatment in the chapters that follow.

*** An Overview of Core JavaScript
#+cindex:Chapter 2 Lexical Structure
[[*Lexical Structure][Chapter 2, Lexical Structure]], explains things like JavaScript comments,
semicolons, and the Unicode character set.

#+cindex:Chapter 3 Types Values Variables
[[*Types Values and Variables][Chapter 3, Types, Values, and Variables]], explains JavaScript variables and the
values you can assign to those variables.

#+cindex:Chapter 4 Expressions Operators
[[*Expressions and Operators][Chapter 4, Expressions and Operators]] discusses expressions and operators.

- Expression :: a phrase of JavaScript that can be evaluated to produce a
                value.  An expression is something that computes a value but
                doesn’t do anything: it doesn’t alter the program state in any
                way.

  - Operators: produce values


#+cindex:Chapter 5 Statements
[[*Statements][Chapter 5, Statements]]

- Statement :: Statements, on the other hand, don’t have a value (or don’t have
               a value that we care about), but they do alter the state.

  - Variable declarations: create variables

  - Assignment statements: assign values to variables

  - Control structures (conditionals and loops)


#+cindex:Chapter 6 Objects
[[*Objects][Chapter 6, Objects]]

#+cindex:Chapter 7 Arrays
[[*Arrays][Chapter 7, Arrays]]

#+cindex:Chapter 8 Functions
[[*Functions][Chapter 8, Functions]]

- Methods :: When we combine functions with objects, we get methods


#+cindex:Chapter 9 Classes Modules
[[*Classes and Modules][Chapter 9, Classes and Modules]] covers object-oriented programming in JavaScript
in detail, with lots of examples

#+cindex:Chapter 10 Pattern Matching Regular Expressions
[[*JavaScript Subsets and Extensions][Chapter 10, Pattern Matching with Regular Expressions]] explains the regular
expression grammar and demonstrates how to use these “regexps” for textual
pattern matching.

#+cindex:Chapter 11 Subsets Extensions
[[*JavaScript Subsets and Extensions][Chapter 11, JavaScript Subsets and Extensions]] covers subsets and extensions of
core JavaScript

#+cindex:Chapter 12 Server-Side
[[*Server-Side JavaScript][Chapter 12, Server-Side JavaScript]] introduces two ways to use JavaScript
outside of web browsers.

#+cindex:Part Two Client-Side
[[*Client-Side JavaScript][Part Two, Client-Side JavaScript]] is a quick sketch of basic client-side
programming techniques, followed by an in-depth example.

#+cindex:Chapter 13 JS in Web Browsers
[[*JavaScript in Web Browsers][Chapter 13, JavaScript in Web Browsers]] explains in detail how to put JavaScript
to work in web browsers.

#+cindex:Chapter 14 Window Object
[[*The Window Object][Chapter 14, The Window Object]] explains techniques for scripting the web browser
and covers some important global functions of client-side JavaScript.

#+cindex:Chapter 15 Scripting Documents
[[*Scripting Documents][Chapter 15, Scripting Documents]] shows you how to select particular HTML
elements from within a document, how to set HTML attributes of those elements,
how to alter the content of those elements, and how to add new elements to the
document; i.e., it shows how JavaScript can script the HTML elements that
define web content.

#+cindex:Chapter 16 Scripting CSS
[[*Scripting CSS][Chapter 16, Scripting CSS]] shows how you can use JavaScript with the CSS styles
that define the presentation of that content.

#+cindex:Chapter 17 Events
[[*Handling Events][Chapter 17, Handling Events]] explains how you can define and register event
handlers and how the browser invokes them when events occur.

Chapters 15, 16, and 17 explain how you can use JavaScript to script the
content (HTML), presentation (CSS), and behavior (event handling) of web pages.
The APIs described in those chapters are somewhat complex and, until recently,
riddled with browser incompatibilities.  For these reasons, many or most
client-side JavaScript programmers choose to use a client-side library or
framework to simplify their basic programming tasks.  The most popular such
library is *jQuery*.

#+cindex:Chapter 19 jQuery Library
[[*The jQuery Library][Chapter 19, The jQuery Library]], discusses jQuery, which defines a clever and
easy-to-use API for scripting document content, presentation, and behavior.

The four chapters of Part II described so far have all really been about web
pages.  Four more chapters shift gears to focus on web applications.  These
chapters are not about using web browsers to display documents with scriptable
content, presentation, and behavior.  Instead, they’re about using web browsers
as application platforms, and they describe the APIs that modern browsers
provide to support sophisticated client-side web apps.

#+cindex:Chapter 18 Scripted HTTP
[[*Scripted HTTP][Chapter 18, Scripted HTTP]] explains how to make scripted HTTP requests with
JavaScript—a kind of networking API.

#+cindex:Chapter 20 Storage Client-Side
[[*Client-Side Storage][Chapter 20, Client-Side Storage]] describes mechanisms for storing data---and
even entire applications---on the client side for use in future browsing
sessions.

#+cindex:Chapter 21 Scripted Media Graphics
[[*Scripted Media and Graphics][Chapter 21, Scripted Media and Graphics]] covers a client-side API for drawing
arbitrary graphics in an HTML =<canvas>= tag.

#+cindex:Chapter 22 HTML5 APIs
[[*HTML5 APIs][Chapter 22, HTML5 APIs]] covers an assortment of new web app APIs specified by or
affiliated with HTML5.  Networking, storage, graphics: these are OS-type
services being provided by the web browser, defining a new cross-platform
application environment.

*** An Extended Example --- LoanCalc
- [[file:LoanCalc.org][LoanCalc]]

This chapter ends with an extended example that puts many of these techniques
together and shows what real-world client-side JavaScript (plus HTML and CSS)
programs look like.

[[file:figs/loancalc-50.png]]

** Core JavaScript
#+cindex:reference, language
#+cindex:language reference
This part of the book, Chapters 2 though 12, documents the core JavaScript
language and is meant to be a JavaScript language reference.

*** Lexical Structure
#+cindex:Chapter 2 Lexical Structure
#+cindex:lexical structure, def
#+cindex:syntax
The /lexical structure/ of a programming language is the set of elementary
rules that specifies how you write programs in that language.  It is the
lowest-level syntax of a language; it specifies such things as what variable
names look like, the delimiter characters for comments, and how one program
statement is separated from the next.

This short chapter documents the lexical structure of JavaScript.

**** Character Set
#+cindex:character set
#+cindex:Unicode
JavaScript programs are written using the Unicode character set.  ECMAScript 3
requires JavaScript implementations to support Unicode version 2.1 or later.
ECMAScript 5 requires implementations to support Unicode 3 or later.

See [[characters-codepoints-strings][Characters---Codepoints---and Strings]] for more about Unicode and
JavaScript.

***** Case Sensitivity
#+cindex:identifiers
#+cindex:case sensitive
JavaScript is a case-sensitive language.  This means that language keywords,
variables, function names, and other {{{dfn(identifiers)}}} must always be
typed with a consistent capitalization of letters.

#+cindex:HTML
#+cindex:XHTML
Note, however, that HTML is not case-sensitive (although XHTML is).  Because of
its close association with client-side JavaScript, this difference can be
confusing.  Many client-side JavaScript objects and properties have the same
names as the HTML tags and attributes they represent.  While these tags and
attribute names can be typed in any case in HTML, in JavaScript they typically
must be all lowercase.

For example, the HTML ~onclick~ event handler attribute is sometimes specified
as ~onClick~ in HTML, but it must be specified as ~onclick~ in JavaScript code
(or in XHTML documents).

***** Whitespace---Line Breaks---and Format Control Characters
JavaScript ignores spaces that appear between tokens in programs.  For the most
part, JavaScript also ignores line breaks (but see [[*Optional Semicolons---Required Semicolons][Optional Semicolons]] for an
exception).

{{{heading(Whitespace)}}}

#+cindex:whitespace characters
In addition to the regular space character (\u0020), JavaScript also recognizes
the following characters as whitespace:

#+cindex:space
- space :: \u0020
  #+cindex:tab
- tab :: \u0009
  #+cindex:vertical tab
- vertical tab :: \u000B
  #+cindex:form feed
- form feed :: \u000C
  #+cindex:nonbreaking space
- nonbreaking space :: \u00A0
  #+cindex:byte order mark
- byte order mark :: \uFEFF
  #+cindex:Unicode category Z
- Unicode category :: Zs


{{{heading(Line Delimiters)}}}

#+cindex:line delimiters
JavaScript recognizes the following characters as line terminators:

  #+cindex:line feed
- line feed :: \u000A
  #+cindex:carriage return
- carriage return :: \u000D
  #+cindex:line separator
- line separator :: \u2028
  #+cindex:paragraph separator
- paragraph separator :: \u2029
  #+cindex:carriage return---line feed
- carriage return --- line feed :: treated as a single line terminator


{{{heading(Unicode format control characters)}}}

#+cindex:Unicode format control characters
#+cindex:format control characters
Unicode format control characters (category Cf), such as =RIGHT-TO-LEFT MARK=
(\u200F) and =LEFT-TO-RIGHT MARK= (\u200E), control the visual presentation of
the text they occur in.  They are important for the proper display of some
non-English languages and are allowed in JavaScript comments, string literals,
and regular expression literals, but not in the identifiers (e.g., variable
names) of a JavaScript program.

{{{heading(Zero Width Joiners)}}}

As a special case, =ZERO WIDTH JOINER= (\u200D) and =ZERO WIDTH NON-JOINER=
(\u200C) are allowed in identifiers, but not as the first character.  As noted
above, the byte order mark format control character (\uFEFF) is treated as a
space character.

***** Unicode Escape Sequences
#+cindex:Unicode characters
#+cindex:Unicode codepoint
Some computer hardware and software can not display or input the full set of
Unicode characters. To support programmers using this older technology,
JavaScript defines special sequences of six ASCII characters to represent any
16-bit Unicode codepoint.

#+cindex:Unicode escape sequences
These Unicode escapes begin with the characters =\u= and are followed by
exactly four hexadecimal digits (using uppercase or lowercase letters =A–F=).

Unicode escapes may appear in
- JavaScript string literals,
- regular expression literals, and in
- identifiers (but not in language keywords)


The Unicode escape for the character =é=, for example, is \u00E9, and the
following two JavaScript strings are identical:

: "café" === "caf\u00e9" // => true

**** Comments
#+cindex:comments

**** Literals
#+cindex:literals

**** Identifiers and Reserved Words
#+cindex:identifiers
#+cindex:reserved words

**** Optional Semicolons---Required Semicolons
#+cindex:semicolons
JavaScript uses the semicolon (=;=) to separate statements from each other.  In
JavaScript, you can usually omit the semicolon between two statements if those
statements are written on separate lines.  (You can also omit a semicolon at
the end of a program or if the next token in the program is a closing curly
brace =}=.)

Many JavaScript programmers (and the code in this book) use semicolons to
explicitly mark the ends of statements, even where they are not required.

Another style is to omit semicolons whenever possible, using them only in the
few situations that require them.

Whichever style you choose, there are a few details you should understand about
optional semicolons in JavaScript.

#+cindex:line break, as semicolon
Note that JavaScript does not treat every line break as a semicolon: it usually
treats line breaks as semicolons only if it can’t parse the code without the
semicolons.  More formally (and with two exceptions described below),
JavaScript treats a line break as a semicolon if the next nonspace character
cannot be interpreted as a continuation of the current statement.

These statement termination rules lead to some surprising cases.  This code
looks like two separate statements separated with a newline:

#+begin_src js -n
var y = x + f
(a+b).toString()
#+end_src

But the parentheses on the second line of code can be interpreted as a function
invocation of ~f~ from the first line, and JavaScript interprets the code like
this:

: var y = x + f(a+b).toString();

#+cindex:explicit semicolon required
#+cindex:semicolon, required explicit
More likely than not, this is not the interpretation intended by the author of
the code.  In order to work as two separate statements, an explicit semicolon
is required in this case.

In general, if a statement begins with:

: ( [ / + -

{{{noindent}}}there is a chance that it could be interpreted as a continuation
of the statement before.  Statements beginning with =/ + -= are quite rare in
practice, but statements beginning with =( [= are not uncommon at all, at least
in some styles of JavaScript programming.

Some programmers like to put a defensive semicolon at the beginning of any such
statement so that it will continue to work correctly even if the statement
before it is modified and a previously terminating semicolon removed:

#+begin_src js -n
var x = 0 			  // semicolon omitted here
;[x,x+1,x+2].forEach(console.log) // defensive ; keeps this statement separate
#+end_src

{{{heading(Exceptions to General Rule of Line Breaks)}}}

There are two exceptions to the general rule that JavaScript interprets line
breaks as semicolons when it cannot parse the second line as a continuation of
the statement on the first line.

1. The first exception involves the ~return~, ~break~, and ~continue~
   statements.  These statements often stand alone, but they are sometimes
   followed by an identifier or expression.  If a line break appears after any
   of these words (before any other tokens), JavaScript will *always* interpret
   that line break as a semicolon.

   #+begin_src js -n
   return
   true;
   #+end_src

   {{{noindent}}}JavaScript assumes you meant:

   : return; true;

   {{{noindent}}}However, you probably meant:

   : return true;

   What this means is that you must not insert a line break between ~return~,
   ~break~ or ~continue~ and the expression that follows the keyword.  If you
   do insert a line break, your code is likely to fail in a nonobvious way that
   is difficult to debug.

2. The second exception involves the ~++~ and ~−−~ operators.  These operators
   can be prefix operators that appear before an expression or postfix
   operators that appear after an expression.  /If you want to use either of
   these operators as postfix operators, they must appear on the same line as
   the expression they apply to/.  Otherwise, the line break will be treated as
   a semicolon, and the ~++~ or ~--~ will be parsed as a prefix operator
   applied to the code that follows.

   #+begin_src js -n
   x
   ++
   y
   #+end_src

   {{{noindent}}}is parsed as:

   : x; ++y;

   {{{noindent}}}not as:

   : x++; y;

*** Types Values and Variables
#+cindex:Chapter 3 Types Values Variables
#+cindex:types, def
#+cindex:values, def
Computer programs work by manipulating values.  The kinds of values that can be
represented and manipulated in a programming language are known as /types/, and
one of the most fundamental characteristics of a programming language is the
set of types it supports.

#+cindex:variable, def
When a program needs to retain a value for future use, it assigns the value to
(or “stores” the value in) a variable.  A /variable/ defines a symbolic name
for a value and allows the value to be referred to by name.

The way that variables work is another fundamental characteristic of any
programming language.  This chapter explains types, values, and variables in
JavaScript.

{{{heading(JavaScript Types Categories)}}}

#+cindex:primitive types
#+cindex:object types
#+cindex:types, categories
JavaScript types can be divided into two categories:

#+cindex:numbers, primitive
#+cindex:strings, primitive
#+cindex:booleans, primitive
#+cindex:null, primitive
#+cindex:undefined, primitive
- primitive types :: JavaScript’s primitive types include /numbers/, strings of
     text (known as /strings/), and Boolean truth values (known as /booleans/).
     The special JavaScript values /null/ and /undefined/ are primitive values,
     but they are not numbers, strings, or booleans.  Each value is typically
     considered to be the sole member of its own special type.

#+cindex:object types
#+cindex:type object
#+cindex:properties, def
- object types :: Any JavaScript value that is not a number, a string, a
                  boolean, or null or undefined is an /object/.  An /object/
                  (that is, a member of the type =object=) is a collection of
                  /properties/ where each property has a name and a value (either
                  a primitive value, such as a number or string, or an object).


{{{heading(About Object Types)}}}

#+cindex:object, ordinary
- An ordinary JavaScript object is an unordered collection of named values.

  #+cindex:object array
  #+cindex:array object
  #+cindex:ordered collection of values, array
- The language also defines a special kind of object, known as an /array/, that
  represents an ordered collection of numbered values.  The JavaScript language
  includes special syntax for working with arrays, and arrays have some special
  behavior that distinguishes them from ordinary objects.

  #+cindex:object function
  #+cindex:function object
- JavaScript defines another special kind of object, known as a /function/.  A
  function is an object that has executable code associated with it.  A
  function may be invoked to run that executable code and return a computed
  value.  Like arrays, functions behave differently from other kinds of
  objects, and JavaScript defines a special language syntax for working with
  them.  The most important thing about functions in JavaScript is that /they
  are true values/ and that JavaScript programs can treat them like regular
  objects.

  #+cindex:object constructor
  #+cindex:constructor object
  #+cindex:constructor function
  #+cindex:class of objects
  #+cindex:object class, constructor function
- Functions that are written to be used (with the ~new~ operator) to initialize
  a newly created object are known as /constructors/.  Each constructor defines a
  class of objects—--the set of objects initialized by that constructor.

  #+cindex:object class
  #+cindex:class object
  #+cindex:subtype of object, class
- /Classes/ can be thought of as subtypes of the object type.  In addition to
  the Array and Function classes, core JavaScript defines three other useful
  classes.  You can define your own classes of objects by defining appropriate
  constructor functions.

    #+cindex:Date class
  - The /Date class/ defines objects that represent dates.

    #+cindex:RegExp class
    #+cindex:regular expressions, RegExp class
  - The /RegExp class/ defines objects that represent regular expressions.

    #+cindex:Error class
  - The /Error class/ defines objects that represent syntax and runtime errors
    that can occur in a JavaScript program.


{{{heading(Garbage Collection of Objects)}}}

#+cindex:garbage collection
The JavaScript interpreter performs automatic garbage collection for memory
management.  This means that a program can create objects as needed, and the
programmer never needs to worry about destruction or deallocation of those
objects.  When an object is no longer reachable—--when a program no longer has
any way to refer to it---the interpreter knows it can never be used again and
automatically reclaims the memory it was occupying.

{{{heading(JavaScript is Object-Oriented)}}}

#+cindex:object-oriented language
JavaScript is an /object-oriented/ language.  Loosely, this means that rather
than having globally defined functions to operate on values of various types,
the types themselves define methods for working with values.

Technically, it is only JavaScript objects that have methods.  But numbers,
strings, and boolean values behave as if they had methods.

In JavaScript, =null= and =undefined are the only values that methods cannot be
invoked on.

{{{heading(Mutability)}}}

#+cindex:mutable types
#+cindex:immutable types
#+cindex:mutability types
JavaScript’s types can be categorized as /mutable/ and /immutable/ types.  A
value of a mutable type can change.  Objects and arrays are mutable.  Numbers,
booleans, =null=, and =undefined= are immutable---it doesn’t even make sense to
talk about changing the value of a number, for example.  Strings can be thought
of as arrays of characters, and you might expect them to be mutable.  In
JavaScript, however, strings are immutable: you can access the text at any
index of a string, but JavaScript provides no way to alter the text of an
existing string.

{{{heading(Dynamic Type Conversion)}}}

#+cindex:type conversion
#+cindex:conversion of types
JavaScript converts values liberally from one type to another.  If a program
expects a string, for example, and you give it a number, it will automatically
convert the number to a string for you.  If you use a nonboolean value where a
boolean is expected, JavaScript will convert accordingly.

JavaScript’s liberal value conversion rules affect its definition of equality,
and the == equality operator performs type conversions.

{{{heading(Variables)}}}

{{{subheading(Untyped)}}}

#+cindex:untyped variables
#+cindex:variabes, untyped
JavaScript variables are /untyped/: you can assign a value of any type to a
variable, and you can later assign a value of a different type to the same
variable.

{{{subheading(Declarations)}}}

#+cindex:variable declarations
#+cindex:declare
#+cindex:@code{var} keyword
#+cindex:keyword @code{var}
Variables are /declared/ with the ~var~ keyword.

{{{subheading(Lexical Scope)}}}

#+cindex:lexical scope
#+cindex:scope, lexical
JavaScript uses /lexical scoping/.

{{{subheading(Global Variables)}}}

#+cindex:global variable
#+cindex:variable, global
Variables declared outside of a function are /global variables/ and are visible
everywhere in a JavaScript program.

{{{subheading(Function Scope)}}}

#+cindex:function scope
#+cindex:scope, function
Variables declared inside a function have /function scope/ and are visible only
to code that appears inside that function.

**** Numbers

**** Text
#+cindex:string, dfn
#+cindex:Unicode
#+cindex:length, string, dfn
#+cindex:empty string, dfn
A {{{dfn(string)}}} is an immutable ordered sequence of 16-bit values, each of
which typically represents a Unicode character---strings are JavaScript's type
for representing text.  The {{{dfn(length)}}} of a string is the number of
16-bit values it contains.  JavaScript's strings (and its arrays) use
zero-based indexing.  The {{{dfn(empty string)}}} is the string of length 0.

#+texinfo:@cartouche
{{{heading(Characters---Codepoints---and JavaScript Strings)}}}
<<characters-codepoints-strings>>

#+cindex:codepoints
#+cindex:characters
#+cindex:UTF-16 encoding
#+cindex:encoding, UTF-16
#+cindex:Unicode
#+cindex:character set, Unicode
JavaScrupt uses the UTF-16 encoding of the Unicode character set, and
JavaScript strings are sequences of unsigned 16-bit values.  The most commonly
used Unicode characters (those from the ``basic multilinqual plane'') have
codepoints that fit in 16 bits and can be represented by a single element of a
string.

#+cindex:surrogate pair, dfn
Unicode characters whose codepoints do not fit in 16 bits are encoded following
the rules of UTF-16 as a sequence (known as a {{{dfn(surrogate pair)}}}) of two
16-bit values.  This means that a JavaScript string of length 2 (two 16-bti
values) might represent only a single Unicode character.

#+begin_example
var p = "π"; // π is 1 character with 16-bit codepoint 0x03c0
var e = "e"; // e is 1 character with 17-bit codepoint 0x1d452
p.length     // => 1: p consists of 1 16-bit element
e.length     // => 2: UTF-16 encoding of e is 2 16-bit values:
	     //    "\ud835\udc52"
#+end_example

#+cindex:string manipulation methods and Unicode
The various string-manipulation methods defined by JavaScript operate on 16-bit
values, not on characters.  They do not treat surrogate pairs specially,
perform no normalization of the string, and do not even ensure that a string is
well-formed UTF-16.
#+texinfo:@end cartouche

**** Boolean Values

**** Null and Undefined

***** Null and Undefined Characteristics
#+cindex:@code{null}
- =null= :: keyword that evaluates to a special value used to indicate the
            absence of a value (:(

            =typeof null= == “object”, i.e., =null= is a special object value
            that indicates “no object” (:-(

            =null= is typically regarded as the sole member of its own type,
            which is used to indicate “no value” for numbers, and strings, as
            well as objects.

#+cindex:@code{undefined}
- =undefined= :: predefined global variable (not a language keyword); the
                 =undefined= value represents a deeper kind of absence; it is
                 the value of variables that have not been initialized, as well
                 as the value you get when you query the value of an object
                 property or array element that does not exist.

                 =typeof undefined= == “undefined”, i.e., the sole member of a
                 special type

                 the =undefined= value is returned by functions that have no
                 return value, and is the value of function parameters for
                 which no argument is supplied.

                 in ECMAScript 3, =undefined= is a read-write variable and can
                 be set to any value; in ECMAScript 5, =undefined= is a
                 read-only variable.

***** Interchangeability of Null and Undefined
Both indicate an absence of value.  The equality operator ~==~ considers them
equal, whereas the strict equality operator ~===~ distinguishes them.  Both are
=falsey=.  Neither have any properties or methods.  If you need to assign a
value to a variable, =null= is almost always the right choice.

**** The Global Object
#+cindex:global object
The /global object/ is a regular JavaScript object that serves a very important
purpose: the properties of this object are the globally defined symbols that
are available to a JavaScript program.  When the JavaScript interpreter starts
(or whenever a web browser loads a new page), it creates a new global object
and gives it an initial set of properties that define:

#+cindex:global properties
- global properties like =undefined=, =Infinity=, and =NaN=

#+cindex:global functions
- global functions like ~isNaN()~, ~parseInt()~, and ~eval()~

#+cindex:constructor functions
- constructor functions like ~Date()~, ~RegExp()~, ~String()~, ~Object()~, and
  ~Array()~

#+cindex:global objects @code{Math}, @code{JSON}
- global objects like ~Math~ and ~JSON~


The initial properties of the global object are not reserved words, but should
be treated as though they were.

#+cindex:@code{this} for global object
In top-level code---JavaScript code that is not part of a function---you can
use the JavaScript keyword ~this~ to refer to the global object:

: var global = this; // Define a global variable to refer to the global object

#+cindex:Window object
#+cindex:@code{window} property
In client-side JavaScript, the Window object serves as the global object for
all JavaScript code contained in the browser window it represents.  This global
Window object has a self-referential ~window~ property that can be used instead
of ~this~ to refer to the global object.  The Window object defines the core
global properties, but it also defines quite a few other globals that are
specific to web browsers and client-side JavaScript.

{{{heading(The Global Object Properties)}}}

- =arguments=
- =Array=
- =Boolean=
- =Date=
- =decodedURI=
- =decodedURIComponent=
- =encodedURI=
- =encodedURIComponent=
- =Error=
- =eval=
- =EvalError=
- =Function=
- =Infinity=
- =isFinite=
- =isNaN=
- =JSON=
- =Math=
- =NaN=
- =Number=
- =Object=
- =parseFloat=
- =parseInt=
- =RangeError=
- =ReferenceError=
- =RegExp=
- =String=
- =SyntaxError=
- =TypeError=
- =undefined=
- =URIError=


{{{heading(User-Defined Global Properties)}}}

This special object also holds program-defined globals as well.  If your code
declares a global variable, that variable is a property of the global object.

**** Wrapper Objects
#+cindex:composite values
JavaScript objects are /composite values/: a collection of properties, or named
values.  You can refer to the value of a property using the =dot= (=.=)
notation.  When the value of a property is a function, it is called a
/method/.  To invoke a method of an object, use the =dot= notation, followed by
open and closed parentheses:

: object.method()

***** Strings
Strings are not objects, but they behave as if they had properties.  Whenever
you try to refer to a property of a string ~s~, JavaScript converts the string
value to an object as if by calling ~new String(s)~.  This object inherits
string methods and is used to resolve the property reference.  Once the
property has been resolved, the newly created object is discarded.  Properties
cannot be assigned.

***** Numbers and Booleans
Numbers and Booleans behave the same way when properties and methods are called
upon them: a temporary object is created using the ~Number()~ or ~Boolean()~
constructor, and the method is resolved using that temporary object.

***** Null and Undefined
The values =null= and =undefined= do not have wrappers associated with them,
and any attempt to access a property of one of these values causes a
=TypeError=.

***** Wrappers
The temporary objects created when you access a property of a string, number,
or boolean are known as wrapper objects, and it may occasionally be necessary
to distinguish a string value from a String object or a number or boolean value
from a Number or Boolean object.  You just need to know that string, number,
and boolean values differ from objects in that their properties are read-only
and that you can’t define new properties on them.

Note that it is possible (but almost never necessary or useful) to explicitly
create wrapper objects, by invoking the ~String()~, ~Number()~, or ~Boolean()~
constructors.

**** Immutable Primitive Values and Mutable Object References

{{{heading(Primitives are Immutable Value Types)}}}

There is a fundamental difference in JavaScript between primitive values
(=undefined=, =null=, booleans, numbers, and strings) and objects (including
arrays and functions): Primitives are immutable: there is no way to change (or
“mutate”) a primitive value (included strings); all string methods that appear
to return a modified string are, in fact, returning a new string value.

: str = "hello"; str.toUpperCase(); // Returns "HELLO", but doesn't alter str

Primitives are compared /by value/.

{{{heading(Objects are Mutable Reference Types)}}}

Objects are mutable: their values can change.

Objects are not compared by value: two objects are not equal even if they have
the same properties and values.  And two arrays are not equal even if they have
the same elements in the same order.  Objects are sometimes called /reference
types/ to distinguish them from JavaScript’s primitive types.  Using this
terminology, object values are references, and we say that objects are compared
by reference: two object values are the same if and only if they refer to the
same underlying object.  Assigning an object (or array) to a variable simply
assigns the reference: it does not create a new copy of the object.

**** Type Conversions
JavaScript performs type conversions in many situations.

***** JavaScript Type Conversions

***** Conversions and Equality

***** Explicit Conversions

***** Object to Primitive Conversions

**** Variable Declaration
Before you use a variable in a JavaScript program, you should /declare/ it.
Variables are declared with the =var= keyword.  You can combine variable
declaration with variable initialization.  If you don’t specify an initial
value for a variable with the var statement, the variable is declared, but its
value is =undefined= until your code stores a value into it.

It is legal and harmless to declare a variable more than once with the =var=
statement.  If the repeated declaration has an initializer, it acts as if it
were simply an assignment statement.

If you attempt to read the value of an undeclared variable, JavaScript
generates an error.  In ECMAScript 5 strict mode, it is also an error to assign
a value to an undeclared variable.  Historically, however, and in non-strict
mode, if you assign a value to an undeclared variable, JavaScript actually
creates that variable as a property of the global object, and it works much
like a properly declared global variable.

**** Variable Scope
#+cindex:scope
#+cindex:global variable, scope
#+cindex:local variable, scope
The /scope/ of a variable is the region of your program source code in which it
is defined.  A /global/ variable has global scope; it is defined everywhere in
your JavaScript code.  Variables declared within a function are defined only
within the body of the function.  They are /local/ variables and have /local/
scope.  Function parameters also count as local variables and are defined only
within the body of the function.  Within the body of a function, a local
variable takes precedence over a global variable with the same name; If you
declare a local variable or function parameter with the same name as a global
variable, you effectively hide the global variable.  You must always use =var=
to declare local variables.

***** Function Scope and Hoisting
JavaScript uses /function scope/ (rather than block scope).  Variables are
visible within the function in which they are defined, and within any functions
that are nested within that function.

#+begin_src js
  function test(o) {
      var i = 0;
      if (typeof o == "object") {
          var j = 0; // j is defined everywhere
          for (var k = 0; k < 10; k++) { // k is defined everywhere
              console.log(k);
          }
          console.log(k); // k is still defined; has value 10
      }
      console.log(j); // j is defined, but may not be initialized
  }
#+end_src

#+cindex:hoisting
JavaScript’s function scope means that all variables declared within a function
are visible throughout the body of the function.  This means that variables are
even visible before they are declared.  This feature of JavaScript is
informally known as /hoisting/: JavaScript code behaves as if all variable
declarations in a function (but not any associated assignments) are “hoisted”
to the top of the function.

#+begin_src js
  var scope = "global";
  function f() {
      console.log(scope); // Prints "undefined", not "global"
      var scope = "local"; // Variable initialized here, but defined everywhere
      console.log(scope); // Prints "local"
  }
#+end_src

You might think that the first line of the function would print “global”,
because the =var= statement declaring the local variable has not yet been
executed.  Because of the rules of function scope, however, this is not what
happens.  The local variable is defined throughout the body of the function,
which means the global variable by the same name is hidden throughout the
function.  Although the local variable is defined throughout, it is not
actually initialized until the =var= statement is executed.

***** Variables as Properties

***** The Scope Chain

*** Expressions and Operators
#+cindex:Chapter 4 Expressions and Operators
#+cindex:expression
#+cindex:evaluate
An /expression/ is a phrase of JavaScript that a JavaScript interpreter can
/evaluate/ to produce a /value/.  A constant embedded literally in your program
is a very simple kind of expression.  A variable name is also a simple
expression that evaluates to whatever value has been assigned to that variable.
Complex expressions are built from simpler expressions.

#+cindex:operator, complex expression
#+cindex:operator, returns a value
#+cindex:operator, evaulates to a value
The most common way to build a complex expression out of simpler expressions is
with an /operator/.  An operator comb`ines the values of its /operands/
(usually two of them) in some way and evaluates to a new value.  For
simplicity, we sometimes say that an operator /returns/ a value rather than
“evaluates to” a value.

This chapter documents all of JavaScript’s operators, and it also explains
expressions (such as array indexing and function invocation) that do not use
operators.

**** Primary Expressions

**** Object and Array Initializers

**** Function Definition Expressions

**** Property Access Expressions

**** Invocation Expressions
#+cindex:invocation expression
#+cindex:function expression
An /invocation expression/ is JavaScript’s syntax for calling (or executing) a
function or method.  It starts with a /function expression/ that identifies the
function to be called.  The function expression is followed by an open
parenthesis, a comma-separated list of zero or more argument expressions, and a
close parenthesis.

#+cindex:invocation expression
#+cindex:function expression
When an invocation expression is evaluated, the function expression is
evaluated first, and then the argument expressions are evaluated to produce a
list of argument values.

Next, the argument values are assigned, in order, to the parameter names
specified when the function was defined.

And then the body of the function is executed.

If the function uses a ~return~ statement to return a value, then that value
becomes the value of the invocation expression.  Otherwise, the value of the
invocation expression is =undefined=.

#+cindex:method invocation
#+cindex:this parameter
#+cindex:object-oriented programming paradigm
#+cindex:methods
Every invocation expression includes a pair of parentheses and an expression
before the open parenthesis.  If that expression is a property access
expression, then the invocation is known as a /method invocation/.  In method
invocations, the object or array that is the subject of the property access
becomes the value of the ~this~ parameter while the body of the function is
being executed.  This enables an object-oriented programming paradigm in which
functions (known by their OO name, “methods”) operate on the object of which
they are part.

#+cindex:global object
#+cindex:ECMAScript 5
#+cindex:strict mode
Invocation expressions that are not method invocations normally use the global
object as the value of the ~this~ keyword.  In ECMAScript 5, however, functions
that are defined in strict mode are invoked with =undefined= as their ~this~
value rather than the global object.

**** Object Creation Expressions

#+cindex:object creation expression
#+cindex:constructor function
#+cindex:initialize properties
#+cindex:@code{new} keyword
An /object creation expression/
- creates a new object using the keyword /new/; and
- invokes a constructor function to initialize the properties of the object.


When an object creation expression is evaluated:
- JavaScript first creates a new empty object, just like the one created by the
  object initializer ={}=;
  #+cindex:@code{this} keyword
- Next, it invokes the specified function with the specified arguments, passing
  the new object as the value of the ~this~ keyword.
- The function can then use ~this~ to initialize the properties of the newly
  created object.
- Functions written for use as constructors do not return a value, and the
  value of the object creation expression is the newly created and initialized
  object.
- If a constructor does return an object value, that value becomes the value of
  the object creation expression and the newly created object is discarded.
**** Operator Overview

**** Arithmetic Expressions

**** Relational Expressions

**** Logical Expressions

**** Assignment Expressions

**** Evaluation Expressions

**** Miscellaneous Operators

*** Statements
#+cindex:Chapter 5 Statements
#+cindex:statements
/Statements/ are JavaScript sentences or commands.  Just as English sentences
are terminated and separated from each other with periods, JavaScript
statements are terminated with semicolons.  Expressions are /evaluated/ to
produce a value, but statements are /executed/ to make something happen.

{{{heading(Side Effects)}}}

#+cindex:side effect
#+cindex:expression statement
#+cindex:declaration statement
#+cindex:statements, types
One way to “make something happen” is to evaluate an expression that has side
effects.  Expressions with side effects, such as /assignments/ and /function
invocations/, can stand alone as statements, and when used this way they are
known as /expression statements/.  A similar category of statements are the
/declaration statements/ that /declare/ new variables and /define/ new
functions.

{{{heading(Control Structures)}}}

#+cindex:control structures
JavaScript programs are nothing more than a sequence of statements to execute.
By default, the JavaScript interpreter executes these statements one after
another in the order they are written.  Another way to “make something happen”
is to alter this default order of execution, and JavaScript has a number of
statements or /control structures/ that do just this:

#+cindex:conditionals
- /Conditionals/ are statements like ~if~ and ~switch~; that make the JavaScript
  interpreter execute or skip other statements depending on the value of an
  expression.

  #+cindex:loops
- /Loops/ are statements like ~while~ and ~for~ that execute other statements
  repetitively.

  #+cindex:jumps
- /Jumps/ are statements like ~break~, ~return~, and ~throw~ that cause the
  interpreter to jump to another part of the program.


The sections that follow describe the various statements in JavaScript and
explain their syntax.

**** Expression Statements

**** Compound and Empty Statements

**** Declaration Statements

**** Conditionals

**** Loops

**** Jumps

**** Miscellaneous Statements

**** Summary of JavaScript Statements

*** Objects
#+cindex:Chapter 6 Objects
#+cindex:objects, intro
JavaScript’s fundamental datatype is the /object/.

#+cindex:composite value, object
- An object is a /composite value/: it aggregates multiple values (primitive
  values or other objects) and allows you to store and retrieve those values by
  name.

  #+cindex:unordered collection of properties, object
- An object is an /unordered collection of properties/, each of which has a
  name and a value.  Property names are strings, so we can say that objects map
  strings to values.

  #+cindex:protoype object
  #+cindex:protoypal inheritance
- An object is more than a simple string- to-value map, however.  In addition
  to maintaining its own set of properties, a JavaScript object also inherits
  the properties of another object, known as its “prototype.”  The methods of
  an object are typically inherited properties, and this “prototypal inheri-
  tance” is a key feature of JavaScript.

  #+cindex:dynamic, objects
  #+cindex:objects, dynamic
  #+cindex:static objects, structs
- JavaScript objects are /dynamic/---properties can usually be added and
  deleted---but they can be used to simulate the static objects and “structs”
  of statically typed languages.  They can also be used (by ignoring the value
  part of the string-to-value mapping) to represent sets of strings.

  #+cindex:object value
- Any value in JavaScript that is not a string, a number, true, false, =null=,
  or =undefined= is an object.  And even though strings, numbers, and booleans
  are not objects, they behave like immutable objects

- The most common things to do with objects are /create/ them and to /set/,
  /query/, /delete/, /test/, and /enumerate/ their properties.

  #+cindex:property as string
  #+cindex:value of object
  #+cindex:getter function
  #+cindex:setter function
- A /property/ has a name and a value.

  - A /property name/ may be any string, including the empty string, but no
    object may have two properties with the same name.

  - The /value/ may be any JavaScript value, or (in ECMAScript 5) it may be a
    getter or a setter function (or both).


{{{Object Terms and Categories}}}

Here are some terms to distinguish among three broad categories of JavaScript
objects and two types of properties:

 #+cindex:native object 
- A /native object/ is an object or class of objects defined by the ECMAScript
  specifi- cation. Arrays, functions, dates, and regular expressions (for
  example) are native objects.

  #+cindex:host object
- A /host object/ is an object defined by the host environment (such as a web
  browser) within which the JavaScript interpreter is embedded. The HTMLElement
  objects that represent the structure of a web page in client-side JavaScript
  are host objects. Host objects may also be native objects, as when the host
  environment defines methods that are normal JavaScript Function objects.

  #+cindex:user-defined object
- A /user-defined/ object is any object created by the execution of JavaScript
  code.

  #+cindex:own property
- An /own property/ is a property defined directly on an object.

  #+cindex:inherited property
- An /inherited property/ is a property defined by an object’s prototype
  object.


**** Creating Objects
Objects are created with:

- object literals ::
     a comma-separated list of colon-separated name:value pairs, enclosed
     within curly braces:

     : {a: 'a', b: 1}

  - property name :: a JavaScript identifier or a string literal (the empty
                     string is allowed); property names that are reserved words
                     must be quoted in ECMAScript 3, but reserved words may be
                     used as property names without quoting in ECMAScript 5.

  - property value :: any JavaScript expression; the value of the expression
                      (it may be a primitive value or an object value) becomes
                      the value of the property

- ~new~ keyword :: ~new~ <Function-Constructor>()

  - constructor :: A function used in this way; it serves to initialize a
                   newly-created object

  - prototype :: an object associated with another object and from which the
                 other object inherits its properties

- ~Object.create(<prototype>, [<properties>])~ ::
     a method in ECMAScript 5 that creates a new object using its first
     argument as the prototype of that object, and its optional second argument
     to describe the properties of the new object.

***** Object Literals
#+cindex:object literal
An object literal is an expression that creates and initializes a new and
distinct object each time it is evaluated.  The value of each property is
evaluated each time the literal is evaluated.  This means that a single object
literal can create many new objects if it appears within the body of a loop in
a function that is called repeatedly, and that the property values of these
objects may differ from each other.

***** Creating Objects with New
#+cindex:@code{new} operator
#+cindex:constructor, built-in
#+cindex:built-in constructor
The ~new~ operator creates and initializes a new object.  Core JavaScript
includes built-in constructors for native types. For example:

: new Object() // same as {}

: new Array() // same as []

: new Date()

: new RegExp(<string>)

It is common to define your own constructor functions to initialize newly
created objects.

****** Prototypes
#+cindex:prototype
Every JavaScript object has a second JavaScript object (or null, but this is
rare) associated with it.  This second object is known as a /prototype/, and
the first object inherits properties from the prototype.

#+cindex:object literal
#+cindex:@code{Object.prototype}
All objects created by /object literals/ have the same prototype object, and we
can refer to this prototype object in JavaScript code as =Object.prototype=.
=Object.prototype= is one of the rare objects that has no prototype: it does
not inherit any properties.  Other prototype objects are normal objects that do
have a prototype.  All of the built-in constructors (and most user-defined
constructors) have a prototype that inherits from =Object.prototype=.

#+cindex:@code{prototype} property
#+cindex:constructor invocation
#+cindex:@code{new} keyword
Objects created using the ~new~ keyword and a constructor invocation use the
value of the =prototype= property of the constructor function as their
prototype.  So the object created by ~new Object()~ inherits from
=Object.prototype= just as the object created by ={}= does.  Similarly, the
object created by new ~Array()~ uses =Array.prototype= as its prototype, and
the object created by ~new Date()~ uses =Date.prototype= as its prototype.
Date.prototype inherits properties from =Object.prototype=,so a =Date= object
created by ~new Date()~ inherits properties from both =Date.prototype= and
=Object.prototype=.

prototype chain :: linked series of prototype objects

***** Object.create()

#+cindex:@code{Object.create()}
#+cindex:ECMAScript 5
#+attr_texinfo: :options Object create (PROTOTYPE [,PROPERTIES])
#+begin_defmethod
A static method defined in ECMAScript 5 that is used to create a new object
using PROTOTYPE as the prototype for the new object and optional PROPERTIES to
describe the properties of the new object.

~Object.create()~ is a /static function/, not a method invoked on individual
objects.  To use it, simply pass the desired prototype object:

: var o1 = Object.create({x:1, y:2}); // o1 inherits properties x and y.

If you want to create an ordinary empty object (like the object returned by ={}=
or ~new Object()~), pass =Object.prototype=:

: var o3 = Object.create(Object.prototype); // o3 is like {} or new Object().
#+end_defmethod

{{{heading(The ~inherit~ Function)}}}

#+cindex:ECMAScript 3
The ability to create a new object with an arbitrary prototype (put another
way: the ability to create an “heir” for any object) is a powerful one, and we
can simulate it in ECMAScript 3 with a function like ~inherit()~.

#+caption: Creating a new object that inherits from a prototype
#+name:inherit-function
#+begin_src js -n
  // inherit() returns a newly created object that inherits properties from the
  // prototype object p.  It uses the ECMAScript 5 function Object.create() if
  // it is defined, and otherwise falls back to an older technique.

  function inherit(p) {
      if (p == null) throw TypeError();	// p must be a non-null object
      if (Object.create)			// If Object.create() is defined...
          return Object.create(p);	// then just use it.
      var t = typeof p;			// Otherwise do some more type checking
      if (t !== "object" && t !== "function")
          throw TypeError();
      function f() {};			// Define a dummy constructor function.
      f.prototype = p;			// Set its prototype property to p.
      return new f();			// Use f() to create an "heir" of p.
  }
#+end_src

This ~inherit()~ function returns a new object that inherits the properties of
the argument object.[fn::~inherit()~ is not a full replacement for
~Object.create()~: it does not allow the creation of objects with null
prototypes, and it does not accept the optional second argument that
~Object.create()~ does.][fn::Douglas Crockford is generally credited as the
first to propose a function that creates objects in this way. See [[http://crockford.com/javascript/prototypal.html][Prototypal
Inheritance in JavaScript]]]

One use for the ~inherit()~ function is when you want to guard against
unintended (but nonmalicious) modification of an object by a library function
that you don’t have control over.  Instead of passing the object directly to
the function, you can pass an heir.  If the function reads properties of the
heir, it will see the inherited values.  If it sets properties, however, those
properties will only affect the heir, not your original object:

#+begin_src js
var o = { x: "don't change this value" };
library_function(inherit(o)); // Guard against accidental modifications of o
#+end_src
**** Querying and Setting Properties
To obtain the value of a property, use the dot (.) or square bracket ([])
operators.  The left-hand side should be an expression whose value is an
object.  If using the dot operator, the right-hand must be a simple identifier
that names the property. If using square brackets, the value within the
brackets must be an expression that evaluates to a string that contains the
desired property name.

To create or set a property, use a dot or square brackets as you would to query
the property, but put them on the left-hand side of an assignment expression.

In ECMAScript 3, the identifier that follows the dot operator cannot be a
reserved word.  If an object has properties whose name is a reserved word, you
must use square bracket notation to access them.  ECMAScript 5 relaxes this
restriction and allows reserved words to follow the dot.

When using square bracket notation, the expression must evaluate to a string or
a value that can be converted to a string.

***** Objects As Associative Arrays
: object["property"]

#+cindex:associatiave array
#+cindex:hash
#+cindex:map
#+cindex:dictionry
This kind of array is known as an /associative array/ (or hash or map or
dictionary).  JavaScript objects are associative arrays.

#+cindex:loosely typed language
In C, C++, Java, and similar strongly typed languages, an object can have only
a fixed number of properties, and the names of these properties must be defined
in advance.  Since JavaScript is a loosely typed language, this rule does not
apply: a program can create any number of properties in any object.  When you
access a property of an object with the =[]= array notation, the name of the
property is expressed as a string.  Strings are JavaScript datatypes, so they
can be manipulated and created while a program is running.

***** Inheritance and Property Access
#+cindex:own properties
JavaScript objects have a set of “own properties,” and they also inherit a set
of properties from their prototype object.

****** Property Access---Querying
#+cindex:query object
#+cindex:query prototype
Suppose you query the property =x= in the object =o=.  If =o= does not have an
own property with that name, the prototype object of =o= is queried for the
property =x=.  If the prototype object does not have an own property by that
name, but has a prototype itself, the query is performed on the prototype of
the prototype.  This continues until the property =x= is found or until an
object with a =null= prototype is searched.

#+cindex:chain, prototype attribute
The prototype ATTRIBUTE of an object creates a chain or linked list from which
properties are inherited.

****** Property Access---Assigning
#+cindex:assign to object
#+cindex:hidden property
Now suppose you assign to the property =x= of the object =o=.  If =o= already
has an own (noninherited) property named =x=, then the assignment simply
changes the value of this existing property.  Otherwise, the assignment creates
a new property named =x= on the object =o=.  If o previously inherited the
property =x=, that inherited property is now hidden by the newly created own
property with the same name.

Property assignment examines the prototype chain to determine whether the
assignment is allowed.  If =o= inherits a read-only property named =x=, for
example, then the assignment is not allowed.  If the assignment is allowed,
however, it always creates or sets a property in the original object and never
modifies the prototype chain.

The fact that inheritance occurs when querying properties but not when setting
them is a key feature of JavaScript because it allows us to selectively
override inherited properties.

****** Property Access---Accessors
#+cindex:accessor property
There is one exception to the rule that a property assignment either fails or
creates or sets a property in the original object.  If =o= inherits the
property =x=, and that property is an /accessor property/ with a setter method,
then that setter method is called rather than creating a new property =x= in
=o=.  Note, however, that the setter method is called on the object =o=, not on
the prototype object that defines the property, so if the setter method defines
any properties, it will do so on =o=, and it will again leave the prototype
chain unmodified.

****** Property Access---Errors
#+cindex:property access errors
Property access expressions do not always return or set a value.

It is not an error to query a property that does not exist.  If the property
=x= is not found as an own property or an inherited property of =o=, the
property access expression ~o.x~ evaluates to =undefined=.

It is an error, however, to attempt to query or set a property of an object
that does not exist.  The =null= and =undefined= values have no properties, and
it is an error to query or set properties of these values.

To guard against querying properties on non-existent objects:
: var len = book && book.subtitle && book.subtitle.length;

Attempts to set properties on other values do not always succeed, either: some
properties are read-only and cannot be set, and some objects do not allow the
addition of new properties.  These failed attempts to set properties usually
fail silently:

: // The prototype properties of built-in constructors are read-only.
: Object.prototype = 0; // Assignment fails silently; Object.prototype unchanged

#+cindex:strict mode
#+cindex:ECMAScript 5
This historical quirk of JavaScript is rectified in the strict mode of
ECMAScript 5.  In strict mode, any failed attempt to set a property throws a
TypeError exception.

{{{heading(When Property Assignment Fails)}}}

An attempt to set a property =p= of an object =o= fails in these circumstances:

#+cindex:read-only property
#+cindex:configurable read-only property
- =o= has an own property =p= that is read-only: it is not possible to set
  read-only properties. [fn::See the ~defineProperty()~ method, however, for an
  exception that allows configurable read-only properties to be set.]

  #+cindex:hide inherited read-only property, not possible
- =o= has an inherited property =p= that is read-only: it is not possible to
  hide an inherited read-only property with an own property of the same name.

  #+cindex:extensible attribute
- =o= does not have an own property =p=; =o= does not inherit a property =p=
  with a setter method, and =o=’s =extensible= attribute is =false=.  If =p=
  does not already exist on =o=, and if there is no setter method to call, then
  =p= must be added to =o=.  But if =o= is not extensible, then no new
  properties can be defined on it.
**** Deleting Properties
The ~delete~ operator removes a property from an object.  Its single operand
should be a property access expression.  ~delete~ operates to remove the
property itself, not just its value.  The ~delete~ operator only deletes own
properties, not inherited ones.  To delete an inherited property, you must
delete it from the prototype object in which it is defined.  Doing this affects
every object that inherits from that prototype.

A ~delete~ expression evaluates to =true= if the delete succeeded or if the
delete had no effect (such as deleting a nonexistent property).  ~delete~ also
evaluates to =true= when used (meaninglessly) with an expression that is not a
property access expression.

~delete~ does not remove properties that have a configurable attribute of
false.  (Though it will remove configurable properties of nonextensible
objects.)  In strict mode, attempting to delete a nonconfigurable property
causes a TypeError.  In non-strict mode (and in ECMAScript 3), ~delete~ simply
evaluates to =false= in this case.

**** Testing Properties
JavaScript objects can be thought of as sets of properties, and it is often
useful to be able to test for membership in the set—to check whether an object
has a property with a given name. You can do this with the:

- ~in~ operator
- ~hasOwnProperty()~ method
- ~propertyIsEnumerable()~ method
- query the property

{{{heading(The ~in Operator)}}}

#+cindex:@code{in} operator
The ~in~ operator expects a property name (as a string) on its left side and an
object on its right.  It returns =true= if the object has an own property or an
inherited property by that name.

{{{heading(hasOwnProperty() Method)}}}

#+cindex:@code{hasOwnProperty()} method
The ~hasOwnProperty()~ method of an object tests whether that object has an own
property with the given name.  It returns =false= for inherited properties.

{{{heading(propertyIsEnumerable() Method)}}}

#+cindex:@code{propertyIsEnumerable()} method
The ~propertyIsEnumerable()~ refines the ~hasOwnProperty()~ test.  It returns
true only if the named property is an own property and its enumerable attribute
is true.

{{{heading(Query the Property)}}}

Instead of using the ~in~ operator it is often sufficient to simply query the
property and use ~!==~ to make sure it is not =undefined=.

There is one thing the ~in~ operator can do that the simple property access
technique shown above cannot do.  ~in~ can distinguish between properties that
do not exist and properties that exist but have been set to =undefined=.

Further, to determine simply whether a property is not =falsey= or converts to
a =falsey= (=null= or =undefined= or =false= or "" or 0 or =NaN=), use ~!=~
instead of ~!==~.

**** Enumerating Properties
#+cindex:iterate through properties
Instead of testing for the existence of individual properties, we sometimes
want to iterate through or obtain a list of all the properties of an object.
This is usually done with the =for/in= loop, although ECMAScript 5 provides two
handy alternatives.

{{{heading(Iterating Using the =for/in= Loop)}}}

The =for/in= loop runs the body of the loop once for each enumerable property
(own or inherited) of the specified object, assigning the name of the property
to the loop variable.  Built-in methods that objects inherit are not
enumerable, but the properties that your code adds to objects are enumerable
(unless you use one of the functions described later to make them
nonenumerable).

To guard against enumerating inherited properties, you might want to filter the
properties returned by =for/in=.  Here are two ways you might do so:

#+begin_src js -n
  for(p in o) {
      if (!o.hasOwnProperty(p)) continue; // Skip inherited properties
  }

  for(p in o) {
      if (typeof o[p] === "function") continue; // Skip methods
  }
#+end_src

***** Utility Functions that use =for/in= Loops

The following examples define utility functions that use =for/in= loops to
manipulate object properties in helpful ways.

**** Property Getters and Setters
Fundamentally, an object property is a name, a value, and a set of attributes.

#+cindex:getter method
#+cindex:setter method
#+cindex:ECMAScript 5
#+cindex:accessor properties
#+cindex:data properties
In ECMAScript 5, the value may be replaced by one or two methods, known as a
/getter/ and a /setter/.  These are both also known as /accessor properties/,
to distinguish then from /data properties/, which have a simple value.

/Accessor properties/ are defined as one or two functions whose name is the
same as the property name, and with the =function= keyword replaced with =get=
and/or =set=.  Accessor properties are inherited, just as data properties are.
Reasons to use accessor properties include sanity checking of property writes
and returning different values on each property read, and providing an
alternative model of a single version of state.

{{{heading(Querying an Accessor Property)}}}

#+cindex:accessor query
When a program queries the value of an accessor property, JavaScript invokes
the getter method (passing no arguments).  The return value of this method
becomes the value of the property access expression.

{{{heading(Setting an Accessor Property)}}}

#+cindex:accessor set
When a program sets the value of an accessor property, JavaScript invokes the
setter method, passing the value of the right-hand side of the assignment.
This method is responsible for “setting,” in some sense, the property value.
The return value of the setter method is ignored.

{{{heading(No Writable Attribute)}}}

#+cindex:writable attribute
Accessor properties do not have a writable attribute as data properties do.  If
a property has both a getter and a setter method, it is a read/write property.
If it has only a getter method, it is a read-only property.  And if it has only
a setter method, it is a write-only property (something that is not possible
with data properties) and attempts to read it always evaluate to =undefined=.

{{{heading(Define an Accessor Property)}}}

#+cindex:accessor property, define
The easiest way to define accessor properties is with an extension to the
object literal syntax:

#+begin_src js -n
  var o = {
      // An ordinary data property
      data_prop: value,
      // An accessor property defined as a pair of functions
      get accessor_prop() { /* function body here */ },
      set accessor_prop(value) { /* function body here */ }
  };
#+end_src

Note that no colon is used to separate the name of the property from the
functions that access that property, but that a comma is still required after
the function body to separate the method from the next method or data property.

**** Property Attributes

#+cindex:attributes, property
In addition to a name and value, properties have /attributes/ that specify
whether they can be /written/, /enumerated/, and /configured/.

#+cindex:ECMAScript 3
In ECMAScript 3, there is no way to set these attributes: all properties
created by ECMAScript 3 programs are 
- writable,
- enumerable, and 
- configurable,


{{{noindent}}}and there is no way to change this.

#+cindex:ECMAScript 5
ECMAScript 5 introduced ways for querying and setting property attributes.
These methods allow authors to:

- add methods to prototype objects and make them nonenumerable, like built-in
  methods.

- “lock down” their objects, defining properties that cannot be changed or
  deleted.


In this regard, =getter= and =setter= methods of an accessor property are to be
considered as property attributes.  In addition, the value of a data property
is considered a property attribute as well.  Thus, a property has a /name/ and
four /attributes/.

  #+cindex:value attribute
  - The /value/ or /get/ attribute: accessor properties don't have a /value/
    attribute; rather, they have a /get/ attribute;

    #+cindex:writable attribute
  - The /writable/ or /set/ attribute: specifies whether the value of the
    property can be set; accessor properties don't have a /writable/ attribute;
    rather, they have a /set/ attribute.

    #+cindex:enumerable attribute
  - The /enumerable attribute/ specifies whether the property name is returned
    by a =for/in= loop.

    #+cindex:configurable attribute
  - The /configurable attribute/ specifies whether the property can be deleted
    and whether its attributes can be altered.

***** The Property Descriptor
#+cindex:property descriptor object
#+cindex:ECMAScript 5
The ECMAScript 5 methods for querying and setting the attributes of a property
use an object called a /property descriptor/ to represent the set of four
attributes.  A property descriptor object has properties with the same names as
the attributes of the property it describes.

#+cindex:property descriptor, data property
Thus, the property descriptor object of a data property has properties named:

- value
- writable (Bool)
- enumerable (Bool)
- configurable (Bool)


#+cindex:property descriptor, accessor property
The descriptor for an accessor property has:

- get (Function)
- set (Function)
- enumerable (Bool)
- configurable (Bool)


****** Object.getOwnPropertyDescriptor()
#+cindex:@code{Object.getOwnPropertyDescriptor()}
To obtain the property descriptor for a named property of a specified object,
call ~Object.getOwnPropertyDescriptor()~.

: Object.getOwnPropertyDescriptor({x:1}, "x");

~Object.getOwnPropertyDescriptor()~ works only for =own= properties.  This
method returns =undefined= for inherited properties and properties that don't
exist.  To query the attributes of inherited properties, you must explicitly
traverse the prototype chain

#+cindex:@code{Object.getOwnPropertyDescriptors()}
To obtain the property descriptors for all properties of an object, use
~Object.getOwnPropertyDescriptors()~.  This will return an object containing
all own property descriptors of an object, or an empty object if there are no
properties.

{{{heading(Create a Shallow Clone)}}}

To create a shallow copy of an object, use this method along with
~Object.getPrototypeOf()~ and ~Object.create()~:

#+caption:Create a Shallow Clone of an object
#+name:create-shallow-clone-of-object
#+begin_src js
Object.create(
  Object.getPrototypeOf(obj), 
  Object.getOwnPropertyDescriptors(obj) 
);
#+end_src

****** Object.defineProperty()
#+cindex:@code{Object.defineProperty()}
To set the attributes of a property, or to create a new property with the
specified attributes, call ~Object.defineProperty()~, passing the object to be
modified, the name of the property to be created or altered, and the property
descriptor object:

: Object.defineProperty(o, "p", {value: v, writable: true, enumerable: false, configurable: true})
: Object.defineProperty(o, "q", {get: function () { ...body }, set: function(q) { ...body }, enumerable: true, configurable: true})

The property descriptor you pass to ~Object.defineProperty()~ does not have to
include all four attributes.  If you’re creating a new property, then omitted
attributes are taken to be =false= or =undefined=.  If you’re modifying an
existing property, then the attributes you omit are simply left unchanged.
This method alters an existing own property or creates a new own property, but
it will not alter an inherited property.

****** Property Descriptors and Object.defineProperties()
#+cindex:@code{Object.defineProperties()}
If you want to create or modify more than one property at a time, use
~Object.define Properties()~.  The first argument is the object that is to be
modified.  The second argument is an object that maps the names of the
properties to be created or modified to the property descriptors for those
properties.

#+begin_src js -n
  var p = Object.defineProperties({}, {
      x: { value: 1, writable: true, enumerable:true, configurable:true },
      y: { value: 1, writable: true, enumerable:true, configurable:true },
      r: {
          get: function() { return Math.sqrt(this.x*this.x + this.y*this.y) },
          enumerable:true,
          configurable:true
      }
  });
#+end_src

This code starts with an empty object, then adds two data properties and one
read-only accessor property to it.  It relies on the fact that
~Object.defineProperties()~ returns the modified object.

****** Property Descriptors and Object.create()
The first argument to the ~Object.create()~ method is the prototype object to
be added to the newly-created object.  A second (optional) argument is the same
as the second argument to ~Object.defineProperties()~.  If you pass a set of
property descriptors to ~Object.create()~, then they are used to add properties
to the newly created object.

***** Property Attributes and TypeError
~Object.defineProperty()~ and ~Object.defineProperties()~ throw =TypeError= if
the attempt to create or modify a property is not allowed.  This happens if you
attempt to add a new property to a nonextensible attribute.

The other reasons that these methods might throw =TypeError= have to do with
the attributes themselves.

- writable attribute: The writable attribute governs attempts to change the
  value attribute.

- configurable attribute: the configurable attribute governs attempts to change
  the other attributes (and also specifies whether a property can be deleted).


However, it is possible to change the value of a nonwritable property if that
property is configurable.  Also, it is possible to change a property from
writable to nonwritable even if that property is nonconfigurable.  Here are
the rules.  Calls that attempt to violate them throw =TypeError=.

- If an object is not extensible, you can edit its existing own properties, but
  you cannot add new properties to it.

- If a property is not configurable, you cannot change its configurable or
  enumerable attributes.

- If an accessor property is not configurable, you cannot change its getter or
  setter method, and you cannot change it to a data property.

- If a data property is not configurable, you cannot change it to an accessor
  property.

- If a data property is not configurable, you cannot change its writable
  attribute from false to true, but you can change it from true to false.

- If a data property is not configurable and not writable, you cannot change
  its value.  You can change the value of a property that is configurable but
  nonwritable, however (because that would be the same as making it writable,
  then changing the value, then converting it back to nonwritable).

***** A Complete Utility Method ~extend()~ Added to Object.prototype
Here is a new version of ~extend()~ that uses
~Object.getOwnPropertyDescriptor()~ and ~Object.defineProperty()~ to copy all
property attributes.  Rather than being written as a function, this version is
defined as a new Object method and is added as a =nonenumerable= property to
=Object.prototype=.

#+caption:extend Method on Object.prototype
#+name:extend-method-on-Object.prototype
#+begin_src js -n
  /*
  ,* Add a nonenumerable extend() method to Object.prototype.  This
  ,* method extends the object on which it is called by copying
  ,* properties from the object passed as its argument. All property
  ,* attributes are copied, not just the property value. All own
  ,* properties (even non- enumerable ones) of the argument object are
  ,* copied unless a property with the same name already exists in the
  ,* target object.
  ,*/

  Object.defineProperty(Object.prototype,
                        "extend", // Object.prototype.extend()
                        {
                            writable: true,
                            enumerable: false,
                            configurable: true,
                            value: function(o) { // Its value is this function
                                // Get all own props, even nonenumerable ones
                                var names = Object.getOwnPropertyNames(o);
                                // Loop through them
                                for(var i = 0; i < names.length; i++) {
                                    // Skip props already in this object
                                    if (names[i] in this) continue;
                                    // Get property description from o
                                    var desc = Object.getOwnPropertyDescriptor(o,names[i]);
                                    // Use it to create property on this
                                    Object.defineProperty(this, names[i], desc);
                            }
                            }
                        }
                       );
#+end_src

**** Object Attributes

#+cindex:object attributes
#+cindex:attributes of objects
#+cindex:object properties
In addition to its /properties/, every object has three associated /object
attributes/:

  #+cindex:prototype reference
  - An object’s /prototype/ is a reference to another object from which
    properties are inherited.

    #+cindex:object class
  - An object’s /class/ is a string that categorizes the type of an object.

    #+cindex:extensible flag
    #+cindex:ECMAScript 5 feature, extensible flag
  - An object’s /extensible flag/ specifies (in ECMAScript 5) whether new
    properties may be added to the object.

***** Prototype Attribute

#+cindex:prototype attribute
An object’s /prototype/ attribute specifies the object from which it inherits
properties. See Prototypes.

{{{heading(Prototype Attribute of an Object)}}}

#+cindex:prototype attribute of an object
This is such an important attribute that we’ll usually simply say “the
PROTOTYPE of =o=” rather than “the prototype attribute of =o=.”

Also, it is important to understand that when =prototype= appears in =code=
font, it refers to an ordinary object property, not to the PROTOTYPE ATTRIBUTE.

: o.prototype // an ordinary object property

{{{heading(The Prototype Attribvute is Set When an Object is Created)}}}

#+cindex:prototype attribute
#+cindex:attribute, prototype
The /prototype/ ATTRIBUTE is set when an object is created.

Objects created from object literals (={}=) use =Object.prototype= as their
prototype.

#+cindex:prototype property
#+cindex:property, prototype
#+cindex:@code{new} keyword
#+cindex:ECMAScript 5
Objects created with ~new~ use the value of the =prototype= PROPERTY of their
constructor function as their prototype.  In ECMAScript 5, you can query the
prototype of any object by passing that object to ~Object.getPrototypeOf()~
function.  There is no equivalent function in ECMAScript 3, but it is often
possible to determine the prototype of an object =o= using the expression
~o.constructor.prototype~.  Objects created with a ~new~ expression usually
inherit a =constructor= PROPERTY that refers to the constructor function used
to create the object.  Constructor functions have a =prototype= PROPERTY that
specifies the prototype for objects created using that constructor.

: function A() {}
: Object.getOwnPropertyNames(A) // ==> [ 'length', 'name', 'arguments', 'caller', 'prototype' ]
:
: var a = new A() // objects created with new inherit a 'constructor' PROPERTY
:                 // that refers to the constructor function;
:                 // constructor functions have a prototype PROPERTY
:                 // that specifies the prototype for created objects
:
: a.constructor        // [Function: A]
: typeof a.constructor // ==> 'function'
: a.constructor === A  // ==> true

: a.__proto__              === A.prototype // ==> true
: a.constructor.prototype  === A.prototype // ==> true
: Object.getPrototypeOf(a) === A.prototype // ==> true

And objects created with ~Object.create()~ use the first argument to that
function (which may be null) as their prototype.  Objects created by object
literals or by ~Object.create()~ have a =constructor= property that refers to
the ~Object()~ constructor.  Thus, ~constructor.prototype~ refers to the
correct prototype for object literals.

{{{heading(isPrototypeOf() Method)}}}

#+cindex:@code{isPrototypeOf()} methodn
To determine whether one object is the prototype of (or is part of the
prototype chain of) another object, use the ~isPrototypeOf()~ method.  To find
out if =p= is the prototype of =o= write:
: p.isPrototypeOf(o)

~isPrototypeOf()~ performs a function similar to the ~instanceof~ operator.

{{{heading(__proto__ Property)}}}

#+cindex:@code{__proto__} property
Mozilla’s implementation of JavaScript has exposed the prototype ATTRIBUTE
through the specially named =__proto__= accessor property, and you can use this
accessor property to directly query or set the prototype of any object.

***** class Attribute

#+cindex:class attribute

***** extensible Attribute

#+cindex:extensible attribute

**** Serializing Objects
#+cindex:serialization
Object /serialization/ is the process of converting an object’s state to a
string from which it can later be restored.

***** JSON Functions
#+cindex:ECMAScript 5
#+cindex:@code{JSON.stringify()}
#+cindex:@code{JSON.parse()}
#+cindex:JSON data interchange format
#+cindex:Javascript Object Notation, JSON
ECMAScript 5 provides native functions ~JSON.stringify()~ and ~JSON.parse()~ to
serialize and restore JavaScript objects.  These functions use the JSON data
interchange format.  JSON stands for “JavaScript Object Notation.”

The native implementation of these functions in ECMAScript 5 was modeled very
closely after the public-domain ECMAScript 3 implementation available at
http://json.org/json2.js.

***** JSON Syntax
JSON syntax is a subset of JavaScript syntax, and it cannot represent all
JavaScript values.  Objects, arrays, strings, finite numbers, true, false, and
null are supported and can be serialized and restored.

- NaN, Infinity, and -Infinity are serialized to null. 

- =Date= objects are serialized to ISO-formatted date strings (see the
  ~Date.toJSON()~ function), but ~JSON.parse()~ leaves these in string form and
  does not restore the original =Date= object.

- =Function=, =RegExp=, and =Error= objects and the =undefined= value cannot be
  serialized or restored.

- ~JSON.stringify()~ serializes only the enumerable own properties of an
  object.  If a property value cannot be serialized, that property is simply
  omitted from the stringified output.

- Both ~JSON.stringify()~ and ~JSON.parse()~ accept optional second arguments
  that can be used to customize the serialization and/or restoration process by
  specifying a list of properties to be serialized.

**** Object Methods
There are a handful of universal object methods that are defined on
=Object.prototype=, but which are intended to be overridden by other, more
specialized classes.

***** toString() Method
#+cindex:@code{toString()} method
The ~toString()~ method takes no arguments; it returns a string that somehow
represents the value of the object on which it is invoked.  JavaScript invokes
this method of an object whenever it needs to convert the object to a string.

The default ~toString()~ method is not very informative (though it is useful
for determining the class of an object.  Because this default method does not
display much useful information, many classes define their own versions of
~toString()~.

***** toLocaleString() Method
#+cindex:@code{toLocaleString()} method
In addition to the basic ~toString()~ method, objects all have a
~toLocaleString()~.  The purpose of this method is to return a localized string
representation of the object.

***** toJSON() Method
#+cindex:@code{toJSON()} method
=Object.prototype= does not actually define a ~toJSON()~ method, but the
~JSON.stringify()~ method looks for a ~toJSON()~ method on any object it is
asked to serialize.  If this method exists on the object to be serialized, it
is invoked, and the return value is serialized, instead of the original object.

***** valueOf Method
#+cindex:@code{valueOf()} method
The ~valueOf()~ method is much like the ~toString()~ method, but it is called
when JavaScript needs to convert an object to some primitive type other than a
string---typically, a number.  JavaScript calls this method automatically if an
object is used in a context where a primitive value is required.
*** Arrays
#+cindex:element, array
#+cindex:index, array
An array is an ordered collection of values.  Each value is called an element,
and each element has a numeric position in the array, known as its index.

#+cindex:untyped, arrays
JavaScript arrays are /untyped/: an array element may be of any type, and
different elements of the same array may be of different types.  Array elements
may even be objects or other arrays, which allows you to create complex data
structures, such as arrays of objects and arrays of arrays.

JavaScript arrays are /zero-based/ and use 32-bit indexes: the index of the
first element is 0, and the highest possible index is 4294967294 (2^32−2), for
a maximum array size of 4,294,967,295 elements.

#+cindex:sparse arrays
JavaScript arrays are /dynamic/: they grow or shrink as needed and there is no
need to declare a fixed size for the array when you create it or to reallocate
it when the size changes.  JavaScript arrays may be /sparse/: the elements need
not have contiguous indexes and there may be gaps.

#+cindex:length property
Every JavaScript array has a length property.  For nonsparse arrays, this
property specifies the number of elements in the array.  For sparse arrays,
length is larger than the index of all elements.

JavaScript arrays are a specialized form of JavaScript object, and array
indexes are really little more than property names that happen to be integers.

Arrays inherit properties from =Array.prototype=, which defines a rich set of
array manipulation methods

**** Creating Arrays
**** Reading and Writing Array Elements
**** Sparse Arrays
**** Array Length
**** Adding and Deleting Array Elements
**** Iterating Arrays
**** Multidimensional Arrays
**** Array Methods
***** join()
***** reverse()
***** sort()
***** concat()
***** slice()
***** splice()
***** push() and pop()
***** unshift() and shift()
***** toString() and toLocaleString()
**** ECMAScript 5 Array Methods
***** forEach()
***** map()
***** filter()
***** every() and some()
***** reduce() and reduceRight()
***** indexOf() and lastIndex()
**** Array Type
**** Array-Like Objects
**** Strings as Arrays
*** Functions

**** Function Properties---Methods---Constructor
Functions are values.

- ~typeof~ operator :: returns the string =function=.

- functions as objects :: functions are really a specialized kind of JavaScript
     object; they can have properties and methods.

- =Function()= constructor :: to create new function objects

***** Function =length= Property
#+cindex:@code{arguments.length}
#+cindex:@code{length} property, functin
=arguments.length= property specifies the number of arguments that were passed
to the function.

#+cindex:arity of function
The =length= property of a function itself, however, has a different meaning.
This read-only property returns the arity of the function---the number of
parameters it declares in its parameter list, which is usually the number of
arguments that the function expects.

***** The =prototype= Property
#+cindex:Function @code{prototype} property
Every function has a =prototype= property that refers to an object known as the
/prototype object/.  Every function has a different prototype object.  When a
function is used as a constructor, the newly created object inherits properties
from the prototype object.

***** The ~call()~ and ~apply()~ Methods
#+cindex:@code{call()}
#+cindex:@code{apply()}
#+cindex:indirect invocation
#+cindex:invocation context
#+cindex:@code{this} keyword
~call()~ and ~apply()~ allow you to indirectly invoke a function as if it were
a method of some other object.  The first argument to both ~call()~ and
~apply()~ is the object on which the function is to be invoked; this argument
is the /invocation context/ and becomes the value of the ~this~ keyword within
the body of the function.

#+cindex:ECMAScript 3
In ECMAScript 3 and non-strict mode, a value of =null= or =undefined= is
replaced with the global object and a primitive value is replaced with the
corresponding wrapper object.

#+cindex:ECMAScript 5
#+cindex:strict mode
In ECMAScript 5 strict mode the first argument to ~call()~ or ~apply()~ becomes
the value of ~this~, even if it is a primitive value or =null= or =undefined=.

****** Monkey Patching Functions

#+cindex:array-like objects
~apply()~ works with array-like objects as well as true arrays.  In particular,
you can invoke a function with the same arguments as the current function by
passing the =arguments= array directly to ~apply()~.  The following code
demonstrates:

#+cindex:@code{trace()} function
#+cindex:monkey patching
#+caption:A Trace Function through Monkey Patching
#+name:trace-function
#+begin_src js -n
  // Replace the method named m of the object o with a version that logs
  // messages before and after invoking the original method.
  function trace(o, m) {
      var original = o[m]; // Remember original method in the closure.
      o[m] = function() { // Now define the new method.
          console.log(new Date(), "Entering:", m); // Log message.
          var result = original.apply(this, arguments); // Invoke original.
          console.log(new Date(), "Exiting:", m); // Log message.
          return result; // Return result.
      };
  }
#+end_src

This ~trace()~ function is passed an object and a method name.  It replaces the
specified method with a new method that “wraps” additional functionality around
the original method.  This kind of dynamic alteration of existing methods is
sometimes called “monkey-patching.”

***** The ~bind()~ Method
#+cindex:ECMAScript 5
#+cindex:ECMAScript 3
#+cindex:@code{bind()} method
The ~bind()~ method was added in ECMAScript 5, but it is easy to simulate in
ECMAScript 3.  The primary purpose of ~bind()~ is to bind a function to an
object.

When you invoke the ~bind()~ method on a function ~f~ and pass an object =o=,
the method returns a new function.  Invoking the new function (as a function)
invokes the original function ~f~ as a method of =o=.  Any arguments you pass
to the new function are passed to the original function.

#+begin_src js -n
function f(y) {return this.x + y}
var o = { x:1 }
var g = f.bind(o);
g(2) // => 3
#+end_src

A ~bind()~ method for ECMAScript 3 is:

#+caption:A ~bind()~ Method for ECMAScript 3
#+name:bind-for-ES3
#+begin_src js -n
  // Return a function that invokes f as a method of o, passing all its arguments.
  function bind(f, o) {
      if (f.bind) return f.bind(o); // Use the bind method, if there is one
      else return function() {      // Otherwise, bind it like this
          return f.apply(o, arguments);
      };
  }
#+end_src

The ~bind()~ method defined by ECMAScript 5 does have some features that cannot
be simulated with the ECMAScript 3 code shown below.  

1 First, the true bind() method returns a function object with its length
  property properly set to the arity of the bound function minus the number of
  bound arguments (but not less than zero).

2. Second, the ECMAScript 5 ~bind()~ method can be used for partial application
   of constructor functions.

   If the function returned by ~bind()~ is used as a constructor, the ~this~
   passed to ~bind()~ is ignored, and the original function is invoked as a
   constructor, with some arguments already bound.

   Functions returned by the ~bind()~ method do not have a =prototype= property
   (the prototype property of regular functions cannot be deleted) and objects
   created when these bound functions are used as constructors inherit from the
   prototype of the original, unbound constructor.

****** Partial Application using the ~bind()~ Method

#+cindex:ECMAScript 5
#+cindex:partial application, @code{bind()}
The ECMAScript 5 ~bind()~ method also performs partial application: any
arguments you pass to ~bind()~ after the first are bound along with the this
value.

#+cindex:currying
#+cindex:functional programming
Partial application is a common technique in functional programming and is
sometimes called /currying/.

#+caption:Examples of Currying using the ~bind()~ Method
#+name:currying-using-bind
#+begin_src js -n
  var sum = function(x,y) { return x + y }; // Return the sum of 2 args
  // Create a new function like sum, but with the this value bound to null
  // and the 1st argument bound to 1. This new function expects just one arg.
  var succ = sum.bind(null, 1);
  succ(2) // => 3: x is bound to 1, and we pass 2 for the y argument

  function f(y,z) { return this.x + y + z }; // Another function that adds
  var g = f.bind({x:1}, 2); // Bind this and y
  g(3) // => 6: this.x is bound to 1, y is bound to 2 and z is 3
#+end_src

****** Partial Application in ECMAScript 3

We can bind the this value and perform partial application in ECMAScript 3. The
standard bind() method can be simulated with code like this in
[[function-bind-for-es3]].  Note that we save this method as
~Function.prototype.bind~, so that all function objects inherit it.

#+caption:A Function.bind() method for ECMAScript 3
#+name:function-bind-for-es3
#+begin_src js -n
  if (!Function.prototype.bind) {
      Function.prototype.bind = function(o /*, args */) {
          // Save the this and arguments values into variables so we can
          // use them in the nested function below.
          var self = this,
              boundArgs = arguments;
          // The return value of the bind() method is a function
          return function() {
              // Build up an argument list, starting with any args passed
              // to bind after the first one, and follow those with all args
              // passed to this function.
              var args = [], i;
              for(i = 1; i < boundArgs.length; i++) args.push(boundArgs[i]);
              for(i = 0; i < arguments.length; i++) args.push(arguments[i]);

              // Now invoke self as a method of o, with those arguments
              return self.apply(o, args);
          }
      }
  }
#+end_src


Notice that the function returned by this bind() method:

- is a closure
- that uses the variables
  - ~self~ and
  - ~boundArgs~
  - declared in the outer function
- even though that inner function
  - has been returned from the outer function and
  - is invoked after the outer function has returned

***** The ~toString()~ Method

***** The Function() Constructor

***** Callable Objects

**** Functional Programming
*** Classes and Modules
#+cindex:prototypes
**** Classes and Prototypes
- class ::
           a set of objects that inherit properties from the same prototype
           object

- prototype object ::
     the central feature of a class.  In Example 6-1 we defined an inherit()
     function that returns a newly created object that in- herits from a
     specified prototype object. If we define a prototype object, and then use
     inherit() to create objects that inherit from it, we have defined a
     JavaScript class.

- initialization ::
                    Usually, the instances of a class require further
                    initialization, and it is common to define a function that
                    creates and initializes the new object.

**** Classes and Constructors
**** Java-Style Classes in JavaScript
**** Augmenting Classes
**** Classes and Types
**** Object-Oriented Techniques
**** Subclasses
**** Classes in ES5
**** Modules
*** Regular Expressions

*** JavaScript Subsets and Extensions

*** Server-Side JavaScript

** Client-Side JavaScript

*** JavaScript in Web Browsers

*** The Window Object

*** Scripting Documents

*** Scripting CSS

*** Handling Events

*** Scripted HTTP

*** The jQuery Library

*** Client-Side Storage

*** Scripted Media and Graphics

*** HTML5 APIs

** Core API Reference

** Client-Side JavaScript Reference
* Professional JavaScript for Web Developers
- by Nicholas Zakas
- 3rd Edition 2012

** Object-Oriented Programming
#+cindex:object-oriented programming
#+cindex:classes
#+cindex:object
#+cindex:hash tables
#+cindex:reference type
ECMAScript has no concept of classes, and therefore objects are different than
in class-based languages.  An object in ECMAScript is an array of values in no
particular order.  Each property or method is identified by a name that is
mapped to a value.  ECMAScript objects can therefore be thought of as hash
tables: nothing more than a grouping of name-value pairs where the value may be
data or a function.  Each object is created based on a reference type, either
one of the native types or a developer-defined type.

*** Understanding Objects
#+cindex:object, create, new @code{Object}
#+cindex:@code{new Object}
The simplest way to create a custom object is to create a new instance of
=Object= and add properties and methods to it.

#+begin_src js -n
var person = new Object();
person.nam = "John";
person.age = 29;
person.job = "Engineer";
person.sayName = function() {
    console.log(this.name);
}
#+end_src

This example creates an object called =person= that has three properties
(=name=, =age=, and =job=) and one method (~sayName()~).  Early JavaScript
developers used this pattern frequently to create new objects.

#+cindex:object literals
#+cindex:object, create, object literal
A few years later, object literals became the preferred pattern for creating
such objects. The previous example can be rewritten using object literal
notation as follows:

#+begin_src js -n
  var person = {
      name: "John",
      age: 29,
      job: "Engineer",
      sayName: function() {
          console.log(this.name);
      }
  }
#+end_src

The =person= object in this example is equivalent to the =person= object in the
prior example, with all the same properties and methods.  These properties are
all created with certain characteristics that define their behavior in
JavaScript.

**** Types of Properties
#+cindex:ECMAScript 5
#+cindex:ECMAScript 3
ECMAScript 5 describes characteristics of properties through the use of
internal-only attributes.  Note that ECMASript 3 uses different definitions.
These attributes are defined by the specification for implementation in
JavaScript engines, and as such, these attributes are not directly accessible
in JavaScript.

To indicate that an attribute is internal, surround the attribute name with two
pairs of square brackets, such as =[ [Enumerable] ]=

There are two types of properties:

- data properties

- accessor properties

***** Data Properties
#+cindex:data properties
Data properties contain a single location for a data value.  Values are read
from and written to this location.

Data properties have four attributes describing their behavior:
#+cindex:attributes
#+cindex:configurable
#+cindex:enumerable
#+cindex:writable
#+cindex:value

- =[ [Configurable] ]= :: Indicates if the property may be redefined by
     removing the property via delete, changing the property’s attributes, or
     changing the property into an accessor property.  By default, this is true
     for all properties defined directly on an object.  Once a property has
     been defined as nonconfigurable, it cannot become configurable again.

- =[ [Enumerable] ]= :: Indicates if the property will be returned in a
     =for-in= loop.  By default, this is true for all properties defined
     directly on an object,

- =[ [Writable] ]= :: Indicates if the property’s value can be changed.  By
     default, this is true for all properties defined directly on an object.

- =[ [Value] ]= :: Contains the actual data value for the property.  This is
                   the location from which the property’s value is read and the
                   location to which new values are saved.  The default value
                   for this attribute is =undefined=.


When a property is explicitly added to an object, the attributes are all set to
true while the value attribute is set to the assigned value.

{{{heading(Object.defineProperty())}}

#+cindex:@code{Object.defineProperty()} method
To change any of the default property attributes, you must use the ECMAScript 5
~Object.defineProperty()~ method.  This method accepts three arguments:

1. the object on which the property should be added or modified,

2. the name of the property, and

3. a descriptor object.


When you are using ~Object.defineProperty()~, the values for =configurable=,
=enumerable=, and =writable= default to =false= unless otherwise specified.

{{{heading(Descriptor Object)}}}

#+cindex:descriptor object
The properties on the descriptor object match the attribute names:

- =configurable=

- =enumerable=

- =writable=

- =value=

***** Accessor Properties
#+cindex:accessor properties
#+cindex:getter function
#+cindex:setter function
Accessor properties do not contain a data value.  Instead, they contain a
combination of a getter function and a setter function.  When an accessor
property is read from, the getter function is called, and it’s the function’s
responsibility to return a valid value; when an accessor property is written
to, a function is called with the new value, and that function must decide how
to react to the data.

Accessor properties have four attributes:

1. =[ [Configurable] ]= :: same

2. =[ [Enumerable] ]= :: same

3. =[ [Get] ]= :: The function to call when the property is read from. The
                  default value is =undefined=.  Assigning just a getter means
                  that the property cannot be written to and attempts to do so
                  will be ignored.  In strict mode, trying to write to a
                  property with only a getter throws an error.

4. =[ [Set] ]= :: The function to call when the property is written to. The
                  default value is =undefined=.  Likewise, a property with only
                  a setter cannot be read and will return the value undefined
                  in nonstrict mode, while doing so throws an error in strict
                  mode.


It is not possible to define an accessor property explicitly; you must use
~Object.defineProperty()~.

**** Defining Multiple Properties
#+cindex:@code{Object.defineProperties()} method
ECMAScript 5 provides the ~Object.defineProperties()~ method to define multiple
properties using multiple descriptors at once.  There are two arguments: 

- the object on which to add or modify the properties and

- an object whose property names correspond to the properties’ names to add or
  modify.

**** Reading Property Attributes
#+cindex:@code{Object.getOwnPropertyDescriptor()} method
It’s also possible to retrieve the property descriptor for a given property by
using the ECMAScript 5 ~Object.getOwnPropertyDescriptor()~ method.  This method
accepts two arguments: 

- the object on which the property resides and

- the name of the property whose descriptor should be retrieved.


The return value is an object with properties for the attributes.

*** Object Creation
#+cindex:object creation patterns

**** The Factory Pattern
#+cindex:factory pattern
The factory pattern is a well-known design pattern used in software engineering
to abstract away the process of creating specific objects.  With no way to
define classes in ECMAScript, developers created functions to encapsulate the
creation of objects with specific interfaces.

#+caption:Factory Pattern
#+name:factory-pattern
#+begin_src js -n
  function createPerson(name, age, job){
      var o = new Object();
      o.name = name;
      o.age = age;
      o.job = job;
      o.sayName = function(){
          alert(this.name);
      };
      return o;
  }
#+end_src

Here, the function ~createPerson()~ accepts arguments with which to build an
object with all of the necessary information to represent a Person object.  The
function can be called any number of times with different arguments and will
still return an object that has three properties and one method.

Though this solved the problem of creating multiple similar objects, the
factory pattern didn’t address the issue of object identification (what type of
object an object is).  As JavaScript continued to evolve, a new pattern
emerged.

**** The Constructor Pattern
#+cindex:constructors
#+cindex:native constructors
#+cindex:constructor pattern
Constructors are simply functions that create objects.  Constructors in
ECMAScript are used to create specific types of objects.  There are native
constructors, such as =Object= and =Array=, which are available automatically
in the execution environment at runtime.

#+cindex:custom constructors
It is also possible to define custom constructors that define properties and
methods for your own type of object.  The previous example can be rewritten
using the constructor pattern as the following:

#+caption:Constructor Pattern
#+name:constructor pattern
#+begin_src js -n
  function Person(name, age, job) {
      this.name = name;
      this.age = age;
      this.job = job;
      this.sayName = function(){
          alert(this.name);
      };
  }
#+end_src

In this example, the ~Person()~ function takes the place of the factory
~createPerson()~ function.  Here,

- There is no object being created explicitly.

- The properties and method are assigned directly onto the ~this~ object.

- There is no ~return~ statement.

- By convention, constructor functions always begin with an uppercase letter,
  whereas non-constructor functions begin with a lowercase letter.


#+cindex:@code{new} operator
To create a new instance of Person, use the ~new~ operator.  Calling a
constructor in this manner essentially causes the following four steps to be
taken:

1. Create a new object.

2. Assign the ~this~ value of the constructor to the new object (so this points
   to the new object).

3. Execute the code inside the constructor (adds properties to the new object).

   #+cindex:constructor property
4. Return the new object.  Each of these new objects has a =constructor=
   property that points back to the constructor function.

   : var new_object = new New_Object_Constructor_Function
   : new_object.constructor == New_Object_Constructor_Function


#+cindex:constructor property
#+cindex:@code{instanceof} operator
#+cindex:object type
#+cindex:type, object
The constructor property was originally intended for use in identifying the
object type.  However, the ~instanceof~ operator is considered to be a safer way
of determining type.

: new_object instanceof New_Object_Constructor_Function // true
: new_object instanceof Object // true

Defining your own constructors ensures that instances can be identified as a
particular type later on, which is a great advantage over the factory pattern.

***** Constructors as Functions
#+cindex:constructor as function
The only difference between constructor functions and other functions is the
way in which they are called.  Any function that is called with the ~new~
operator acts as a constructor, whereas any function called without it acts
just as you would expect a normal function call to act.

***** Problems with Constructors
The major downside to constructors is that methods are created once for each
instance.  It doesn’t make sense to have two instances of Function that do the
same thing, especially when the this object makes it possible to avoid binding
functions to particular objects until runtime.

**** The Prototype Pattern
#+cindex:prototype property
#+cindex:reference type
#+cindex:type
Each function is created with a prototype property, which is an object
containing properties and methods that should be available to instances of a
particular reference type.  This object is literally a prototype for the object
to be created once the constructor is called.  The benefit of using the
prototype is that all of its properties and methods are shared among object
instances.  Instead of assigning object information in the constructor, they
can be assigned directly to the prototype.

#+BEGIN_SRC js -n
function Person(){ }
Person.prototype.name = “Nicholas”;
Person.prototype.age = 29;
Person.prototype.job = “Software Engineer”;
Person.prototype.sayName = function(){
    console.log(this.name);
}

var person1 = new Person();
person1.sayName(); //”Nicholas”

var person2 = new Person();
person2.sayName(); //”Nicholas”

alert(person1.sayName == person2.sayName); //true
#+END_SRC

Here, the properties and the ~sayName()~ method are added directly to the
prototype property of =Person=, leaving the constructor empty.  However, it’s
still possible to call the constructor to create a new object and have the
properties and methods present. Unlike the constructor pattern, the properties
and methods are all shared among instances, so person1 and person2 are both
accessing the same set of properties and the same ~sayName()~ function.

***** How Prototypes Work
#+cindex:prototypes
#+cindex:prototype property
Whenever a function is created, its =prototype= property is also created
according to a specific set of rules.

{{{heading(Constructor Property)}}}

#+cindex:constructor property
By default, all prototypes automatically get a property called =constructor=
that points back to the function on which it is a property.  In the previous
example, for instance, =Person.prototype.constructor= points to =Person=.

When defining a custom constructor, the prototype gets the =constructor=
property only by default; all other methods are inherited from =Object=.

{{{heading(Prototype Attribute)}}}

Each time the constructor is called to create a new instance, that instance has
an internal pointer to the constructor’s prototype.  In ECMA-262 fifth edition,
this is called =[ [Prototype] ]=.  There is no standard way to access =[
[Prototype] ]= from script.

The important thing to understand is that a direct link exists between the
instance and the constructor’s prototype but not between the instance and the
constructor.

#+caption:Constructor Function Prototype
#+name:constructor-function-prototype
[[./figs/constructor-function-prototype.png]]

#+cindex:lookup procedure
Note that =Person.prototype= points to the prototype object but
=Person.prototype.constructor= points back to =Person=.  The prototype contains
the =constructor= property and the other properties that were added.  Each
instance of =Person= has an internal property ( =[ [Prototype] ]= ) that points
to =Person.prototype=.  There is no direct relationship with the constructor.
Also note that even though neither of these instances have properties or
methods, ~person1.sayName()~ works.  This is due to the lookup procedure for
object properties.

{{{heading(isPrototypeOf Method)}}}

#+cindex:@code{isPrototypeOf()} method
Even though =[ [Prototype] ]= is not accessible in all implementations, the
~isPrototypeOf()~ method can be used to determine if this relationship exists
between objects.  The ~isPrototypeOf()~ method checks if an object exists in
another object's prototype chain.

: Person.prototype.isPrototypeOf(person1) // true

{{{heading(Object.getPrototypeOf Method)}}}

#+cindex:@code{Object.getPrototypeOf()} method
ECMAScript 5 adds a new method called ~Object.getPrototypeOf()~, which returns
the value of =[ [Prototype] ]= in all supporting implementations.  Using
~Object.getPrototypeOf()~, you are able to retrieve an object’s prototype
easily, which becomes important once you want to implement inheritance using
the prototype.

{{{heading(Prototype Lookup Procedure)}}}

#+cindex:lookup procedure
Whenever a property is accessed for reading on an object, a search is started
to find a property with that name. The search begins on the object instance
itself. If a property with the given name is found on the instance, then that
value is returned; if the property is not found, then the search continues up
the pointer to the prototype, and the prototype is searched for a property with
the same name. If the property is found on the prototype, then that value is
returned.  This is how prototypes are used to share properties and methods
among multiple object instances.

Although it’s possible to read values on the prototype from object instances,
it is not possible to overwrite them.  If you add a property to an instance
that has the same name as a property on the prototype, you create the property
on the instance, which then masks the property on the prototype.  The only way
to regain access to the prototype property is to delete the instance property.

{{{heading(hasOwnProperty Method)}}}

#+cindex:@code{hasOwnProperty()} method
The ~hasOwnProperty()~ method determines if a property exists on the instance
or on the prototype.  This method, which is inherited from =Object=, returns
=true= only if a property of the given name exists on the object instance.

***** Prototypes and the ~in~ Operator
#+cindex:@code{in} operator
#+cindex:@code{for-in} loop
#+cindex:enumerable properties
There are two ways to use the ~in~ operator:

- on its own :: When used on its own, the ~in~ operator returns =true= when a
                property of the given name is accessible by the object, which
                is to say that the property may exist on the instance or on the
                prototype.

- as a =for-in= loop :: When using a =for-in= loop, all properties that are
     accessible by the object and can be enumerated will be returned, which
     includes properties both on the instance and on the prototype.


{{{heading(Object.keys Method)}}}

#+cindex:@code{Object.keys()} method
To retrieve a list of all enumerable instance properties on an object, you can
use the ECMAScript 5 ~Object.keys()~ method, which accepts an object as its
argument and returns an array of strings containing the names of all enumerable
properties.

{{{heading(Object.getOwnPropertyNames Method)}}}

#+cindex:@code{Object.getOwnPropertyNames()} method
If you’d like a list of all instance properties, whether enumerable or not, you
can use ~Object.getOwnPropertyNames()~ in the same way.

***** Dynamic Nature of Prototypes
Since the process of looking up values on a prototype is a search, changes made
to the prototype at any point are immediately reflected on instances, even the
instances that existed before the change was made.  Although properties and
methods may be added to the prototype at any time, and they are reflected
instantly by all object instances, you cannot overwrite the entire prototype
and expect the same behavior.  The =[ [Prototype] ]= pointer is assigned when
the constructor is called, so changing the prototype to a different object
severs the tie between the constructor and the original prototype.

***** Native Object Prototypes
The prototype pattern is important not just for defining custom types but also
because it is the pattern used to implement all of the native reference types.
Each of these (including =Object=, =Array=, =String=, and so on) has its
methods defined on the constructor’s prototype.

Through native object prototypes, it’s possible to get references to all of the
default methods and to define new methods.  Native object prototypes can be
modified just like custom object prototypes, so methods can be added at any
time.

***** Problems with Prototypes
It negates the ability to pass initialization arguments into the constructor,
meaning that all instances get the same property values by default.

The main problem comes with their shared nature.  All properties on the
prototype are shared among instances, which is ideal for functions.  Properties
that contain primitive values also tend to work well.

The real problem occurs when a property contains a reference value.

**** Combination Constructor-Prototype Pattern

**** Dynamic Prototype Pattern

**** Parasitic Prototype Pattern

**** Durable Constructor Pattern

*** Inheritance

**** Prototype Chaining

**** Constructor Stealing

**** Combination Inheritance

**** Prototypal Inheritance

**** Parasitic Inheritance

**** Parasitic Combination Inheritance

*** Summary of OO Programming
* Secrets of the JavaScript Ninja
:PROPERTIES:
:Author:   John Resig
:Author+:  Bear Bibeault
:Published: 2013
:Publisher: Manning Publications Co.
:ISBN:     978-1-933988-69-6
:Pages:    392
:URI:      https://www.manning.com/books/secrets-of-the-javascript-ninja
:END:

- https://livebook.manning.com/#!/book/secrets-of-the-javascript-ninja/table-of-contents/

** Front Matter
:PROPERTIES:
:unnumbered: t
:END:
#+texinfo:@insertcopying
*** Copying
:PROPERTIES:
:copying:  t
:unnumbered: t
:END:
\copy2013 by Manning Publications Co. All rights reserved.

#+HTML:<pre>
#+begin_display
Manning Publications Co.
20 Baldwin Road
PO Box 261
Shelter Island, NY 11964
#+end_display
#+HTML:</pre>

*** Preface

{{{heading(In-Depth Coverage Topics)}}}

A real need for in-depth coverage of the most important parts of the JavaScript
language:
#+cindex:functions
- functions
  #+cindex:closures
- closures
  #+cindex:protyptes
- prototypes
  #+cindex:cross-browser code
- cross-browser code


{{{heading(The Fundamentals)}}}

There isn’t any point to diving into new technologies if you don’t have a
proper understanding of the fundamental characteristics of the JavaScript
language.  The reality is that most development needs to make sure that code
continues to work in the majority of browsers and for the majority of potential
users.

{{{heading(jQuery)}}}

#+cindex:jQuery
Perhaps the largest change that came to jQuery as a result of writing this book
was a complete overhaul from using browser-specific sniffing to using feature
detection at the core of the library.  This has enabled jQuery to be used
almost indefinitely, without assuming that browsers would always have specific
bugs or be missing specific features.

#+cindex:cross-browser capabilities
Using the techniques outlined in this book, jQuery’s cross-browser capabilities
provide a fairly solid guarantee that code written with jQuery will work in a
maximum number of browser environments.  This guarantee has led to explosive
growth in jQuery over the past four years, with it now being used in over 57%
of the top 10,000 websites on the Internet, according to BuiltWith.com.

{{{heading(New JS-Based Languages)}}}

#+cindex:CoffeeScript
#+cindex:Processing.js
#+cindex:ECMAScript specification
There are now a number of active programming languages that are built on top
of, or compiled to, JavaScript, such as CoffeeScript and Processing.js.  These
languages require complex language parsing, code evaluation, and scope
manipulation in order to work effectively.  Although dynamic code evaluation
has been maligned due to its complexity and potential for security issues,
without it we wouldn’t have had the CoffeeScript programming language, which
has gone on to influence the upcoming ECMAScript specification itself.

{{{heading(The Future)}}}

#+cindex:browser APIs
The future for browser development continues to be very strong, and it’s
largely due to the features encapsulated in JavaScript and in the browser APIs.
Having a solid grasp of the most crucial parts of the JavaScript language,
combined with a desire for writing code that’ll work in many browsers, will
enable you to create code that’s elegant, fast, and ubiquitous.

*** About this Book
Web developers need to have a sound grasp of the language that brings life to
web applications.

#+cindex:Rhino
#+cindex:V8
#+cindex:Node.js
JavaScript isn’t just for browsers anymore.  The language has knocked down the
walls of the browser and is being used on the server in engines such as Rhino
and V8, and in frameworks like Node.js.

Although this book is primarily focused on JavaScript for web applications, the
fundamentals of the language presented in [[*Part 2---Apprentice Training][Part 2]] of this book are applicable
across the board.

It’s now more important than ever that they grasp its fundamentals, so that
they can become true ninjas of the language.

{{{heading(Intended Audience)}}}

#+cindex:audience
This book is aimed at web developers who already have at least a basic grasp of
JavaScript.
- You should understand the basic structure of JavaScript statements and
- how they work to create straightforward on-page scripts.
- You don’t need to be an advanced user of the language---that’s what this book
  is for---but
- you shouldn’t be a rank novice.
- You should also have a working knowledge of HTML and CSS.
- You should know the basics of putting a web page together.


{{{heading(Recommended Prerequisite Materials)}}}

#+cindex:recommended reading
#+cindex:prerequisite reading
#+cindex:JavaScript: The Definitive Guide
#+cindex:Flanagan, David
#+cindex:JavaScript: The Good Parts
#+cindex:Crockford, Douglas
#+cindex:Head First JavaScript
#+cindex:Morrison, Michael
- /JavaScript: The Definitive Guide/ by David Flanagan
- /JavaScript: The Good Parts/ by Douglas Crockford
- /Head First JavaScript/ by Michael Morrison.
- /Head First JavaScript Programming/ by Elizabeth Robson and Eric Freeman
  (This book replaces /Head First JavaScript/)

**** Roadmap
This book is organized to take you from an apprentice to a ninja in four parts.

1. [[*Part 1---Preparing for Training][Part 1]] introduces the topic and some tools we’ll need as we progress through
   the rest of the book.

   #+cindex:advanced web applications, problems
   - [[*Enter the Ninja][Chapter 1]] introduces us to the challenges that we face as writers of
     advanced web applications.  It presents some of the problems that the
     proliferation of browsers creates, and suggests best current practices
     that we should follow when developing our applications, including testing
     and performance analysis.

     #+cindex:testing
     #+cindex:test tools
     #+cindex:assert
   - [[*Arming with Testing and Debugging][Chapter 2]] discusses testing, taking a look at the current state of testing
     and test tools.  It also introduces a small but powerful testing concept,
     the ~assert~, which will be used extensively throughout the remainder of
     the book to make sure that our code does what we think it should be doing
     (or sometimes to prove that it doesn’t!).

     #+cindex:JavaScript fundamentals
2. [[*Part 2---Apprentice Training][Part 2]] focuses on JavaScript fundamentals: aspects of the language that you
   take for granted but aren’t really sure how they work.  This may be the most
   important part of the book, and even if it’s all you read, you’ll come away
   with a much sounder understanding of JavaScript, the language.

   #+cindex:functions
   #+cindex:functional language
   - Armed with these tools, [[*Functions are Fundamental][chapter 3]] begins our foray into the fundamentals
     of the language, starting, perhaps to your surprise, with a thorough
     examination of the function as defined by JavaScript.  Although you might
     have expected the object to be the target of first focus, it’s a solid
     understanding of the function, and JavaScript as a functional language,
     that begins our transformation from run-of-the-mill JavaScript coders to
     JavaScript ninjas!

     #+cindex:recursion
     #+cindex:variable argument lists
     #+cindex:overload functions
     #+cindex:method overloading
     #+cindex:functional programming
   - Not being done with functions quite yet, [[*Wielding Functions][chapter 4]] takes the fundamentals
     we learned in chapter 3 and applies them to problems we face in creating
     our applications.  We’ll explore recursion—not only for its own sake, but
     because we can learn a lot more about functions through scrutinizing
     it---and we’ll learn how the functional programming aspects of JavaScript
     can be applied to not only make our code elegant, but also more robust and
     succinct.  We’ll learn ways to deal with variable argument lists, and ways
     to overload functions in a language that doesn’t natively support the
     object-oriented concept of method overloading.

     #+cindex:closures
     #+cindex:functional programming
     #+cindex:scope
   - One of the most important concepts you can take away from this book is the
     subject of [[*Object-orientation with Prototypes][chapter 5]]: closures.  A key concept in functional programming,
     closures allow us to exert fine-grained control over the scope of objects
     that we declare and create in our programs.  The control of these scopes
     is the key factor in writing code worthy of a ninja.  Even if you stop
     reading after this chapter (but we hope that you don’t), you’ll be a far
     better JavaScript developer than when you started.

     #+cindex:objects
     #+cindex:prototype property
     #+cindex:functions and the prototype property
   - Objects are finally addressed in [[*Object-orientation with Prototypes][chapter 6]], where we learn how patterns of
     objects can be created through the prototype property of the function, and
     we’ll learn how objects are tied to functions for their definitions---one
     of the many reasons we discussed functions first.

     #+cindex:regular expressions
   - [[*Wrangling Regular Expressions][Chapter 7]] focuses on the regular expression, an often-overlooked feature
     of the language that can do the work of scores of lines of code when used
     correctly.  We’ll learn how to construct and use regular expressions and
     how to solve some recurring problems elegantly, using regular expressions
     and the methods that work with them.

     #+cindex:timers
     #+cindex:intervals
     #+cindex:single-threaded model
     #+cindex:HTML5
     #+cindex:web workers
   - Part 2 on language fundamentals closes out with [[*Taming Threads and Timers][chapter 8]], in which we
     learn how timers and intervals work in the single-threaded nature of
     JavaScript.  HTML5 promises to bring us relief from the confines of the
     single thread with web workers, but most browsers aren’t quite there yet,
     and virtually all of the existing JavaScript code depends upon a good
     understanding of JavaScript’s single-threaded model.

     #+cindex:problems, solve
3. In [[*Part 3---Ninja Training][part 3]], we dive into using the fundamentals that we learned in part 2 to
   solve knotty problems that the browsers throw at us.

   #+cindex:runtime code evaluation
   #+cindex:evaluate code while running
   #+cindex:JSON evaluation
   #+cindex:metalanguages
   #+cindex:domain-specific languages
   #+cindex:compression
   #+cindex:obfuscation
   #+cindex:aspect-oriented programming
   - Part 3 opens with [[*Ninja Alchemy - Runtime Code Evaluation][chapter 9]], in which we open the black box of
     JavaScript’s runtime code evaluation.  We’ll look at various ways to
     evaluate code on the fly, including how to do so safely and in the scope
     of our choosing.  Real-world examples, such as JSON evaluation,
     metalanguages (a.k.a. domain-specific languages), compression and
     obfuscation, and even aspect-oriented programming, are discussed.

     #+cindex:with statement
   - In [[*=with= Statements][chapter 10]], we examine the controversial ~with~ statement, which is
     used to shorten references within a scope.  Whether you are a fan or
     detractor of ~with~, it exists in a lot of code in the wild, and you
     should understand it regardless of whether you think it’s the bomb or an
     abomination.

     #+cindex:cross-browser issues
     #+cindex:browser differences
     #+cindex:browser bugs,fixes
     #+cindex:browers, missing features
     #+cindex:feature simulation
     #+cindex:object detection
   - Dealing with cross-browser issues is the subject of [[*Developing Cross-Browser Strategies][chapter 11]].  We
     examine the five key development concerns with regard to these issues:
     browser differences, bugs and bug fixes, external code and markup, missing
     features, and regressions.  Strategies such as feature simulation and
     object detection are discussed at length to help us deal with these
     cross-browser challenges.

     #+cindex:element attributes, properties
     #+cindex:attributes
     #+cindex:properties
     #+cindex:styles
   - Handling element attributes, properties, and styles is the focus of
     [[*Cutting Through Attributes-Properties-and CSS][chapter 12]].  While the differences in how the various browsers handle these
     aspects of elements are slowly converging over time, there still exists a
     number of knotty problems that this chapter describes how to solve.

     #+cindex:event handling
     #+cindex:custom events
     #+cindex:event delegation
   - Part 3 concludes in [[*Surviving Events][chapter 13]] with a thorough investigation of event
     handling in the browsers and ways to create a unified subsystem that
     handles events in a browser-agnostic manner.  This includes adding features
     not provided by the browsers, such as custom events and event delegation.

   #+cindex:advanced topics
   #+cindex:jQuery library
4. [[*Part 4---Master Training][Part 4]] wraps up the book with a look at advanced topics focusing on lessons
   learned from the creation of advanced JavaScript libraries, such as jQuery.

   #+cindex:DOM manipulation APIs
   #+cindex:Document Object Model
   #+cindex:manipulate DOM at runtime
   #+cindex:injecting elements into the DOM
   - In part 4 we pick up the pace and delve deeply into advanced topics taken
     from the heart of JavaScript libraries such as jQuery.  [[*Manipulating the DOM][Chapter 14]]
     discusses how DOM manipulation APIs can be constructed to manipulate the
     Document Object Model at runtime, including the Gordian knot of injecting
     new elements into the DOM.

     #+cindex:CSS selector engines
   - Finally, in [[*CSS Selector Engines][chapter 15]], we discuss how CSS selector engines are
     constructed and the different ways in which they parse and evaluate
     selectors.  Not for the faint of heart, this chapter, but it’s a worthy
     final test of your ninja-hood.

**** Code Downloads
#+cindex:source code
#+cindex:download source code
Source code for all the working examples in this book (along with some extras
that never made it into the text) is available for [[https://www.manning.com/SecretsoftheJavaScriptNinja][download from the book’s web
page]].

#+cindex:Apache server
The code examples for this book are organized by chapter, with separate folders
for each chapter.  The layout is ready to be served by a local web server, such
as the Apache HTTP Server.  Simply unzip the downloaded code into a folder of
your choice and make that folder the document root of the application.  Most of
the examples don’t require the presence of a web server at all and can be
loaded directly into a browser for execution.

*** About the Authors

**** John Resig

#+cindex:Resig, John
#+cindex:Khan Academy
- Dean of Computer Science at Khan Academy
  - Khan Academy’s goal is to create excellent educational resources that are
    freely available for all to learn from
  #+cindex:jQuery library
- creator of the jQuery JavaScript library
  #+cindex:open source
- also created a number of other open source utilities and projects, including
    #+cindex:Processing.js
  - Processing.js (a port of the Processing language to JavaScript)
    #+cindex:QUnit
    #+cindex:test suite, QUnit
  - QUnit (a test suite for testing JavaScript code)
    #+cindex:TestSwarm
    #+cindex:testing, distributed
  - TestSwarm (a platform for distributed JavaScript testing)

**** Bear Bibeault

#+cindex:Bibeault, Bear
#+cindex:books
Bear is the author of a number of other Manning books:
#+cindex:jQuery in Action
- /jQuery in Action/ (first and second editions)
  #+cindex:Ajax in Practice
- /Ajax in Practice/
  #+cindex:Prototype and Scriptaculous in Action
- /Prototype and Scriptaculous in Action/

** Part 1---Preparing for Training
This part of the book will set the stage for your JavaScript ninja training.

In [[*Enter the Ninja][chapter 1]], you’ll learn what we’re trying to accomplish with this book, and
we’ll lay the framework for the environment in which JavaScript authors
operate.

[[*Arming with Testing and Debugging][Chapter 2]] will teach you why testing is so important and give you a brief
survey of some of the testing tools available. Then we’ll develop some
surprisingly simple testing tools that you’ll use throughout the rest of your
training.

*** Enter the Ninja
:PROPERTIES:
:chapter:  1
:END:

{{{heading(Chapter topics:)}}}

- A look at the purpose and structure of this book

- Which libraries we’ll look at

- What is “advanced” JavaScript programming?

- Cross-browser authoring

- Test suite examples


{{{heading(The Purpose of this Book)}}}

``This book sets out to uncover the techniques and secrets used by
... world-class code bases and to gather them into a single resource.  In this
book we’ll be examining the techniques that were (and continue to be) used to
create the popular JavaScript libraries.  The techniques and practices used to
create modern JavaScript libraries will be the focus of our attention in this
book.  Understanding how the very best JavaScript libraries are constructed can
provide us with great insight into how our own code can be constructed to
achieve these same goals.''

{{{heading(Creating Cross-Browser JavaScript Code)}}}

#+cindex:cross-browser JavaScript code
#+cindex:libraries, JavaScript
There’s nothing simple about creating effective and cross-browser JavaScript
code.

{{{subheading(Obtuse browser differences)}}}

In addition to the normal challenges of writing clean code, we have the
added complexity of dealing with obtuse browser differences and complexities.

{{{subheading(JavaScript Libraries)}}}

To deal with these challenges, JavaScript developers frequently /capture sets
of common and reusable functionality/ in the form of JavaScript libraries.

- common and reusable functionality

- JavaScript Libraries---sets of common and reusable functionality

- they need to be easy to use,

- incur the least amount of overhead, and

- be able to work across all browsers that we wish to target.


Understanding how the very best JavaScript libraries are constructed can
provide us with great insight into how our own code can be constructed to
achieve these same goals.

#+cindex:techniques, examine
/This book sets out to uncover the techniques and secrets used by these
world-class code bases and to gather them into a single resource/.  In this
book we’ll be examining the techniques that were (and continue to be) used to
create the popular JavaScript libraries.

**** The JavaScript libraries we’ll be tapping
The techniques and practices used to create modern JavaScript libraries will be
the focus of our attention in this book.

{{{heading(jQuery---The Primary Library)}}}

#+cindex:jQuery
The primary library that we’ll be considering is *jQuery*, which has risen in
prominence to be the most ubiquitous JavaScript library in modern use.

[[http://jquery.com][jQuery]] was created by John Resig and released in January of 2006.  /jQuery
popularized the use of CSS selectors to match DOM content/.  Among its many
capabilities, it provides

{{{subheading(jQuery Capabilities:)}}}

- DOM manipulation,
- Ajax,
- event handling, and
- animation functionality.


{{{heading(Prototype---Yahoo UI---base2)}}}

In addition to examining example code from jQuery, we’ll also look at
techniques utilized by the following libraries:

#+cindex:Prototype
- [[http://prototypejs.org/][Prototype]] :: The godfather of the modern JavaScript libraries, created by Sam
     Stephenson and released in 2005.  This library embodies DOM, Ajax, and
     event functionality, in addition to object-oriented, aspect-oriented, and
     functional programming techniques.

  #+cindex:Yahoo! UI
- [[http://developer.yahoo.com/yui][Yahoo! UI]] :: The result of internal JavaScript framework development at
     Yahoo! and released to the public in February of 2006.  Yahoo! UI (YUI)
     includes DOM, Ajax, event, and animation capabilities in addition to a
     number of preconstructed widgets (calendar, grid, accordion, and others).

  #+cindex:base2
  #+cindex:Edwards, Dean
- [[http://code.google.com/p/base2][base2]] :: Created by Dean Edwards and released in March 2007.  This library
     supports DOM and event functionality.  Its claim to fame is that it
     attempts to implement the various W3C specifications in a universal,
     cross-browser manner.


These techniques aren’t only useful for constructing large libraries; they can
be applied to all JavaScript coding, regardless of size.

{{{heading(How JavaScript Libraries are Analyzed)}}}

#+cindex:JavaScript library, makeup
The makeup of a JavaScript library can be broken down into three aspects:

- Advanced use of the JavaScript language

- Meticulous construction of cross-browser code

- The use of current best practices that tie everything together


We’ll be carefully analyzing these three aspects in each of the libraries to
gather a complete knowledge base we can use to create our own effective
JavaScript code.

**** Understanding the JavaScript language

{{{heading(Objects---Functions---Closures)}}}

JavaScript consists of a close relationship between:
- objects,
- functions, and
- closures

#+caption:JavaScript consists of a close relationship between objects, functions, and closures.
#+name:fig-JS-objects-functions-closures
[[https://dpzbhybb2pdcj.cloudfront.net/resig/Figures/01fig01.jpg]]

Understanding the strong relationship between these three concepts can vastly
improve our JavaScript programming ability, giving us a strong foundation for
any type of application development.

{{{heading(Timers---Regular Expressions)}}}

#+cindex:timers
#+cindex:regular expressions
In addition to these fundamental concepts, there are two features in JavaScript
that are woefully underused:

- timers; and

- regular expressions.


These two concepts have applications in virtually any JavaScript code base, but
they aren’t always used to their full potential due to their misunderstood
nature.  A firm grasp of how /timers/ operate within the browser, all too
frequently a mystery, gives us the ability to tackle complex coding tasks such
as long-running computations and smooth animations.  And a sound understanding
of how /regular expressions/ work allows us to simplify what would otherwise be
quite complicated pieces of code.

{{{heading(The ~with~ Statement---The ~eval()~ Method)}}}

#+cindex:@code{with} statement
#+cindex:@code{eval()} method
As another high point of our advanced tour of the JavaScript language, we’ll
take a look at the ~with~ statement in chapter 10, and the divisive ~eval()~
method in chapter 9---two important, but controversial, language features that
have been trivialized, misused, and even condemned outright by many JavaScript
programmers.

**** Cross-Browser Considerations
When developing browser-based JavaScript applications (which is the focus of
this book), sooner rather than later, we’re going to run face first into The
Browsers and their maddening issues and inconsistencies.

The quality of browsers has improved greatly as of late, but they all still
have some bugs, missing APIs, and browser-specific quirks that we’ll need top
deal with.  Developing a comprehensive strategy for tackling these browser
issues, and becoming intimately familiar with their differences and quirks, is
just as important, if not more so, than proficiency in JavaScript itself.

When writing browser applications or JavaScript libraries to be used in them,
picking and choosing which browsers to support is an important consideration.
We’d probably like to support them all, but limitations on development and
testing resources dictate otherwise.  So how do we decide which to support, and
to what level?

...

**** Current best practices
#+cindex:best practices
To enter the big leagues, you also need to exhibit the traits that scores of
previous developers have proved are beneficial to the development of quality
code.  These traits, which we’ll examine in depth in chapter 2, are known as
/best practices/ and, in addition to mastery of the language, include such
elements as:

#+cindex:testing
- Testing

  #+cindex:performance analysis
- Performance analysis

  #+cindex:debugging skills
- Debugging skills

***** Current best practice---testing
#+cindex:@code{assert(_} function
#+cindex:testing tool
We’ll be applying a number of testing techniques that serve to ensure that our
example code operates as intended, as well as to serve as examples of how to
test general code.  The primary tool that we’ll be using for testing is an
~assert()~ function, whose purpose is to assert that a premise is either =true=
or =false=.

The general form of this function is:
: assert(condition, message);
where the first parameter is a condition that should be true, and the second is
a message that will be displayed if it’s not.

Note that the ~assert()~ function isn’t an innate feature of the language (some
languages, such as Java, provide such capabilities), so we’ll be implementing
it ourselves.  We’ll be discussing its implementation and use in chapter 2.

***** Current best practice---performance analysis
#+cindex:performance analysis
We’ll be using code such as the following later in this book for collecting
performance information:

#+begin_src js
start = new Date().getTime();
for (var n = 0; n < maxCount; n++) {
  /* perform the operation to be measured *//
}
elapsed = new Date().getTime() - start;
assert(true,"Measured time: " + elapsed);
#+end_src

#+cindex:timestamps, performance analysis
Here, we bracket the execution of the code to be measured with the collection
of timestamps: one before we execute the code and one after.  Their difference
tells us how long the code took to perform, which we can compare against
alternatives to the code that we measure using the same technique.

Note how we perform the code multiple times; in this example, we perform it the
number of times represented by maxCount.  Because a single operation of the
code happens much too quickly to measure reliably, we need to perform the code
many times to get a measurable value.  Frequently, this count can be in the
tens of thousands, or even millions, depending upon the nature of the code
being measured.  A little trial and-error lets us choose a reasonable value.

*** Arming with Testing and Debugging
:PROPERTIES:
:chapter:  2
:END:

Coverage:
- Tools for debugging JavaScript code
- Techniques for generating tests
- Building a test suite
- How to test asynchronous operations


#+cindex:test suites
Constructing effective test suites for your code is always important, so we’re
going to discuss it now, before we go into any discussions on coding.  As
important as a solid testing strategy is for all code, it can be crucial for
situations where /external factors/ have the potential to affect the operation
of your code, which is exactly the case we’re faced with in cross-browser
JavaScript development.  We also have the problem of determining if our code
works in all the browsers that we choose to support.  It’s vital that the
importance of testing be emphasized and testing strategies defined, because
we’ll be using these strategies throughout the rest of the book.

In this chapter, we’re going to look at:

#+cindex:debugging JavaScript
- some tools and techniques for debugging JavaScript code,
- for generating tests based upon those results, and
- for constructing a test suite to reliably run those tests.

**** Debugging code
#+cindex:debuggin
Similar tools have been developed for all major browsers:

#+cindex:Firebug
- [[http://getfirebug.org/][Firebug]]
  #+cindex:IE Developer
- IE Developer Tools—Included in Internet Explorer 8 and later.
  #+cindex:Opera Dragonfly
- Opera Dragonfly
  #+cindex:WebKit Developer Tools
- WebKit Developer Tools---Introduced in Safari 3, dramatically improved as of
  Safari 4, and now available in Chrome.


There are two important approaches to debugging JavaScript:
#+cindex:logging
- logging and
  #+cindex:breakpoints
- breakpoints.

***** Logging
#+cindex:logging
#+cindex:@code{console.log()}
Logging statements (such as using the ~console.log()~ method in Firebug,
Safari, Chrome, IE, and recent versions of Opera) are part of the code (even if
perhaps temporarily) and are useful in a cross-browser sense.  We can write
logging calls in our code, and we can benefit from seeing the messages in the
consoles of all modern browsers.

All our logging statements can be written to the console and be browsed
immediately or at a later time without impeding the normal flow of the program.
For example, if we wanted to know what the value of a variable named ~x~ was at
a certain point in the code, we might write this:

#+begin_src js
var x = 213;
console.log(x);
#+end_src

***** Breakpoints
#+cindex:breakpoints
Breakpoints are a somewhat more complex concept than logging, but they possess
a notable advantage over logging: they halt the execution of a script at a
specific line of code, pausing the browser.  This allows us to leisurely
investigate the state of all sorts of things at the point of the break.  This
includes all accessible variables, the context, and the scope chain.

#+name:setting-breakpoints
#+begin_src html :tangle public/breakpoint.html :mkdirp yes
<!DOCTYPE html>
<html>
  <head>
    <title>Listing 2.2</title>
    <script type="text/javascript" src="log.js"></script>
    <script type="text/javascript">var x = 213;
      log(x); <!-- Set a breakpoint here -->
    </script>
  </head>
  <body>
  </body>
</html>
#+end_src

#+cindex:breakpoint, set
If we were to set a breakpoint using Firebug on the annotated line B in listing
2.2 (by clicking on the line number margin in the Script display) and refresh
the page to cause the code to execute, the debugger would stop execution at
that line and show us the display in figure 2.2.

Note how the rightmost pane allows us to see the state within which our code is
running, including the value of ~x~.  The debugger breaks on a line before the
breakpointed line is actually executed; in this example, the call to the
~log()~ method has yet to be executed.

#+cindex:step into
If we were trying to debug a problem with our new method, we might want to step
into that method to see what’s going on inside it.  Clicking on the “step into”
button (the left-most gold arrow button) causes the debugger to execute up to
the first line of our method, and we’d see the display shown in figure 2.3.
Note how the displayed state has changed.

Debugging code not only serves its primary and obvious purpose (detecting and
fixing bugs), but it also can help us achieve the current best-practice goal of
generating effective test cases.

**** Test generation
Good tests exhibit three important characteristics:

- Repeatability ::

                   Our test results should be highly reproducible.  Tests run
                   repeatedly should always produce the exact same results.  If
                   test results are nondeterministic, how would we know which
                   results are valid and which are invalid?  Additionally,
                   reproducibility ensures that our tests aren’t dependent upon
                   external factors issues like network or CPU loads.

- Simplicity ::

                Our tests should focus on testing one thing.  We should strive
                to remove as much HTML markup, CSS, or JavaScript as we can
                without disrupting the intent of the test case.  The more we
                remove, the greater the likelihood that the test case will only
                be influenced by the specific code that we’re testing.

- Independence ::

                  Our tests should execute in isolation.  We must avoid making
                  the results from one test dependent upon another.  Breaking
                  tests down into the smallest possible units will help us
                  determine the exact source of a bug when an error occurs.


There are a number of approaches that can be used for constructing tests, with
the two primary approaches being:

- deconstructive tests
- constructive tests

**** Testing Frameworks
{{{heading(QUnit)}}}

{{{heading(YUI Test)}}}

{{{heading(JsUnit)}}}

{{{heading(Newer Unit-Testing Frameworks)}}}

**** The Funamentals of a Test Suite

** Part 2---Apprentice Training

*** Functions are Fundamental

*** Wielding Functions

*** Closing in on Closures

*** Object-orientation with Prototypes

*** Wrangling Regular Expressions

*** Taming Threads and Timers

** Part 3---Ninja Training

*** Ninja Alchemy - Runtime Code Evaluation

*** =with= Statements

*** Developing Cross-Browser Strategies

*** Cutting Through Attributes-Properties-and CSS
*** Surviving Events

** Part 4---Master Training

*** Manipulating the DOM

*** CSS Selector Engines

** End Matter

** Concept Index
:PROPERTIES:
:index:    cp
:unnumbered: t
:END:
* Speaking JavaScript---An In-Depth Guide for Programmers
- http://speakingjs.com/

- By Dr. Axel Rauschmayer

- This book covers JavaScript up to and including ECMAScript 5.
** About Speaking JavaScript
This book has been written for programmers, by a programmer.  In order to
understand it, you should already know object-oriented programming, for
example, via a mainstream programming language such as Java, PHP, C++, Python,
Ruby, Objective-C, Swift, C#, or Perl.

Thus, the book’s target audience is programmers who want to learn JavaScript
quickly and properly, and JavaScript programmers who want to deepen their
skills and/or look up specific topics.

Speaking JavaScript has four parts:

1. JavaScript Quick Start: Learn a safe subset of JavaScript in less than 30
   pages.
2. Background: When, why, and how was JavaScript created? How is it related to
   other programming languages? What were the important steps that got us to
   where we are today?
3. JavaScript in Depth: This part is more of a reference: look for a topic that
   you are interested in, jump in, and explore. I still tried to make it fun to
   read.
4. Tips, Tools, and Libraries: This part gives tips for using JavaScript: best
   practices, advanced techniques, and learning resources. It also describes a
   few important tools and libraries.

* Exploring ES6
- https://exploringjs.com/es6.html
- by Dr. Axel Rauschmayer
* Setting Up ES6
- https://exploringjs.com/setting-up-es6.html

- By Dr. Axel Rauschmayer
** About Setting Up ES6
ES6 (whose official name is ECMAScript 2015) is the latest version of
JavaScript.  This book explains how to set up ES6 projects that are compiled to
ES5 via Babel 6.  It covers the following scenarios:

- Deploying ES6 in browsers via Babel and webpack
- Deploying ES6 in Node.js, by statically or dynamically compiling it via
  Babel.

* Some JavaScript Quizzes

** So, you think you know JavaScript?
- http://dmitry.baranovskiy.com/post/91403200


Quick test for real understanding of JavaScript core beyond closures and
scopes. Here five small scripts.

- [[https://humanwhocodes.com/blog/2010/01/26/answering-baranovskiys-javascript-quiz/][Answering Baranovskiy’s JavaScript quiz]]

** Javascript quiz
Perfection Kills by kangax
- http://perfectionkills.com/javascript-quiz/

** Javascript quiz ES6 edition
Perfection Kills by kangax
- http://perfectionkills.com/javascript-quiz-es6/

* Exploring ES2016 and ES2017
- https://exploringjs.com/es2016-es2017.html

- By Dr. Axel Rauschmayer

* Exploring ES2018 and ES2019
- https://exploringjs.com/es2018-es2019/index.html

- By Dr. Axel Rauschmayer

* JavaScript for Impatient Programmers
- https://exploringjs.com/impatient-js/index.html

- By Dr. Axel Rauschmayer

** About JavaScript for Impatient Programmers
This book makes JavaScript less challenging to learn for newcomers, by offering
a modern view that is as consistent as possible.

{{{heading(Highlights)}}}

- Get started quickly, by initially focusing on modern features.
- Test-driven exercises and quizzes available for most chapters.
- Covers all essential features of JavaScript, up to and including ES2019.
- Optional advanced sections let you dig deeper.

* Exploring ReasonML and Functional Programming
- http://reasonmlhub.com/exploring-reasonml/

- By Dr. Axel Rauschmayer

** About Exploring Reason ML
- ReasonML: This book teaches the programming language ReasonML by Facebook.
- Functional programming: It is also an introduction to functional
  programming. Especially people familiar with C-style languages (Java,
  JavaScript, C#, etc.) will profit from ReasonML’s familiar syntax.
- Required knowledge: You should know how to program, e.g. in a mainstream
  language such as Java, JavaScript, C#, Python, C/C++, PHP, Ruby, Go, etc.

* JSON
- [[http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf][Standard ECMA-404]] “The JSON Data Interchange Syntax”

** Introducing JSON
- https://json.org

* Concept Index
:PROPERTIES:
:index:    cp
:unnumbered: t
:END:

* List of Tables
:PROPERTIES:
:unnumbered: t
:END:
#+texinfo:@listoffloats Table

* List of Programs
:PROPERTIES:
:unnumbered: t
:END:
#+texinfo:@listoffloats Listing
* Macro Definitions
#+macro:heading @@html:<h2>@@@@texinfo:@heading @@$1@@html:</h2>@@
#+macro:subheading @@html:<h3>@@@@texinfo:@subheading @@$1@@html:</h3>@@
#+macro:dfn @@texinfo:@dfn{@@$1@@texinfo:}@@
#+macro:noindent @@texinfo:@noindent @@
#+macro:var @@texinfo:@var{@@$1@@texinfo:}@@
#+macro:command @@texinfo:@command{@@$1@@texinfo:}@@
#+macro:option @@texinfo:@option{@@$1@@texinfo:}@@

** Export to HTML
*** HTML Options
#+OPTIONS: H:4
#+OPTIONS: html-link-use-abs-url:nil html-postamble:auto html-preamble:t
#+OPTIONS: html-scripts:t html-style:t html5-fancy:t tex:t ':t broken-links:mark

*** HTML Export Settings
#+export_file_name: ecmascript_262.html
#+html_doctype: html5
#+html_container: div
#+description:
#+keywords:
#+html_link_home:
#+html_link_up:
#+html_mathjax:
#+html_head:
#+html_head_extra:
#+subtitle:Version {{{version}}} Lasted Updated {{{date}}}
#+infojs_opt:
#+creator: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 26.1 (<a href="https://orgmode.org">Org</a> mode 9.1.14)
#+latex_header:

** Export to Texinfo
*** Texinfo Export Settings
#+texinfo_filename:ecmascript_262.info
#+texinfo_class: info
#+texinfo_header:
#+texinfo_post_header:
#+subtitle:
#+subauthor:
#+texinfo_dir_category:JavaScript
#+texinfo_dir_title:Secrets of the JavaScript Ninja
#+texinfo_dir_desc:Training in the JavaScript language
#+texinfo_printed_title:Secrets of the JavaScript Ninja

* Settings                                                         :noexport:
#+startup: content 3
#+options: H:4 ':t
* Footnotes

[fn:13] Added in ES2018, not yet supported in Firefox. 

[fn:1] Except "use strict"

[fn:2] Except leading zeroes in parseInt

[fn:3] Partially supported by all browsers

[fn:4] This page was last modified on 9 October 2011, at 19:22.

[fn:5] The ECMAScript 5 spec says that ~undefined~ is (almost) always passed,
but that the function being called should change its ~thisValue~ to the global
object when /not/ in strict mode.  This allows strict mode callers to avoid
breaking existing non-strict-mode libraries.

[fn:6] Note that we save this method as ~Function.prototype.bind~, so that all
function objects inherit it.

[fn:7]Similar methods in various libraries may have other names for the same
basic functionality; popular alternates include the extend() and mix()
methods. There was also, briefly, an Object.mixin() method in ECMAScript 6 in
addition to the Object.assign() method. The primary difference was that
Object.mixin() also copied over accessor properties, but the method was removed
due to concerns over the use of super (discussed in the “Easy Prototype Access
with Super References” section of this chapter).

[fn:8] Now Stage 4

[fn:9] Now Stage 3

[fn:10] See ``JavaScript Module Systems Showdown: CommonJS vs AMD vs ES2015''
by Sebastian Peyrott at https://auth0.com/blog/javascript-module-systems-showdown/.

[fn:11] Dynamic import is an ECMAScript propsal due to be standardized in
ES2020.

[fn:12] Roughly 2000--2010

* Local Variables                                                  :noexport:
# Local Variables:
# fill-column: 79
# time-stamp-pattern: "8/^\\#\\+Date:%:y-%02m-%02d %02H:%02M$"
# eval: (setq org-publish-project-alist '(("ecmascript_262" :base-directory "." :publishing-directory "./public_html" :publishing-function org-html-publish-to-html :section-numbers t :table-of-contents t)))
# eval: (org-indent-mode)
# End:
