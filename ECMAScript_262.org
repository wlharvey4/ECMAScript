# -*- mode: org; -*-
#+Title:ECMAScript 262
#+Date:2019-06-17 09:30
#+macro:version 0.2.16

* ECMAScript Description

  The ECMAScript specification is a standardized specification of a scripting
  language developed by Brendan Eich of Netscape.

  ECMAScript is a scripting language specification standardized by ECMA
  International in ECMA-262 and ISO/IEC 16262.  It was created to standardize
  JavaScript (``Spidermonkey''), so as to foster multiple independent
  implementations.  Other implementations include
  - JScript (Microsoft)
  - ActionScript (Macromedia Inc.; Adobe)


  ECMAScript is *object-based*: basic language and host facilities are provided
  by /objects/, and an ECMAScript program is a cluster of communicating
  objects.  An ECMAScript *object* is a collection of /properties/ each with
  zero or more /attributes/ that determine how each property can be used.
  *Properties* are containers that hold other objects, primitive values, or
  functions.  A *primitive value* is a member of one of the following built-in
  types:
  - Undefined
  - Null
  - Boolean
  - Number
  - String


  An *object* is a member of the remaining built-in type
  - Object


  And a *function* is a /callable object/.  A *method* is a function that is associated with
  an object via a property.

  ECMAScript defines a collection of *built-in objects* that round out the
  definition of ECMAScript entities.  These built-in objects include:
  - the global object
  - the Object object
  - the Function object
  - the Array object
  - the String object
  - the Boolean object
  - the Number object
  - the Math object
  - the Date object
  - the RegExp object
  - the JSON object
  - the Error objects
    - EvalError
    - RangeError
    - ReferenceError
    - SyntaxError
    - TypeError
    - URIError


  ECMAScript also defines a set of *built-in operators*.  ECMAScript operators
  include:
  - unary operators
  - multiplicative operators
  - additive operators
  - bitwise shift operators
  - relational operators
  - equality operators
  - binary bitwise operators
  - binary logical operators
  - assignment operators
  - comma operator


  *ECMAScript syntax* intentionally resembles Java syntax. ECMAScript syntax is
  relaxed to enable it to serve as an easy-to-use scripting language.

** Version Numbers

   | Year | JavaScript | ECMA   | Browser            |
   |      | <c>        | <c>    |                    |
   |------+------------+--------+--------------------|
   | 1996 | 1.0        |        | Netscape 2         |
   | 1997 |            | ES1    | IE 4               |
   | 1998 | 1.3        |        | Netscape 4         |
   | 1999 |            | ES2    | IE 5               |
   | 2000 |            | ES3    | IE 5.5             |
   | 2000 | 1.5        |        | Firefox 1          |
   | 2011 |            | ES5    | IE 9[fn:1]         |
   | 2011 | 1.8.5      |        | Firefox 4[fn:2]    |
   | 2012 |            |        | IE 10              |
   | 2012 |            |        | Chrome 23          |
   | 2012 |            |        | Safari 6           |
   | 2013 |            |        | Firefox 21         |
   | 2013 |            |        | Opera 15           |
   | 2015 |            | ES2015 | All browsers[fn:3] |
   |------+------------+--------+--------------------|

** ECMAScript History

   - 1993 ::
     - NCSA’s *Mosaic* was the first widely popular web browser.

   - 1994 ::
     - a company called *Netscape* was founded to exploit the potential of the
       nascent World Wide Web.
     - Netscape created the proprietary web browser *Netscape Navigator*,
     - Many of the original Mosaic authors went on to work on Navigator, but
       the two intentionally shared no code.
     - Netscape quickly realized that the Web needed to become more dynamic.

   - 1995 ::
     - Netscape hired *Brendan Eich* with the promise of letting him implement
       Scheme (a Lisp dialect) in the browser.
     - Before he could get started, Netscape collaborated with hardware and
       software company *Sun* (since bought by Oracle) to include its more
       static programming language, *Java*, in Navigator.
     - As a consequence, a hotly debated question at Netscape was why the Web
       needed two programming languages: Java and a scripting language.
     - Netscape management decided that a scripting language had to have a
       syntax similar to Java’s.
     - That ruled out adopting existing languages such as Perl, Python, TCL, or
       Scheme.
     - To defend the idea of JavaScript against competing proposals, Netscape
       needed a prototype. Eich wrote one in 10 days.
     - JavaScript’s first code name was *"Mocha"*.
     - Netscape marketing later changed it to *"LiveScript"*, for trademark
       reasons and because the names of several products already had the prefix
       “Live.”
     - In late November 1995, *Navigator 2.0B3* came out and included the
       prototype, which continued its early existence without major changes.
     - In early December 1995, Java’s momentum had grown and the language was
       renamed again, to its final name, *JavaScript*.

   - 1996 ::
     - *Microsoft* implemented the same language, under the different
       name *JScript*, in Internet Explorer 3.0
     - Partially to keep Microsoft in check, Netscape decided to standardize
       JavaScript and asked the standards organization *Ecma International* to
       host the standard.
     - Work on a specification called *ECMA-262* started.
     - Because Sun (now Oracle) had a trademark on the term JavaScript, it
       couldn’t be the official name of the language to be standardized. Hence,
       *ECMAScript* was chosen, derived from JavaScript and Ecma.
     - However, that name is used only to refer to versions of the language
       (where one refers to the specification).  Everyone still calls the
       language *JavaScript*.
       #+cindex:TC39
     - *ECMA-262* is managed and evolved by Ecma’s *Technical Committee 39
       (TC39)*.  [[https://tc39.es][TC39]]

   - 1997 ::
     - ECMAScript 1 *First Edition*
     - *Dynamic HTML*: allows you to dynamically change the content and
       appearance of a web page, achieved by manipulating the Document Object
       Model (DOM) of the page, a tree-shaped data structure.  Things that can
       be done include: changing content, changing style, and showing and
       hiding elements.  First in Internet Explorer 4 and in Netscape
       Navigator 4.

   - 1998 ::
     - ECMAScript 2 --- Editorial changes to align ECMA-262 with the standard
       ISO/IEC 16262

   - 1999 ::
     - ECMAScript 3 --- ~do-while~, regular expressions, new string methods
       (~concat~, ~match~, ~replace~, ~slice~, ~split~ with a regular
       expression, etc.), exception handling, and more
     - *XMLHttpRequest*: lets a client-side script send an HTTP or HTTPS
       request to a server and get back data, usually in a text format (XML,
       HTML, JSON).  Introduced in Internet Explorer 5.

   - 2001 ::
     - *JSON*: a JavaScript-based data exchange format.  *Douglas Crockford*
       named and documented JSON (JavaScript Object Notation), whose main idea
       is to use JavaScript syntax to store data in text format.  JSON uses
       JavaScript literals for objects, arrays, strings, numbers, and booleans
       to represent structured data.

   - 2004 ::
     - *Dojo Toolkit*: a framework for programming JavaScript in the large.
       The Dojo Toolkit facilitates programming in the large by providing the
       necessary infrastructure: an inheritance library, a module system, an
       API for desktop-style graphical widgets, and more.
       - https://dojotoolkit.org
       - https://github.com/dojo/dojo

   - 2005 ::
     - *AJAX* (/Asynchronous JavaScript and XML/): browser-based desktop-class
       applications.  Ajax is a collection of technologies that brings a level
       of interactivity to web pages that rivals that of desktop applications.
       The two cornerstones of Ajax are:
       1. loading content asynchronously in the background (via
          ~XMLHttpRequest~); and
       2. dynamically updating the current page with the results (via /dynamic
          HTML/).

       [[https://www.adaptivepath.com/ideas/ajax-new-approach-web-applications/][Ajax: A New Approach to Web Applications]] February 18, 2005 | By Jesse
       James Garrett

       Ajax marked the mainstream breakthrough of JavaScript and dynamic web
       applications.  It is interesting to note how long that took—at that
       point, the Ajax ingredients had been available for years.  Since the
       inception of Ajax, other data formats have become popular (JSON instead
       of XML), other protocols are used (e.g., Web Sockets in addition to
       HTTP), and bidirectional communication is possible. But the basic
       techniques are still the same.

       The term Ajax is used much less these days and has mostly been replaced
       by the more comprehensive terms *HTML5* and *Web Platform* (which both
       mean /JavaScript plus browser APIs/).

     - *Apache CouchDB*: a JavaScript-centric database.  Roughly, CouchDB is a
       JSON database: you feed it JSON objects, without the need to specify a
       schema in advance. Additionally, you can define views and indexes via
       JavaScript functions that perform map/reduce operations. Hence, CouchDB
       is a very good fit for JavaScript because you can work directly with
       native data.  Compared to a /relational database/, there is no
       mapping-related impedance mismatch.  Compared to an /object database/,
       you avoid many complications because only data is stored, not behavior.

       CouchDB is just one of several similar *NoSQL databases*.  Most of them
       have excellent JavaScript support.

       - http://couchdb.apache.org
       - https://github.com/apache/couchdb

   - 2006 ::
     - *jQuery*: helping with DOM manipulation.  The browser DOM is one of the
       most painful parts of client-side web development.  jQuery made DOM
       manipulation fun by abstracting over browser differences and by
       providing a powerful fluent-style API for querying and modifying the
       DOM.

   - 2007 ::
     - *WebKit*: aking the mobile web mainstream.  Based on prior work by KDE,
       WebKit is an /HTML engine/ that was introduced by Apple in 2003.  It was
       open-sourced in 2005.  With the introduction of the iPhone in 2007, the
       mobile Web suddenly became mainstream and had little to no limitations
       compared to the nonmobile Web.

   - 2008 ::
     - ECMAScript 4 (Abandoned)

       ECMAScript 4 was developed as the next version of JavaScript, with a
       prototype written in ML.  However, TC39 could not agree on its feature
       set.  To prevent an impasse, the committee met at the end of July 2008
       and came to an accord, summarized in four points:

       1. Develop an incremental update of ECMAScript 3 (which became
          *ECMAScript 5*).

       2. Develop a major new version that does less than ECMAScript 4, but
          much more than the incremental update of ECMAScript 3. The code name
          for the new version is *Harmony*, due to the nature of the meeting in
          which it was conceived.  Harmony will be split into ECMAScript 6 and
          ECMAScript 7.

       3. Features from ECMAScript 4 that would be *dropped* included
          /packages/, /namespaces/, and /early binding/.

       4. Other ideas were to be developed in consensus with all of TC39.

       Thus, the ECMAScript 4 developers agreed to make Harmony less radical
       than ECMAScript 4, and the rest of TC39 agreed to keep moving things
       forward.

   - *V8*: proving JavaScript can be fast.  When Google introduced its Chrome
     web browser, one of its highlights was a fast JavaScript engine called V8.
     It changed the perception of JavaScript as being slow and led to a speed
     race with other browser vendors from which we are still profiting.  V8 is
     open source and can be used as a standalone component whenever you need a
     fast embedded language that is widely known.

   - 2009 ::
     - ECMAScript 5 --- Adds a strict mode, getters and setters, new array
       methods, support for JSON, and more

     - *Node.js*: implementing JavaScript on the server.  Created by Ryan Dahl,
       Node.js lets you implement servers that perform well under load.  To do
       so, it uses /event-driven/, /nonblocking I/O/ and /JavaScript/ (via V8).
       JavaScript was chosen for some of the following reasons:
       - “Because it’s bare and does not come with I/O APIs.” [Node.js can thus
         introduce its own nonblocking APIs.]
       - “Web developers use it already.” [JavaScript is a widely known
         language, especially in a web context.]
       - “DOM API is event-based.  Everyone is already used to running without
         threads and on an event loop.” [Developers are used to an asynchronous
         coding style.]

       The appeal of Node.js for JavaScript programmers goes beyond being able
       to program in a familiar language; you get to use the same language on
       both client and server.  That means you can share more code (e.g., for
       validating data) and use techniques such as isomorphic
       JavaScript. Isomorphic JavaScript is about assembling web pages on
       either client or server, with numerous benefits: pages can be rendered
       on the server for faster initial display, SEO, and running on browsers
       that either don’t support JavaScript or a version that is too old. But
       they can also be updated on the client, resulting in a more responsive
       user interface.

     - *PhoneGap*: writing native apps in HTML5.  The initial mission of
       PhoneGap was to make it possible to implement native mobile apps via
       HTML5. Since then, support has expanded to nonmobile operating
       systems. Currently supported platforms include Android, Bada,
       BlackBerry, Firefox OS, iOS, Mac OS X, Tizen, Ubuntu, Windows (desktop),
       and Windows Phone.

     - *Chrome OS*: making the browser the operating system.  With Chrome OS,
       the web platform is the native platform. This approach has several
       advantages:
       - It is much easier to create an operating system, because all of the
         user interface technology is already there.
       - Many developers already (mostly) know how to write apps for the
         operating system.
       - Managing apps is simple. That helps public installations such as
         Internet cafes and schools.

   - 2011 ::
     - ECMAScript 5.1 --- Editorial changes to align ECMA-262 with the third
       edition of the international standard ISO/IEC 16262:2011

     - *Windows 8*: first-class HTML5 apps.  Microsoft's Windows 8 has
       extensive integration with HTML5.  HTML5 applications are first-class
       citizens in Windows 8, on par with those implemented via incumbent
       technologies such as .NET and C++.

   - 2015 ::
     - ECMAScript 6
     - renamed to *ECMAScript 2015*
     - and *ES2015*
     - many new features added

   - 2016 ::
     - *ECMAScript 2016* (7th Edition)
     - exponentiation operator; ~Array.prototype.includes()~

   - 2017 ::
     - *ECMAScript 2017* (8th Edition)
     - concurrency; atomics; ~async/await~

   - 2018 ::
     - *ECMAScript 2018* (9th Edition)
     - asynchronous iteration and generators; new RegExp features; rest/spread
       parameters

** CommonJS

   The dominant incarnation of this standard is *Node.js modules* (Node.js
   modules have a few features that go beyond CJS).

   - http://www.commonjs.org
   - http://wiki.commonjs.org/wiki/CommonJS [fn:4]

   JavaScript is a powerful object oriented language with some of the fastest
   dynamic language interpreters around.  The official JavaScript specification
   defines APIs for some objects that are useful for building browser-based
   applications.  *However, the spec does not define a standard library that is
   useful for building a broader range of applications*.

   The CommonJS API will fill that gap by *defining APIs that handle many
   common application needs*, ultimately providing a standard library as rich
   as those of Python, Ruby and Java.  The intention is that an application
   developer will be able to write an application using the CommonJS APIs and
   then run that application across different JavaScript interpreters and host
   environments.

   With CommonJS-compliant systems, you can use JavaScript to write:

   - Server-side JavaScript applications
   - Command line tools
   - Desktop GUI-based applications
   - Hybrid applications (Titanium, Adobe AIR)

   [[https://arstechnica.com/information-technology/2009/12/commonjs-effort-sets-javascript-on-path-for-world-domination/][CommonJS effort sets JavaScript on path for world domination]] KRIS KOWAL -
   12/1/2009, 9:19 PM

* ECMAScript Specifications

  [[http://www.ecma-international.org/publications/standards/Ecma-262.htm][Current edition]].

  The first edition of ECMA-262 was adopted by the Ecma General Assembly in
  June 1997.  [[http://www.ecma-international.org/publications/standards/Ecma-262-arch.htm][Historical standards]].

** Edition 1

   June 1997.  [[https://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%25201st%2520edition,%2520June%25201997.pdf][First edition]]

   Netscape 2 was the first browser to run JavaScript.  After Netscape the
   Mozilla foundation continued to develop JavaScript for the Firefox browser.

** Edition 2

   June 1998.  [[https://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%25202nd%2520edition,%2520August%25201998.pdf][2nd Edition]]

   Editorial changes.x

** Edition 3

   December 1999.  [[https://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%25203rd%2520edition,%2520December%25201999.pdf][3rd Edition]] PDF

   ECMAScript 3 is fully supported in all browsers.

   - Regular expressions
   - better string handling
   - new control statements
   - try/catch exception handling
   - tighter definition of errors
   - formatting for numeric output

** Edition 4

   Abandoned.

** Edition 5

   December 2009.  [[https://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262%25205th%2520edition%2520December%25202009.pdf][5th Edition]] PDF

   ECMAScript 5 is fully supported in all /modern/ browsers.

   - [[http://kangax.github.io/compat-table/es5/][ES5 compatibility table]]
   - [[https://github.com/es-shims/es5-shim][es5-shim]]

   Codifies de facto interpretations of the language specification that have
   become common among browser implementations and adds support for new
   features that have emerged since the publication of the third edition.

   - strict mode that provides enhanced error checking and program security ::

        'use strict' directive defines that the JavaScript code should be
        executed in "strict mode".

        ECMAScript defines a strict variant of the language. The
        strict variant of the language excludes some specific syntactic and
        semantic features of the regular ECMAScript language and modifies the
        detailed semantics of some features.  The strict variant also specifies
        additional error conditions that must be reported by throwing error
        exceptions in situations that are not specified as errors by the
        non-strict form of the language.

        Strict mode selection and use of the strict mode syntax and semantics
        of ECMAScript is explicitly made at the level of individual ECMAScript
        code units.  Because strict mode is selected at the level of a
        syntactic code unit, strict mode only imposes restrictions that have
        local effect within such a code unit.

   - ambiguities clarified ::

   - accessor properties---getters and setters ::

        Getters and setters allow the programnmer to implement the getting and
        setting of a property via methods.

   - syntactic changes ::

        ECMAScript 5 includes the following syntactic changes:

     + Reserved words as property keys; the programmer can use reserved words
       (such as ~new~ and ~function~) after the dot operator and as unquoted
       property keys in object literals.

     + Legal trailing commas

     + Multiline string literals using a trailing backslash (=/=)

   - New Functionality in the Standard Library ::

     + *Metaprogramming* (reflective creation and inspection of objects)

       - Getting and setting prototypes

         - ~Object.create()~

         - ~Object.getPrototypeOf()~

       - Managing property attributes via property descriptors (program control
         of property attributes)

         - ~Object.defineProperty()~

         - ~Object.defineProperties()~

         - ~Object.create()~

         - ~Object.getOwnPropertyDescriptor()~

       - Listing properties

         - ~Object.keys()~

         - ~Object.getOwnPropertyNames()~

       - Protecting objects

         - ~Object.preventExtensions()~

         - ~Object.isExtensible()~

         - ~Object.seal()~

         - ~Object.isSealed()~

         - ~Object.freeze()~

         - ~Object.isFrozen()~

       - New Function method

         - ~Function.prototype.bind()~

     + *New Methods*

       - on Strings

         - ~String.prototype.trim()~

         - Access characters via the bracket operator =[...]=

       - on Arrays

         - ~Array.isArray()~

         - ~Array.prototype.every()~

         - ~Array.prototype.filter()~

         - ~Array.prototype.forEach()~

         - ~Array.prototype.indexOf()~

         - ~Array.prototype.lastIndexOf()~

         - ~Array.prototype.map()~

         - ~Array.prototype.reduce()~

         - ~Array.prototype.some()~

       - on Dates

         - ~Date.now()~

         - ~Date.prototype.toISOString()~

     + JSON library support

       - ~JSON.parse()~

       - ~JSON.stringify()~

       - Some built-in objects have special toJSON() methods:

         - ~Boolean.prototype.toJSON()~

         - ~Number.prototype.toJSON()~

         - ~String.prototype.toJSON()~

         - ~Date.prototype.toJSON()~

** Edition 5.1

   June 2011.  [[http://www.ecma-international.org/ecma-262/5.1/index.html#Title][ECMAScript 5.1]] HTML

   Fully aligned with third edition of the international standard ISO/IEC
   16262:2011.

** Edition 6 --- ECMAScript 2015 (ES 6) (ES2015)

   June 2015.  [[http://www.ecma-international.org/ecma-262/6.0/index.html#Title][ECMAScript 2015 (ES2015)]]

   Internet Explorer does not support ECMAScript 2015.

   The sixth edition was initially known as ECMAScript 6 (ES6) and later
   renamed to ECMAScript 2015 (ES2015).

   #+BEGIN_QUOTE
   ECMAScript 5 is a nice and decent programming language, of course. But
   because of its history, it has some nasty aspects which ECMAScript 6 finally
   resolves.... ECMAScript 6's language design is cleaner than ECMAScript 5,
   its syntax increases the expressiveness of your code, it decreases the
   necessary boilerplate code (e.g. function vs. arrow syntax) and it
   especially let you get rid of some very nasty but required hacks and
   workarounds from the ECMAScript 5 era (e.g. ~var self = this~).

   --- Dr. Ralf S. Engelschall
   #+END_QUOTE

   - ~let~ and ~const~ declarations
   - exponentiation operator =**=
   - default parameter values
   - number and math enhancements,
     - new =Number= properties
       - =EPSILON=
       - =MIN_SAFE_INTEGER=
       - =MAX_SAFE_INTEGER=
     - new =Number= methods
       - ~Number.isInteger()~
       - ~Number.isSafeInteger()~
   - new library methods on =Array=
     - ~Array.find()~
     - ~Array.findIndex()~
   - new global methods
     - ~isFinite()~
     - ~isNaN()~
   - significant new syntax for writing complex applications, defined
     semantically in the same terms as ECMAScript 5 strict mode:
     + classes
     + modules
   - iterators
   - for/of loops
   - Python-style generators and generator expressions
   - arrow functions
     - allow a short syntax for writing function expressions
     - do not have their own =this=
     - are not hoisted
     - use =const= instead of =var= because a function expression is always a
       constant
   - binary data
   - typed arrays
   - collections
     + maps
     + sets
     + weak maps
   - promises
   - reflection
   - proxies (metaprogramming for virtual objects and wrappers)
   - template literals

** Edition 7 --- ES2016

   June 2016.  [[http://www.ecma-international.org/ecma-262/7.0/index.html#Title][ECMAScript 2016 (ES2016)]]

   - exponentiation operator (~**~)
   - ~Array.prototype.includes~

** Edition 8 --- ES2017

   June 2017.  [[http://www.ecma-international.org/ecma-262/8.0/index.html#Title][ECMAScript 2017 (ES2017)]]

   - concurrency
   - atomics
   - async/await (syntactic integration with promises )

** Edition 9 --- ES2018

   June 2018.  [[http://www.ecma-international.org/ecma-262/9.0/index.html#Title][ECMAScript 2018 (ES2018)]]

   - features for asynchronous iteration and generators
   - new regular expression features
   - rest/spread parameters

** Edition 10 --- ES2020 (Draft)

   March 2019.  [[https://tc39.github.io/ecma262/][ECMAScript 2020 (Draft)]]

** TC39 JavaScript Specification Group
- https://tc39.es

#+cindex:specification, TC39 group
#+cindex:Ecma International
Ecma International's TC39 is a group of JavaScript developers, implementers,
academics, and more, collaborating with the community to maintain and evolve
the definition of JavaScript.

We develop the JavaScript (formally, ECMAScript) specification [[https://github.com/tc39/ecma262/][on GitHub]] and
meet every two months to discuss proposals. To learn more about the process,
please take a look at the [[https://tc39.github.io/process-document/][four stages]] for [[Y][new language feature proposals]].  See
our [[https://github.com/tc39/agendas/][meeting agendas]] and [[https://github.com/tc39/tc39-notes/][minutes]] to learn more.

{{{heading(Contributing to TC39)}}}

TC39 welcomes contributions.  You can help by giving feedback on proposals,
improving documentation, writing tests or implementations, or suggesting
language feature ideas.  See our [[https://github.com/tc39/ecma262/blob/master/CONTRIBUTING.md][contributor guide]] for details.

*** Stage 3 Proposals
- [[https://github.com/tc39/proposal-global][globalThis]]
- [[https://github.com/tc39/proposal-dynamic-import][import()]]
- [[https://github.com/tc39/proposal-bigint][BigInt]]
- [[https://github.com/tc39/proposal-private-methods][Private instance methods and accessors]]
- [[https://github.com/tc39/proposal-class-fields][Class Public Instance Fields & Private Instance Fields]]
- [[https://github.com/tc39/proposal-static-class-features][Static class fields and private static methods]]
- [[https://github.com/tc39/proposal-promise-allSettled][Promise.allSettled]]
- [[https://github.com/tc39/proposal-hashbang][Hashbang Grammar]]

* ECMAScript 3 Features

* ECMAScript 5 Features

* ECMAScript 2015 (ES6) Features

  - http://es6-features.org/
  - https://github.com/rse/es6-features

** Constants

** Scoping

** Arrow Functions

** Extended Parameter Handling

** Template Literals

** Extended Literals

** Enhanced Regular Expression

** Enhanced Object Properties

** Destructuring Assignment

** Modules

** Classes

** Symbol Type

** Iterators

** Generators

** Map/Set & WeakMap/WeakSet

** Typed Arrays

** New Built-In Methods

** Promises
#+cindex:promises
First class representation of a value that may be made asynchronously and be
available in the future.

Promises can be vaguely defined as “a proxy for a value that will eventually
become available.”

*** Traditional Callback Method

#+cindex:callback
Traditionally JavaScript relied on /callbacks/ instead of /promises and
chaining/.  If the ~fetch~ function asked for a /callback/, you’d have to add
one that would then get executed whenever the fetch operation ended.

#+cindex:asynchronous code flow
#+cindex:best practice
Typical asynchronous code flow conventions in Node.js established a best
practice of reserving the first parameter in the callback for errors---that may
or may not occur---during the ~fetch~‐ing process.  The rest of the parameters
could be used to read the results of the asynchronous operation.

#+cindex:callback-based API
#+cindex:traditional asynchronous code
The following shows how ~fetch()~ would look if it had a callback-based API:

#+begin_src js
fetch('/items', (err, res) => {
    if (err) {
        // handle err
    } else {
        // handle response
    }
});
#+end_src

The callback would not be invoked until the =/items= resource had been
retrieved, or an error arose from the fetch operation.  Execution would remain
asynchronous and nonblocking.

*Note* that in this model you could only specify /a single callback/.  That
callback would be responsible for /all/ functionality derived from the
response, and it would be up to the consumer to come up with a mechanism to
compose different aspects of handling the response into that single callback.

*** An Event-Driven Model
#+cindex:event-driven model
#+cindex:events
Besides traditional callbacks, another API design choice might have been to use
an event-driven model.  If this model were implemented by ~fetch~, ~fetch~
would be able to register callbacks for different kinds of events, binding as
many event handlers as needed for any events.  Typically there would be an
=error= event that's raised when things go awry, and other events are raised
when notable things happen.

Here is some code that would be used if ~fetch~ were based upon events:

#+begin_src js
fetch('/items')
    .on('error', err => {
        // handle error
    })
    .on('data', res => {
        // handle response
    })
#+end_src

*Note* that binding several listeners for each type of event would eliminate
the concern we had earlier about having to centralize response handling in a
single callback.

Events, however, make it hard to chain callbacks and have them fire when
another asynchronous task is fulfilled, and that’s where promises come in.
Moreover, events are better suited to handle streams of values, making them
somewhat inappropriate in this particular use case.

*** Asynchronous Fetch Example

#+cindex:@code{fetch()}
: fetch('/items')
makes a "fire and forget" =GET= request against =/items=, meaning you ignore
the response and whether the request succeeded.

#+cindex:Promise
#+cindex:@code{then()} method
#+cindex:@code{response} parameter
The ~fetch()~ method returns a =Promise=.  You can chain the ~then()~ method on
that =Promise=, and the callback will be executed once the =/items= resource
finishes loading, receiving a ~response~ parameter.

: fetch('/items').then(response => {
:     // do something with the response
: })

Here is how ~fetch()~ might be implemented in a browser:

#+begin_src js
const p = fetch('/items');

p.then(res => {
    // handle response
});

p.catch(err => {
    // handle error
});
#+end_src

#+cindex:reaction
#+cindex:fulfillment
#+cindex:fulfillment value
#+cindex:@code{then()} method
#+cindex:@code{catch()} method
#+cindex:rejection
/Reactions/ passed to ~then()~ can be used to handle the /fulfillment/ of a
promise, which is accompanied by a /fulfillment value/; and /reactions/ passed
to ~catch()~ are executed with a /rejection reason/ that can be used when
handling rejections.

#+cindex:register reaction
You can also /register/ a /reaction/ to rejections in the /second/ argument
passed to ~then()~.

#+begin_src js
const p = fetch('/items');
p.then(
    res => {
    // handle response
},
    err => {
    // handle error
});
#+end_src

Another alternative is to omit the /fulfillment reaction/ in ~then(fulfillment,
rejection)~ (use =null= instead).  Using ~then(null, rejection)~ is equivalent
to ~catch(rejection)~.

#+begin_src js
const p = fetch('/items');
p.then(res => {
    // handle response
});
p.then(null, err => {
    // handle error
});
#+end_src

*** Chaining of Promises
#+cindex:chaining of promises
The ~then()~ and ~catch()~ methods return a new =Promise= every time, creating
a tree-like data structure.  That’s important because chaining can have wildly
different results depending on where you append a ~then()~ or a ~catch()~ call.

Assume you have a ~p1~ promise, and ~p1.then()~ returns a ~p2~ promise.  The
~p1~ and ~p2~ promises are nodes connected by the ~p1.then()~ reaction
handler.

Reactions create new promises that are attached to the tree as children of the
promise they are reacting to.

~p1.then(r1).then(r2)~ creates two new promises ~p2~ and ~p3~.  Reaction ~r2~
is going to fire if ~p2~ fulfills, while reaction ~r1~ will fire when ~p1~ is
fulfilled.

Figuring out the tree-like nature of promises is the key to unlocking a deep
understanding of how promises behave.  See the tool [[https://bevacqua.github.io/promisees/][Promisees]] to play around
with promise chains while visualizing the tree structure they leave behind.
Promisees lets you write a piece of code and visualize how the underlying graph
evolves as promises are settled in fulfillment or rejection.

*** Creating Promises

**** Using the Promise Constructor

#+cindex:promise creation
#+cindex:Promise constructor
#+cindex:resolver
#+cindex:@code{resolve()} method
#+cindex:@code{reject()} method
#+cindex:settle
#+cindex:pending state
#+cindex:reactions
A promise is created by passing the ~Promise~ constructor a /resolver/ that
decides how and when the promise is settled, by calling either a ~resolve~
method that will /settle the promise in fulfillment/ or a ~reject~ method that
will /settle the promise as a rejection/.  Until the promise is settled by
calling either function, it’ll be in a /pending state/ and any /reactions/
attached to it won’t be executed.

The following snippet of code creates a promise from scratch where we’ll wait
for a second before randomly settling the promise with a fulfillment or
rejection result.

#+begin_src js
new Promise (function (resolve, reject) {
    setTimeout (function () {
        if (Math.random() > 0.5) {
            resolve('random success')
        } else {
            reject(new Error ('random failure'))
        }
    }, 1000)
})
#+end_src

**** Using the ~resolve()~ and ~reject()~ Methods

Promises can also be created using ~Promise.resolve~ and ~Promise.reject~.
These methods create promises that will immediately settle with a /fulfillment
value/ and a /rejection reason/, respectively.

#+begin_src js
Promise.resolve({ result: 123 }).then(data => console.log(data.result))
// 123
#+end_src

**** Looking at Reactions
When a promise is fulfilled, reactions registered with its ~then()~ method are
executed.  When a promise is rejected, reactions registered with its ~catch()~
method are executed.  Those reactions can, in turn, result in three different
situations depending on whether they
- return a value,
- a ~Promise~,
- a =thenable=, or
- throw an error.


=Thenables= are objects considered promise-like that can be cast into a
~Promise~ using ~Promise.resolve()~.

A reaction may return a /value/, which would cause the promise returned by
~then()~ to become fulfilled with that value.  Promises can be chained to
transform the fulfillment value of the previous promise over and over:

#+begin_src js
Promise
  .resolve(2)
  .then(x => x * 7)
  .then(x => x - 3)
  .then(x => console.log(x))
// 7
#+end_src

A reaction may return a promise.

#+begin_src js
Promise
  .resolve(2)
  .then(x => new Promise(function (resolve) {
      setTimeout(() => resolve(x * 1000), x * 1000)
  }))
  .then(x => console.log(x))
// 2000
#+end_src

A reaction may throw an error, which would cause the promise returned by
~then()~ to become rejected and thus follow the ~catch()~ branch, using said
error as the rejection reason.

#+begin_src js
const p = fetch('/items')
  .then(res => { throw new Error('unexpectedly') })
  .catch(err =>  console.error(err))
#+end_src
*** Promise Continuation and Chaining

#+cindex:@code{catch()} method
When an error happens in a promise resolver, you can catch that error using the
~catch()~ method:

#+begin_src js
new Promise((resolve, reject) => reject(new Error('oops')))
    .catch(err => console.error(err));
#+end_src

#+cindex:exception in resolver
A promise will settle as a rejection when the resolver calls ~reject()~ or if
an exception is thrown inside the resolver.

#+begin_src js
new Promise((resolve, reject) => {
    throw new Error('oops');
}).catch(err => console.error(err));
#+end_src

Errors that occur while executing a fulfillment or rejection reaction result in
a promise being rejected.

#+begin_src js
Promise
    .resolve(2)
    .then(x => { throw new Error('failed') })
    .catch(err => console.error(err));
#+end_src

Decompose the series of chained method calls into variables.

#+begin_src js :results output
const p1 = Promise.resolve(2);
const p2 = p1.then(x => { throw new Error('failed') });
const p3 = p2.catch(err => console.log(err));
#+end_src

#+RESULTS:
: Error: failed

If you attached the ~catch()~ reaction to ~p1~, you wouldn't be able to catch
the error originated in the ~then()~ reaction.

As long as an error remains uncaught in a promise chain, a rejection handler
will be able to capture it.  In the following example we’ve introduced an
intermediary ~then()~ call in between ~p2~, where the error originated, and
~p4~, where we attach the rejection reaction.  When ~p2~ settles with a
rejection, ~p3~ becomes settled with a rejection, as it depends on ~p2~
directly.  When ~p3~ settles with a rejection, the rejection handler in ~p4~
fires.

#+begin_src js :results output
const p1 = Promise.resolve(2)
const p2 = p1.then(x => { throw new Error('failed') })
const p3 = p2.then(x => x * 2)
const p4 = p3.catch(err => console.log(err))
#+end_src

#+RESULTS:
: Error: failed

The following example shows how you could print a statement to the browser con‐
sole by creating a ~p4~ fulfillment handler that depends on ~p3~ to settle
successfully with fulfillment.

#+begin_src js :results output
const p1 = Promise.resolve(2)
const p2 = p1.then(x => { throw new Error('failed') })
const p3 = p2.catch(err => console.log(err))
const p4 = p3.then(() => console.log('crisis averted'))
#+end_src

#+RESULTS:
: Error: failed
: crisis averted

Similarly, if an error occurred in the ~p3~ rejection handler, we could capture
that one as well using ~catch()~.  The next piece of code shows how an
exception being thrown in ~p3~ could be captured using ~p3.catch()~ just like
with any other errors arising in previous examples.

#+begin_src js :results output
const p1 = Promise.resolve(2)
const p2 = p1.then(x => { throw new Error('failed') })
const p3 = p2.catch(err => { throw new Error('oops') })
const p4 = p3.catch(err => console.log(err))
#+end_src

#+RESULTS:
: Error: oops

The following example prints ~err.message~ once instead of twice.  That’s
because no errors happened in the first ~catch()~, so the rejection branch for
that promise wasn’t executed.

#+begin_src js
fetch('/items')
    .then(res => res.a.prop.that.does.not.exist)
    .catch(err => console.error(err.message))
    .catch(err => console.error(err.message))
// <- 'Cannot read property "prop" of undefined'
#+end_src

In contrast, the next snippet will print ~err.message~ twice.  It works by
saving a reference to the promise returned by ~then()~, and then tacking two
~catch()~ reactions onto it.  The second ~catch()~ in the previous example was
capturing errors produced in the promise returned from the first ~catch()~, while
in this case both rejection handlers branch off of ~p~.

#+begin_src js
const p = fetch('/items')
  .then(res => res.a.prop.that.does.not.exist)
p.catch(err => console.error(err.message))
p.catch(err => console.error(err.message))
// <- 'Cannot read property "prop" of undefined'
// <- 'Cannot read property "prop" of undefined'
#+end_src

We should observe, then, that promises can be chained arbitrarily.  As we just
saw, you can save a reference to any point in the promise chain and then append
more promises on top of it.  This is one of the fundamental points to
understanding promises.

#+begin_src js
const p1 = fetch('/items')
const p2 = p1.then(res => res.a.prop.that.does.not.exist)
const p3 = p2.catch(err => {})
const p4 = p3.catch(err => console.error(err.message))
#+end_src

Here is an enumeration of what is going on as that piece of code is executed:

1. ~fetch()~ returns a brand new ~p1~ promise.

2. ~p1.then()~ returns a brand new ~p2~ promise, which will react if ~p1~ is
   fulfilled.

3. ~p2.catch()~ returns a brand new ~p3~ promise, which will react if ~p2~ is
   rejected.

4. ~p3.catch()~ returns a brand new ~p4~ promise, which will react if ~p3~ is
   rejected.

5. When ~p1~ is fulfilled, the ~p1.then()~ reaction is executed.

6. Afterwards, ~p2~ is rejected because of an error in the ~p1.then()~
   reaction.

7. Since ~p2~ was rejected, ~p2.catch()~ reactions are executed, and the
   ~p2.then()~ branch is ignored.

8. The ~p3~ promise from ~p2.catch()~ is fulfilled, because it doesn’t produce
   an error or result in a rejected promise.

9. Because ~p3~ was fulfilled, the ~p3.catch()~ is never followed.  The
   ~p3.then()~ branch would’ve been used instead.
*** Creating a Promise
#+cindex:promise creation
A promise can be created by:
- using a function that returns a promise, such as ~fetch()~
- calling ~Promise.resolve()~ or ~Promise.reject()~
- using the Promise constructor function


#+cindex:Promise constructor function
#+cindex:promise resolver function
#+cindex:promise settlement
#+cindex:settle
#+cindex:@code{resolve} function
#+cindex:@code{reject} function
Promises can be created from scratch by using ~new Promise(resolver)~.  The
~resolver~ parameter is a function that will be used to settle the promise.
The ~resolver~ takes two arguments: a ~resolve~ function and a ~reject~
function.

The pair of promises shown in the next snippet are settled in fulfillment and
rejection, respectively.

#+cindex:fulfillment value
- settling the first promise with a fulfillment value of 'result',
- rejecting the second promise with an Error object, specifying 'reason' as its
  message.

#+begin_src js
new Promise(resolve => resolve('result'))
new Promise((resolve, reject) => reject(new Error('reason')))
#+end_src

#+cindex:fulfill a promise
#+cindex:fulfillment value
#+cindex:result fulfillment value
Usually promises will fulfill with a /result/ such as the response from an Ajax
call, as we’ve seen with ~fetch~.  You’ll definitely want to state the reason
for your rejections---typically wrapping them in an ~Error~ object so that you
can report back a stack trace.  Note that only the first call made to one of
these functions (~resolve()~ or ~reject()~) will have an impact---once a
promise is settled its outcome can’t change.
** Meta-Programming

** Internationalization & Localization

* ECMAScript compatibility table

  - http://kangax.github.io/compat-table/es6/

  Notice the column "Babel + core-js" as this is what can be achieved today
  with transpiling (and that's fully sufficient for practice).

* ECMAScript Books

  - *[[http://speakingjs.com/es5/index.html][Speaking JavaScript: An In-Depth Guide for Programmers]]* by Dr. Axel
    Rauschmayer March 2014

    This book covers JavaScript up to and including ECMAScript 5.  The book’s
    target audience is programmers who want to learn JavaScript quickly and
    properly, and JavaScript programmers who want to deepen their skills and/or
    look up specific topics.

  - *[[http://exploringjs.com/impatient-js/toc.html][JavaScript for impatient programmers]]* by Dr. Axel Rauschmayer 2019

    This book makes JavaScript less challenging to learn for newcomers, by
    offering a modern view that is as consistent as possible.

    - Test-driven exercises and quizzes available for most chapters.
    - Covers all essential features of JavaScript, up to and including ES2019.
    - Optional advanced sections let you dig deeper.

  - *[[http://exploringjs.com/es6/index.html][Exploring ES6]]* by Dr. Axel Rauschmayer 2018-05-11

    The most comprehensive book on ECMAScript 6 (ECMAScript 2015); a book for
    people who already know JavaScript.

  - *Setting up ES6* by Dr. Axel Rauschmayer 

    This book explains how to set up ES6 projects that are compiled to ES5 via
    Babel 6.  You should already know ES6. It covers the following scenarios:

    - Deploying ES6 in browsers via Babel and webpack.
    - Deploying ES6 in Node.js, by statically or dynamically compiling it via
      Babel.

  - *[[http://exploringjs.com/es2016-es2017/index.html][Exploring ES2016 and ES2017]]* by Dr. Axel Rauschmayer 2018

    Covers what’s new in ECMAScript 2016 and ECMAScript 2017.

  - *[[http://exploringjs.com/es2018-es2019/toc.html][Exploring ES2018 and ES2019]]* by Dr. Axel Rauschmayer 2019

    Covers what’s new in ECMAScript 2018 and ECMAScript 2019.

  - *[[https://github.com/getify/You-Dont-Know-JS][You Don't Know JavaScript]]* by Kyle Simpson 2018

    - [[https://github.com/getify/You-Dont-Know-JS/blob/master/up%2520&%2520going/README.md#you-dont-know-js-up--going][Up and Going]]

    - [[https://github.com/getify/You-Dont-Know-JS/blob/master/scope%2520&%2520closures/README.md#you-dont-know-js-scope--closures][Scope and Closures]]

    - [[https://github.com/getify/You-Dont-Know-JS/blob/master/this%2520&%2520object%2520prototypes/README.md#you-dont-know-js-this--object-prototypes][this and Object Prototypes]]

    - [[https://github.com/getify/You-Dont-Know-JS/blob/master/types%2520&%2520grammar/README.md#you-dont-know-js-types--grammar][Types and Grammar]]

    - [[https://github.com/getify/You-Dont-Know-JS/blob/master/async%2520&%2520performance/README.md#you-dont-know-js-async--performance][Async and Performance]]

    - [[https://github.com/getify/You-Dont-Know-JS/blob/master/es6%2520&%2520beyond/README.md#you-dont-know-js-es6--beyond][ES6 and Beyond]]
* JavaScript---The Definitive Guide
:PROPERTIES:
:author:   David Flanagan
:published: 2011
:publisher: O'Reilly Media
:END:
- http://shop.oreilly.com/product/9780596805531.do
- [[https://resources.oreilly.com/examples/9780596805531/][Example Code]]
- [[https://www.oreilly.com/catalog/errata.csp?isbn=9780596805531][Errata]]

Since 1996, /JavaScript: The Definitive Guide/ has been the bible for
JavaScript programmers---a programmer's guide and comprehensive reference to the
core language and to the client-side JavaScript APIs defined by web browsers.

The 6th edition covers HTML5 and ECMAScript 5.  Many chapters have been
completely rewritten to bring them in line with today's best web development
practices.  New chapters in this edition document jQuery and server side
JavaScript.  It's recommended for experienced programmers who want to learn the
programming language of the Web, and for current JavaScript programmers who
want to master it.

This book covers the JavaScript language and the JavaScript APIs implemented by
web browsers.  It was written for programmers who already use JavaScript but
want to take their understanding to a new level and really master the language
and the web platform.  The goal with this book is to document the JavaScript
language and platform comprehensively and definitively.  It will reward careful
study, and that the time you spend reading it will be easily recouped in the
form of higher programming productivity.

{{{heading(How This Book Is Organized)}}}
This book is divided into four parts.

- Part I covers the JavaScript language itself.
- Part II covers client-side JavaScript: the JavaScript APIs defined by HTML5
  and related standards and implemented by web browsers.
- Part III is the reference section for the core language,
- Part IV is the reference for client-side JavaScript.


{{{subheading(The Sixth Edition)}}}
This sixth edition of the book covers both:

- ECMAScript 5 (the latest version of the core language) and
- HTML5 (the latest version of the web platform)

** Introduction to JavaScript
:PROPERTIES:
:chapter:  One
:END:
JavaScript is part of the triad of technologies that all Web developers must
learn:

- HTML to specify the /content/ of web pages
- CSS to specify the /presentation/ of web pages, and
- JavaScript to specify the /behavior/ of web pages.


JavaScript is:

- a high-level,
- dynamic,
- untyped
- interpreted
- programming language

that is well-suited to:

- /object-oriented/ and
- /functional/

programming styles.  JavaScript derives:

- its /syntax/ from *Java*,
- its /first-class functions/ from *Scheme*, and
- its /prototype-based inheritance/ from *Self*.


JavaScript has long since outgrown its scripting-language roots to become a
robust and efficient general-purpose language.  The latest version of the
language defines new features for serious large-scale software development.

*** Some History of JavaScript the Name
JavaScript is completely different from the Java programming language.  “Java-
Script” is a trademark licensed from Sun Microsystems (now Oracle) used to
describe Netscape’s (now Mozilla’s) implementation of the language.

Netscape submitted the language for standardization to ECMA---the European
Computer Manufacturer’s Association---and because of trademark issues, the
standardized version of the language was stuck with the awkward name
“ECMAScript.”  Microsoft’s version of the language is formally known as
“JScript.”  This book uses the name “ECMAScript” only to refer to the language
standard.

*** About Versions
#+cindex:version 3
#+cindex:ECMAScript 3
#+cindex:ES3
For the last decade[fn:5], all web browsers have implemented version 3 of the
ECMAScript standard and there has really been no need to think about version
numbers: the language standard was stable and browser implementations of the
language were, for the most part, interoperable.

#+cindex:version 5
#+cindex:ECMAScript 5
#+cindex:ES5
Recently, an important new version of the language has been defined as
ECMAScript version 5 and, at the time of this writing, browsers are beginning
to implement it.  This book covers all the new features of ECMAScript 5 as well
as all the long-standing features of ECMAScript 3.  You’ll sometimes see these
language versions abbreviated as ES3 and ES5, just as you’ll sometimes see the
name JavaScript abbreviated as JS.

#+cindex:version 4
#+cindex:ECMAScript 4
#+cindex:versino 1.5
#+cindex:V8
The only version numbers that are relevant are ECMAScript versions 3 or 5.
Version 4 was never released.  Sometimes, however, you’ll also see a JavaScript
version number, such as JavaScript 1.5 or JavaScript 1.8.  These are Mozilla’s
version numbers: version 1.5 is basically ECMAScript 3, and later versions
include nonstandard language extensions.  there are also version numbers
attached to particular JavaScript interpreters or “engines.” Google calls its
JavaScript interpreter V8, for example, and at the time of this writing the
current version of the V8 engine is 3.0.

*** About JavaScript's Minimal Standard Library
#+cindex:standard library
#+cindex:input output functionality
#+cindex:host environment
To be useful, every language must have a platform or /standard library/ or API
of functions for performing things like basic input and output.  The core
JavaScript language defines a minimal API for working with /text/, /arrays/,
/dates/, and /regular expressions/ but does not include any /input/ or /output/
functionality.  Input and output (as well as more sophisticated features, such
as /networking/, /storage/, and /graphics/) are the responsibility of the “host
environment” within which JavaScript is embedded.  Usually that host
environment is a web browser, but it can be something else.

*** What This Book Covers
#+cindex:coverage, book
#+cindex:book coverage
This book covers low-level fundamentals first, and then builds on those to more
advanced and higher-level abstractions.

- [[*Core JavaScript][Part I]] of this book covers the language itself and its minimal built-in API.
- [[*Client-Side JavaScript][Part II]] explains how JavaScript is used in web browsers and covers the
  sprawling browser-based APIs loosely known as “client-side JavaScript.”
- [[*Core API Reference][Part III]] is the reference section for the core API.
- [[*Client-Side JavaScript Reference][Part IV]] is the reference section for client-side JavaScript.

#+cindex:Chapter 1
Chapter 1 makes a quick first pass through the core language and the
client-side API, introducing key features that will make it easier to
understand the in-depth treatment in the chapters that follow.

*** An Overview of Core JavaScript
#+cindex:Chapter 2 Lexical Structure
[[*Lexical Structure][Chapter 2, Lexical Structure]], explains things like JavaScript comments,
semicolons, and the Unicode character set.

#+cindex:Chapter 3 Types Values Variables
[[*Types Values and Variables][Chapter 3, Types, Values, and Variables]], explains JavaScript variables and the
values you can assign to those variables.

#+cindex:Chapter 4 Expressions Operators
[[*Expressions and Operators][Chapter 4, Expressions and Operators]] discusses expressions and operators.

- Expression :: a phrase of JavaScript that can be evaluated to produce a
                value.  An expression is something that computes a value but
                doesn’t do anything: it doesn’t alter the program state in any
                way.

  - Operators: produce values


#+cindex:Chapter 5 Statements
[[*Statements][Chapter 5, Statements]]

- Statement :: Statements, on the other hand, don’t have a value (or don’t have
               a value that we care about), but they do alter the state.

  - Variable declarations: create variables

  - Assignment statements: assign values to variables

  - Control structures (conditionals and loops)


#+cindex:Chapter 6 Objects
[[*Objects][Chapter 6, Objects]]

#+cindex:Chapter 7 Arrays
[[*Arrays][Chapter 7, Arrays]]

#+cindex:Chapter 8 Functions
[[*Functions][Chapter 8, Functions]]

- Methods :: When we combine functions with objects, we get methods


#+cindex:Chapter 9 Classes Modules
[[*Classes and Modules][Chapter 9, Classes and Modules]] covers object-oriented programming in JavaScript
in detail, with lots of examples

#+cindex:Chapter 10 Pattern Matching Regular Expressions
[[*JavaScript Subsets and Extensions][Chapter 10, Pattern Matching with Regular Expressions]] explains the regular
expression grammar and demonstrates how to use these “regexps” for textual
pattern matching.

#+cindex:Chapter 11 Subsets Extensions
[[*JavaScript Subsets and Extensions][Chapter 11, JavaScript Subsets and Extensions]] covers subsets and extensions of
core JavaScript

#+cindex:Chapter 12 Server-Side
[[*Server-Side JavaScript][Chapter 12, Server-Side JavaScript]] introduces two ways to use JavaScript
outside of web browsers.

#+cindex:Part Two Client-Side
[[*Client-Side JavaScript][Part Two, Client-Side JavaScript]] is a quick sketch of basic client-side
programming techniques, followed by an in-depth example.

#+cindex:Chapter 13 JS in Web Browsers
[[*JavaScript in Web Browsers][Chapter 13, JavaScript in Web Browsers]] explains in detail how to put JavaScript
to work in web browsers.

#+cindex:Chapter 14 Window Object
[[*The Window Object][Chapter 14, The Window Object]] explains techniques for scripting the web browser
and covers some important global functions of client-side JavaScript.

#+cindex:Chapter 15 Scripting Documents
[[*Scripting Documents][Chapter 15, Scripting Documents]] shows you how to select particular HTML
elements from within a document, how to set HTML attributes of those elements,
how to alter the content of those elements, and how to add new elements to the
document; i.e., it shows how JavaScript can script the HTML elements that
define web content.

#+cindex:Chapter 16 Scripting CSS
[[*Scripting CSS][Chapter 16, Scripting CSS]] shows how you can use JavaScript with the CSS styles
that define the presentation of that content.

#+cindex:Chapter 17 Events
[[*Handling Events][Chapter 17, Handling Events]] explains how you can define and register event
handlers and how the browser invokes them when events occur.

Chapters 15, 16, and 17 explain how you can use JavaScript to script the
content (HTML), presentation (CSS), and behavior (event handling) of web pages.
The APIs described in those chapters are somewhat complex and, until recently,
riddled with browser incompatibilities.  For these reasons, many or most
client-side JavaScript programmers choose to use a client-side library or
framework to simplify their basic programming tasks.  The most popular such
library is *jQuery*.

#+cindex:Chapter 19 jQuery Library
[[*The jQuery Library][Chapter 19, The jQuery Library]], discusses jQuery, which defines a clever and
easy-to-use API for scripting document content, presentation, and behavior.

The four chapters of Part II described so far have all really been about web
pages.  Four more chapters shift gears to focus on web applications.  These
chapters are not about using web browsers to display documents with scriptable
content, presentation, and behavior.  Instead, they’re about using web browsers
as application platforms, and they describe the APIs that modern browsers
provide to support sophisticated client-side web apps.

#+cindex:Chapter 18 Scripted HTTP
[[*Scripted HTTP][Chapter 18, Scripted HTTP]] explains how to make scripted HTTP requests with
JavaScript—a kind of networking API.

#+cindex:Chapter 20 Storage Client-Side
[[*Client-Side Storage][Chapter 20, Client-Side Storage]] describes mechanisms for storing data---and
even entire applications---on the client side for use in future browsing
sessions.

#+cindex:Chapter 21 Scripted Media Graphics
[[*Scripted Media and Graphics][Chapter 21, Scripted Media and Graphics]] covers a client-side API for drawing
arbitrary graphics in an HTML =<canvas>= tag.

#+cindex:Chapter 22 HTML5 APIs
[[*HTML5 APIs][Chapter 22, HTML5 APIs]] covers an assortment of new web app APIs specified by or
affiliated with HTML5.  Networking, storage, graphics: these are OS-type
services being provided by the web browser, defining a new cross-platform
application environment.

*** An Extended Example --- LoanCalc
- [[file:LoanCalc.org][LoanCalc]]

This chapter ends with an extended example that puts many of these techniques
together and shows what real-world client-side JavaScript (plus HTML and CSS)
programs look like.

[[../figs/loancalc-50.png]]

** Core JavaScript
#+cindex:reference, language
#+cindex:language reference
This part of the book, Chapters 2 though 12, documents the core JavaScript
language and is meant to be a JavaScript language reference.
*** Lexical Structure
#+cindex:Chapter 2 Lexical Structure
#+cindex:lexical structure, def
The /lexical structure/ of a programming language is the set of elementary
rules that specifies how you write programs in that language.  It is the
lowest-level syntax of a language; it specifies such things as what variable
names look like, the delimiter characters for comments, and how one program
statement is separated from the next.

This short chapter documents the lexical structure of JavaScript.

**** Character Set
#+cindex:character set

**** Comments
#+cindex:comments

**** Literals
#+cindex:literals

**** Identifiers and Reserved Words
#+cindex:identifiers
#+cindex:reserved words

**** Optional Semicolons
#+cindex:semicolons 

*** Types Values and Variables
#+cindex:Chapter 3 Types Values Variables
#+cindex:types, def
#+cindex:values, def
Computer programs work by manipulating values.  The kinds of values that can be
represented and manipulated in a programming language are known as /types/, and
one of the most fundamental characteristics of a programming language is the
set of types it supports.

#+cindex:variable, def
When a program needs to retain a value for future use, it assigns the value to
(or “stores” the value in) a variable.  A /variable/ defines a symbolic name
for a value and allows the value to be referred to by name.

The way that variables work is another fundamental characteristic of any
programming language.  This chapter explains types, values, and variables in
JavaScript.

{{{heading(JavaScript Types Categories)}}}

#+cindex:primitive types
#+cindex:object types
#+cindex:types, categories
JavaScript types can be divided into two categories:

#+cindex:numbers, primitive
#+cindex:strings, primitive
#+cindex:booleans, primitive
#+cindex:null, primitive
#+cindex:undefined, primitive
- primitive types :: JavaScript’s primitive types include /numbers/, strings of
     text (known as /strings/), and Boolean truth values (known as /booleans/).
     The special JavaScript values /null/ and /undefined/ are primitive values,
     but they are not numbers, strings, or booleans.  Each value is typically
     considered to be the sole member of its own special type.

#+cindex:object types
#+cindex:type object
#+cindex:properties, def
- object types :: Any JavaScript value that is not a number, a string, a
                  boolean, or null or undefined is an /object/.  An /object/
                  (that is, a member of the type =object=) is a collection of
                  /properties/ where each property has a name and a value (either
                  a primitive value, such as a number or string, or an object).


{{{heading(About Object Types)}}}

#+cindex:object, ordinary
- An ordinary JavaScript object is an unordered collection of named values.

  #+cindex:object array
  #+cindex:array object
  #+cindex:ordered collection of values, array
- The language also defines a special kind of object, known as an /array/, that
  represents an ordered collection of numbered values.  The JavaScript language
  includes special syntax for working with arrays, and arrays have some special
  behavior that distinguishes them from ordinary objects.

  #+cindex:object function
  #+cindex:function object
- JavaScript defines another special kind of object, known as a /function/.  A
  function is an object that has executable code associated with it.  A
  function may be invoked to run that executable code and return a computed
  value.  Like arrays, functions behave differently from other kinds of
  objects, and JavaScript defines a special language syntax for working with
  them.  The most important thing about functions in JavaScript is that /they
  are true values/ and that JavaScript programs can treat them like regular
  objects.

  #+cindex:object constructor
  #+cindex:constructor object
  #+cindex:constructor function
  #+cindex:class of objects
  #+cindex:object class, constructor function
- Functions that are written to be used (with the ~new~ operator) to initialize
  a newly created object are known as /constructors/.  Each constructor defines a
  class of objects—--the set of objects initialized by that constructor.

  #+cindex:object class
  #+cindex:class object
  #+cindex:subtype of object, class
- /Classes/ can be thought of as subtypes of the object type.  In addition to
  the Array and Function classes, core JavaScript defines three other useful
  classes.  You can define your own classes of objects by defining appropriate
  constructor functions.

    #+cindex:Date class
  - The /Date class/ defines objects that represent dates.

    #+cindex:RegExp class
    #+cindex:regular expressions, RegExp class
  - The /RegExp class/ defines objects that represent regular expressions.

    #+cindex:Error class
  - The /Error class/ defines objects that represent syntax and runtime errors
    that can occur in a JavaScript program.


{{{heading(Garbage Collection of Objects)}}}

#+cindex:garbage collection
The JavaScript interpreter performs automatic garbage collection for memory
management.  This means that a program can create objects as needed, and the
programmer never needs to worry about destruction or deallocation of those
objects.  When an object is no longer reachable—--when a program no longer has
any way to refer to it---the interpreter knows it can never be used again and
automatically reclaims the memory it was occupying.

{{{heading(JavaScript is Object-Oriented)}}}

#+cindex:object-oriented language
JavaScript is an /object-oriented/ language.  Loosely, this means that rather
than having globally defined functions to operate on values of various types,
the types themselves define methods for working with values.

Technically, it is only JavaScript objects that have methods.  But numbers,
strings, and boolean values behave as if they had methods.  

In JavaScript, =null= and =undefined are the only values that methods cannot be
invoked on.

{{{heading(Mutability)}}}

#+cindex:mutable types
#+cindex:immutable types
#+cindex:mutability types
JavaScript’s types can be categorized as /mutable/ and /immutable/ types.  A
value of a mutable type can change.  Objects and arrays are mutable.  Numbers,
booleans, =null=, and =undefined= are immutable---it doesn’t even make sense to
talk about changing the value of a number, for example.  Strings can be thought
of as arrays of characters, and you might expect them to be mutable.  In
JavaScript, however, strings are immutable: you can access the text at any
index of a string, but JavaScript provides no way to alter the text of an
existing string.

{{{heading(Dynamic Type Conversion)}}}

#+cindex:type conversion
#+cindex:conversion of types
JavaScript converts values liberally from one type to another.  If a program
expects a string, for example, and you give it a number, it will automatically
convert the number to a string for you.  If you use a nonboolean value where a
boolean is expected, JavaScript will convert accordingly.

JavaScript’s liberal value conversion rules affect its definition of equality,
and the == equality operator performs type conversions.

{{{heading(Variables)}}}

{{{subheading(Untyped)}}}

#+cindex:untyped variables
#+cindex:variabes, untyped
JavaScript variables are /untyped/: you can assign a value of any type to a
variable, and you can later assign a value of a different type to the same
variable.

{{{subheading(Declarations)}}}

#+cindex:variable declarations
#+cindex:declare
#+cindex:@code{var} keyword
#+cindex:keyword @code{var}
Variables are /declared/ with the ~var~ keyword.

{{{subheading(Lexical Scope)}}}

#+cindex:lexical scope
#+cindex:scope, lexical
JavaScript uses /lexical scoping/.

{{{subheading(Global Variables)}}}

#+cindex:global variable
#+cindex:variable, global
Variables declared outside of a function are /global variables/ and are visible
everywhere in a JavaScript program.

{{{subheading(Function Scope)}}}

#+cindex:function scope
#+cindex:scope, function
Variables declared inside a function have /function scope/ and are visible only
to code that appears inside that function.

**** Numbers

**** Text

**** Boolean Values

**** Null and Undefined

**** The Global Object

**** Wrapper Objects

**** Immutable Primitive Values and Mutable Object References

**** Type Conversions

**** Variable Declaration

**** Variable Scope

*** Expressions and Operators
#+cindex:Chapter 4 Expressions and Operators
#+cindex:expression
#+cindex:evaluate
An /expression/ is a phrase of JavaScript that a JavaScript interpreter can
/evaluate/ to produce a /value/.  A constant embedded literally in your program
is a very simple kind of expression.  A variable name is also a simple
expression that evaluates to whatever value has been assigned to that variable.
Complex expressions are built from simpler expressions.

#+cindex:operator, complex expression
#+cindex:operator, returns a value
#+cindex:operator, evaulates to a value
The most common way to build a complex expression out of simpler expressions is
with an /operator/.  An operator comb`ines the values of its /operands/
(usually two of them) in some way and evaluates to a new value.  For
simplicity, we sometimes say that an operator /returns/ a value rather than
“evaluates to” a value.

This chapter documents all of JavaScript’s operators, and it also explains
expressions (such as array indexing and function invocation) that do not use
operators.

**** Primary Expressions

**** Object and Array Initializers

**** Function Definition Expressions

**** Property Access Expressions

**** Invocation Expressions

**** Object Creation Expressions

**** Operator Overview

**** Arithmetic Expressions

**** Relational Expressions

**** Logical Expressions

**** Assignment Expressions

**** Evaluation Expressions

**** Miscellaneous Operators

*** Statements
#+cindex:Chapter 5 Statements
#+cindex:statements
/Statements/ are JavaScript sentences or commands.  Just as English sentences
are terminated and separated from each other with periods, JavaScript
statements are terminated with semicolons.  Expressions are /evaluated/ to
produce a value, but statements are /executed/ to make something happen.

{{{heading(Side Effects)}}}

#+cindex:side effect
#+cindex:expression statement
#+cindex:declaration statement
#+cindex:statements, types
One way to “make something happen” is to evaluate an expression that has side
effects.  Expressions with side effects, such as /assignments/ and /function
invocations/, can stand alone as statements, and when used this way they are
known as /expression statements/.  A similar category of statements are the
/declaration statements/ that /declare/ new variables and /define/ new
functions.

{{{heading(Control Structures)}}}

#+cindex:control structures
JavaScript programs are nothing more than a sequence of statements to execute.
By default, the JavaScript interpreter executes these statements one after
another in the order they are written.  Another way to “make something happen”
is to alter this default order of execution, and JavaScript has a number of
statements or /control structures/ that do just this:

#+cindex:conditionals
- /Conditionals/ are statements like ~if~ and ~switch~; that make the JavaScript
  interpreter execute or skip other statements depending on the value of an
  expression.

  #+cindex:loops
- /Loops/ are statements like ~while~ and ~for~ that execute other statements
  repetitively.

  #+cindex:jumps
- /Jumps/ are statements like ~break~, ~return~, and ~throw~ that cause the
  interpreter to jump to another part of the program.


The sections that follow describe the various statements in JavaScript and
explain their syntax.

**** Expression Statements

**** Compound and Empty Statements

**** Declaration Statements

**** Conditionals

**** Loops

**** Jumps

**** Miscellaneous Statements

**** Summary of JavaScript Statements

*** Objects
#+cindex:Chapter 6 Objects
#+cindex:objects, intro
JavaScript’s fundamental datatype is the /object/.

#+cindex:composite value, object
- An object is a /composite value/: it aggregates multiple values (primitive
  values or other objects) and allows you to store and retrieve those values by
  name.

  #+cindex:unordered collection of properties, object
- An object is an /unordered collection of properties/, each of which has a
  name and a value.  Property names are strings, so we can say that objects map
  strings to values.

  #+cindex:protoype object
  #+cindex:protoypal inheritance
- An object is more than a simple string- to-value map, however.  In addition
  to maintaining its own set of properties, a JavaScript object also inherits
  the properties of another object, known as its “prototype.”  The methods of
  an object are typically inherited properties, and this “prototypal inheri-
  tance” is a key feature of JavaScript.

  #+cindex:dynamic, objects
  #+cindex:objects, dynamic
  #+cindex:static objects, structs
- JavaScript objects are /dynamic/---properties can usually be added and
  deleted---but they can be used to simulate the static objects and “structs”
  of statically typed languages.  They can also be used (by ignoring the value
  part of the string-to-value mapping) to represent sets of strings.

  #+cindex:object value
- Any value in JavaScript that is not a string, a number, true, false, =null=,
  or =undefined= is an object.  And even though strings, numbers, and booleans
  are not objects, they behave like immutable objects

- The most common things to do with objects are /create/ them and to /set/,
  /query/, /delete/, /test/, and /enumerate/ their properties.

  #+cindex:property as string
  #+cindex:value of object
  #+cindex:getter function
  #+cindex:setter function
- A /property/ has a name and a value.

  - A /property name/ may be any string, including the empty string, but no
    object may have two properties with the same name.

  - The /value/ may be any JavaScript value, or (in ECMAScript 5) it may be a
    getter or a setter function (or both).

{{{heading(Property Attributes)}}}

  #+cindex:property attributes
- In addition to its name and value, each property has associated values that
  we’ll call /property attributes/:

    #+cindex:writable attribute
  - The /writable attribute/ specifies whether the value of the property can be
    set.

    #+cindex:enumerable attribute
  - The /enumerable attribute/ specifies whether the property name is returned
    by a for/in loop.

    #+cindex:configurable attribute
  - The /configurable attribute/ specifies whether the property can be deleted
    and whether its attributes can be altered.

  #+cindex:ECMAScript 5 feature
  #+cindex:configure attributes
- Prior to ECMAScript 5, all properties in objects created by your code are
  writable, enumerable, and configurable.  In ECMAScript 5, you can configure
  the attributes of your properties.

{{{heading(Object Attributes)}}}

  #+cindex:object properties
- In addition to its properties, every object has three associated /object
  attributes/:

  #+cindex:prototype reference
  - An object’s /prototype/ is a reference to another object from which
    properties are inherited.

    #+cindex:object class
  - An object’s /class/ is a string that categorizes the type of an object.

    #+cindex:extensible flag
    #+cindex:ECMAScript 5 feature
  - An object’s /extensible flag/ specifies (in ECMAScript 5) whether new
    properties may be added to the object.


Finally, here are some terms we’ll use to distinguish among three broad
categories of JavaScript objects and two types of properties:

 #+cindex:native object 
- A /native object/ is an object or class of objects defined by the ECMAScript
  specifi- cation. Arrays, functions, dates, and regular expressions (for
  example) are native objects.

  #+cindex:host object
- A /host object/ is an object defined by the host environment (such as a web
  browser) within which the JavaScript interpreter is embedded. The HTMLElement
  objects that represent the structure of a web page in client-side JavaScript
  are host objects. Host objects may also be native objects, as when the host
  environment defines methods that are normal JavaScript Function objects.

  #+cindex:user-defined object
- A /user-defined/ object is any object created by the execution of JavaScript
  code.

  #+cindex:own property
- An /own property/ is a property defined directly on an object.

  #+cindex:inherited property
- An /inherited property/ is a property defined by an object’s prototype
  object.
*** Arrays

*** Functions

*** Classes and Modules

*** Regular Expressions

*** JavaScript Subsets and Extensions

*** Server-Side JavaScript

** Client-Side JavaScript

*** JavaScript in Web Browsers

*** The Window Object

*** Scripting Documents

*** Scripting CSS

*** Handling Events

*** Scripted HTTP

*** The jQuery Library

*** Client-Side Storage

*** Scripted Media and Graphics

*** HTML5 APIs

** Core API Reference

** Client-Side JavaScript Reference
* Secrets of the JavaScript Ninja
:PROPERTIES:
:Author:   John Resig
:Author+:  Bear Bibeault
:Published: 2013
:Publisher: Manning Publications Co.
:ISBN:     978-1-933988-69-6
:Pages:    392
:URI:      https://www.manning.com/books/secrets-of-the-javascript-ninja
:END:

- https://livebook.manning.com/#!/book/secrets-of-the-javascript-ninja/table-of-contents/

** Front Matter
:PROPERTIES:
:unnumbered: t
:END:
#+texinfo:@insertcopying
*** Copying
:PROPERTIES:
:copying:  t
:unnumbered: t
:END:
\copy2013 by Manning Publications Co. All rights reserved.

#+HTML:<pre>
#+begin_display
Manning Publications Co.
20 Baldwin Road
PO Box 261
Shelter Island, NY 11964
#+end_display
#+HTML:</pre>

*** Preface

{{{heading(In-Depth Coverage Topics)}}}

A real need for in-depth coverage of the most important parts of the JavaScript
language:
#+cindex:functions
- functions
  #+cindex:closures
- closures
  #+cindex:protyptes
- prototypes
  #+cindex:cross-browser code
- cross-browser code


{{{heading(The Fundamentals)}}}

There isn’t any point to diving into new technologies if you don’t have a
proper understanding of the fundamental characteristics of the JavaScript
language.  The reality is that most development needs to make sure that code
continues to work in the majority of browsers and for the majority of potential
users.

{{{heading(jQuery)}}}

#+cindex:jQuery
Perhaps the largest change that came to jQuery as a result of writing this book
was a complete overhaul from using browser-specific sniffing to using feature
detection at the core of the library.  This has enabled jQuery to be used
almost indefinitely, without assuming that browsers would always have specific
bugs or be missing specific features.

#+cindex:cross-browser capabilities
Using the techniques outlined in this book, jQuery’s cross-browser capabilities
provide a fairly solid guarantee that code written with jQuery will work in a
maximum number of browser environments.  This guarantee has led to explosive
growth in jQuery over the past four years, with it now being used in over 57%
of the top 10,000 websites on the Internet, according to BuiltWith.com.

{{{heading(New JS-Based Languages)}}}

#+cindex:CoffeeScript
#+cindex:Processing.js
#+cindex:ECMAScript specification
There are now a number of active programming languages that are built on top
of, or compiled to, JavaScript, such as CoffeeScript and Processing.js.  These
languages require complex language parsing, code evaluation, and scope
manipulation in order to work effectively.  Although dynamic code evaluation
has been maligned due to its complexity and potential for security issues,
without it we wouldn’t have had the CoffeeScript programming language, which
has gone on to influence the upcoming ECMAScript specification itself.

{{{heading(The Future)}}}

#+cindex:browser APIs
The future for browser development continues to be very strong, and it’s
largely due to the features encapsulated in JavaScript and in the browser APIs.
Having a solid grasp of the most crucial parts of the JavaScript language,
combined with a desire for writing code that’ll work in many browsers, will
enable you to create code that’s elegant, fast, and ubiquitous.

*** About this Book
Web developers need to have a sound grasp of the language that brings life to
web applications.

#+cindex:Rhino
#+cindex:V8
#+cindex:Node.js
JavaScript isn’t just for browsers anymore.  The language has knocked down the
walls of the browser and is being used on the server in engines such as Rhino
and V8, and in frameworks like Node.js.

Although this book is primarily focused on JavaScript for web applications, the
fundamentals of the language presented in [[*Part 2---Apprentice Training][Part 2]] of this book are applicable
across the board.

It’s now more important than ever that they grasp its fundamentals, so that
they can become true ninjas of the language.

{{{heading(Intended Audience)}}}

#+cindex:
This book is aimed at web developers who already have at least a basic grasp of
JavaScript.
- You should understand the basic structure of JavaScript statements and
- how they work to create straightforward on-page scripts.
- You don’t need to be an advanced user of the language---that’s what this book
  is for---but
- you shouldn’t be a rank novice.
- You should also have a working knowledge of HTML and CSS.
- You should know the basics of putting a web page together.


{{{heading(Recommended Prerequisite Materials)}}}

#+cindex:recommended reading
#+cindex:prerequisite reading
#+cindex:JavaScript: The Definitive Guide
#+cindex:Flanagan, David
#+cindex:JavaScript: The Good Parts
#+cindex:Crockford, Douglas
#+cindex:Head First JavaScript
#+cindex:Morrison, Michael
- /JavaScript: The Definitive Guide/ by David Flanagan
- /JavaScript: The Good Parts/ by Douglas Crockford
- /Head First JavaScript/ by Michael Morrison.
- /Head First JavaScript Programming/ by Elizabeth Robson and Eric Freeman
  (This book replaces /Head First JavaScript/)

**** Roadmap
This book is organized to take you from an apprentice to a ninja in four parts.

1. [[*Part 1---Preparing for Training][Part 1]] introduces the topic and some tools we’ll need as we progress through
   the rest of the book.

   #+cindex:advanced web applications, problems
   - [[*Enter the Ninja][Chapter 1]] introduces us to the challenges that we face as writers of
     advanced web applications.  It presents some of the problems that the
     proliferation of browsers creates, and suggests best current practices
     that we should follow when developing our applications, including testing
     and performance analysis.

     #+cindex:testing
     #+cindex:test tools
     #+cindex:assert
   - [[*Arming with Testing and Debugging][Chapter 2]] discusses testing, taking a look at the current state of testing
     and test tools.  It also introduces a small but powerful testing concept,
     the ~assert~, which will be used extensively throughout the remainder of
     the book to make sure that our code does what we think it should be doing
     (or sometimes to prove that it doesn’t!).

     #+cindex:JavaScript fundamentals
2. [[*Part 2---Apprentice Training][Part 2]] focuses on JavaScript fundamentals: aspects of the language that you
   take for granted but aren’t really sure how they work.  This may be the most
   important part of the book, and even if it’s all you read, you’ll come away
   with a much sounder understanding of JavaScript, the language.

   #+cindex:functions
   #+cindex:functional language
   - Armed with these tools, [[*Functions are Fundamental][chapter 3]] begins our foray into the fundamentals
     of the language, starting, perhaps to your surprise, with a thorough
     examination of the function as defined by JavaScript.  Although you might
     have expected the object to be the target of first focus, it’s a solid
     understanding of the function, and JavaScript as a functional language,
     that begins our transformation from run-of-the-mill JavaScript coders to
     JavaScript ninjas!

     #+cindex:recursion
     #+cindex:variable argument lists
     #+cindex:overload functions
     #+cindex:method overloading
     #+cindex:functional programming
   - Not being done with functions quite yet, [[*Wielding Functions][chapter 4]] takes the fundamentals
     we learned in chapter 3 and applies them to problems we face in creating
     our applications.  We’ll explore recursion—not only for its own sake, but
     because we can learn a lot more about functions through scrutinizing
     it---and we’ll learn how the functional programming aspects of JavaScript
     can be applied to not only make our code elegant, but also more robust and
     succinct.  We’ll learn ways to deal with variable argument lists, and ways
     to overload functions in a language that doesn’t natively support the
     object-oriented concept of method overloading.

     #+cindex:closures
     #+cindex:functional programming
     #+cindex:scope
   - One of the most important concepts you can take away from this book is the
     subject of [[*Object-orientation with Prototypes][chapter 5]]: closures.  A key concept in functional programming,
     closures allow us to exert fine-grained control over the scope of objects
     that we declare and create in our programs.  The control of these scopes
     is the key factor in writing code worthy of a ninja.  Even if you stop
     reading after this chapter (but we hope that you don’t), you’ll be a far
     better JavaScript developer than when you started.

     #+cindex:objects
     #+cindex:prototype property
     #+cindex:functions and the prototype property
   - Objects are finally addressed in [[*Object-orientation with Prototypes][chapter 6]], where we learn how patterns of
     objects can be created through the prototype property of the function, and
     we’ll learn how objects are tied to functions for their definitions---one
     of the many reasons we discussed functions first.

     #+cindex:regular expressions
   - [[*Wrangling Regular Expressions][Chapter 7]] focuses on the regular expression, an often-overlooked feature
     of the language that can do the work of scores of lines of code when used
     correctly.  We’ll learn how to construct and use regular expressions and
     how to solve some recurring problems elegantly, using regular expressions
     and the methods that work with them.

     #+cindex:timers
     #+cindex:intervals
     #+cindex:single-threaded model
     #+cindex:HTML5
     #+cindex:web workers
   - Part 2 on language fundamentals closes out with [[*Taming Threads and Timers][chapter 8]], in which we
     learn how timers and intervals work in the single-threaded nature of
     JavaScript.  HTML5 promises to bring us relief from the confines of the
     single thread with web workers, but most browsers aren’t quite there yet,
     and virtually all of the existing JavaScript code depends upon a good
     understanding of JavaScript’s single-threaded model.

     #+cindex:problems, solve
3. In [[*Part 3---Ninja Training][part 3]], we dive into using the fundamentals that we learned in part 2 to
   solve knotty problems that the browsers throw at us.

   #+cindex:runtime code evaluation
   #+cindex:evaluate code while running
   #+cindex:JSON evaluation
   #+cindex:metalanguages
   #+cindex:domain-specific languages
   #+cindex:compression
   #+cindex:obfuscation
   #+cindex:aspect-oriented programming
   - Part 3 opens with [[*Ninja Alchemy - Runtime Code Evaluation][chapter 9]], in which we open the black box of
     JavaScript’s runtime code evaluation.  We’ll look at various ways to
     evaluate code on the fly, including how to do so safely and in the scope
     of our choosing.  Real-world examples, such as JSON evaluation,
     metalanguages (a.k.a. domain-specific languages), compression and
     obfuscation, and even aspect-oriented programming, are discussed.

     #+cindex:with statement
   - In [[*=with= Statements][chapter 10]], we examine the controversial ~with~ statement, which is
     used to shorten references within a scope.  Whether you are a fan or
     detractor of ~with~, it exists in a lot of code in the wild, and you
     should understand it regardless of whether you think it’s the bomb or an
     abomination.

     #+cindex:cross-browser issues
     #+cindex:browser differences
     #+cindex:browser bugs,fixes
     #+cindex:browers, missing features
     #+cindex:feature simulation
     #+cindex:object detection
   - Dealing with cross-browser issues is the subject of [[*Developing Cross-Browser Strategies][chapter 11]].  We
     examine the five key development concerns with regard to these issues:
     browser differences, bugs and bug fixes, external code and markup, missing
     features, and regressions.  Strategies such as feature simulation and
     object detection are discussed at length to help us deal with these
     cross-browser challenges.

     #+cindex:element attributes, properties
     #+cindex:attributes
     #+cindex:properties
     #+cindex:styles
   - Handling element attributes, properties, and styles is the focus of
     [[*Cutting Through Attributes-Properties-and CSS][chapter 12]].  While the differences in how the various browsers handle these
     aspects of elements are slowly converging over time, there still exists a
     number of knotty problems that this chapter describes how to solve.

     #+cindex:event handling
     #+cindex:custom events
     #+cindex:event delegation
   - Part 3 concludes in [[*Surviving Events][chapter 13]] with a thorough investigation of event
     handling in the browsers and ways to create a unified subsystem that
     handles events in a browser-agnostic manner.  This includes adding features
     not provided by the browsers, such as custom events and event delegation.

   #+cindex:advanced topics
   #+cindex:jQuery library
4. [[*Part 4---Master Training][Part 4]] wraps up the book with a look at advanced topics focusing on lessons
   learned from the creation of advanced JavaScript libraries, such as jQuery.

   #+cindex:DOM manipulation APIs
   #+cindex:Document Object Model
   #+cindex:manipulate DOM at runtime
   #+cindex:injecting elements into the DOM
   - In part 4 we pick up the pace and delve deeply into advanced topics taken
     from the heart of JavaScript libraries such as jQuery.  [[*Manipulating the DOM][Chapter 14]]
     discusses how DOM manipulation APIs can be constructed to manipulate the
     Document Object Model at runtime, including the Gordian knot of injecting
     new elements into the DOM.

     #+cindex:CSS selector engines
   - Finally, in [[*CSS Selector Engines][chapter 15]], we discuss how CSS selector engines are
     constructed and the different ways in which they parse and evaluate
     selectors.  Not for the faint of heart, this chapter, but it’s a worthy
     final test of your ninja-hood.

**** Code Downloads
#+cindex:source code
#+cindex:download source code
Source code for all the working examples in this book (along with some extras
that never made it into the text) is available for [[https://www.manning.com/SecretsoftheJavaScriptNinja][download from the book’s web
page]].

#+cindex:Apache server
The code examples for this book are organized by chapter, with separate folders
for each chapter.  The layout is ready to be served by a local web server, such
as the Apache HTTP Server.  Simply unzip the downloaded code into a folder of
your choice and make that folder the document root of the application.  Most of
the examples don’t require the presence of a web server at all and can be
loaded directly into a browser for execution.

*** About the Authors

**** John Resig

#+cindex:Resig, John
#+cindex:Khan Academy
- Dean of Computer Science at Khan Academy
  - Khan Academy’s goal is to create excellent educational resources that are
    freely available for all to learn from
  #+cindex:jQuery library
- creator of the jQuery JavaScript library
  #+cindex:open source
- also created a number of other open source utilities and projects, including
    #+cindex:Processing.js
  - Processing.js (a port of the Processing language to JavaScript)
    #+cindex:QUnit
    #+cindex:test suite, QUnit
  - QUnit (a test suite for testing JavaScript code)
    #+cindex:TestSwarm
    #+cindex:testing, distributed
  - TestSwarm (a platform for distributed JavaScript testing)

**** Bear Bibeault

#+cindex:Bibeault, Bear
#+cindex:books
Bear is the author of a number of other Manning books:
#+cindex:jQuery in Action
- /jQuery in Action/ (first and second editions)
  #+cindex:Ajax in Practice
- /Ajax in Practice/
  #+cindex:Prototype and Scriptaculous in Action
- /Prototype and Scriptaculous in Action/

** Part 1---Preparing for Training
This part of the book will set the stage for your JavaScript ninja training.

In [[*Enter the Ninja][chapter 1]], you’ll learn what we’re trying to accomplish with this book, and
we’ll lay the framework for the environment in which JavaScript authors
operate.

[[*Arming with Testing and Debugging][Chapter 2]] will teach you why testing is so important and give you a brief
survey of some of the testing tools available. Then we’ll develop some
surprisingly simple testing tools that you’ll use throughout the rest of your
training.

*** Enter the Ninja
:PROPERTIES:
:chapter:  1
:END:

Chapter topics:

- A look at the purpose and structure of this book

- Which libraries we’ll look at

- What is “advanced” JavaScript programming?

- Cross-browser authoring

- Test suite examples


#+cindex:cross-browser JavaScript code
#+cindex:libraries, JavaScript
There’s nothing simple about creating effective and cross-browser JavaScript
code.  In addition to the normal challenges of writing clean code, we have the
added complexity of dealing with obtuse browser differences and complexities.
To deal with these challenges, JavaScript developers frequently /capture sets
of common and reusable functionality/ in the form of JavaScript libraries.

- JavaScript Libraries---sets of common and reusable functionality

- they need to be easy to use,

- incur the least amount of overhead, and

- be able to work across all browsers that we wish to target.


Understanding how the very best JavaScript libraries are constructed can
provide us with great insight into how our own code can be constructed to
achieve these same goals.

/This book sets out to uncover the techniques and secrets used by these
world-class code bases and to gather them into a single resource./ In this book
we’ll be examining the techniques that were (and continue to be) used to create
the popular JavaScript libraries.

#+cindex:techniques, examine
/This book sets out to uncover the techniques and secrets used by these
world-class code bases and to gather them into a single resource/.  In this
book we’ll be examining the techniques that were (and continue to be) used to
create the popular JavaScript libraries.

**** The JavaScript libraries we’ll be tapping
The techniques and practices used to create modern JavaScript libraries will be
the focus of our attention in this book.  The primary library that we’ll be
considering is *jQuery*, which has risen in prominence to be the most
ubiquitous JavaScript library in modern use.

#+cindex:jQuery
[[http://jquery.com][jQuery]] was created by John Resig and released in January of 2006.  jQuery
popularized the use of CSS selectors to match DOM content.  Among its many
capabilities, it provides

- DOM manipulation,
- Ajax,
- event handling, and
- animation functionality.


In addition to examining example code from jQuery, we’ll also look at
techniques utilized by the following libraries:

#+cindex:Prototype
- [[http://prototypejs.org/][Prototype]] :: The godfather of the modern JavaScript libraries, created by Sam
     Stephenson and released in 2005.  This library embodies DOM, Ajax, and
     event functionality, in addition to object-oriented, aspect-oriented, and
     functional programming techniques.

  #+cindex:Yahoo! UI
- [[http://developer.yahoo.com/yui][Yahoo! UI]] :: The result of internal JavaScript framework development at
     Yahoo! and released to the public in February of 2006.  Yahoo! UI (YUI)
     includes DOM, Ajax, event, and animation capabilities in addition to a
     number of preconstructed widgets (calendar, grid, accordion, and others).

  #+cindex:base2
  #+cindex:Edwards, Dean
- [[http://code.google.com/p/base2][base2]] :: Created by Dean Edwards and released in March 2007.  This library
     supports DOM and event functionality.  Its claim to fame is that it
     attempts to implement the various W3C specifications in a universal,
     cross-browser manner.


These techniques aren’t only useful for constructing large libraries; they can
be applied to all JavaScript coding, regardless of size.

#+cindex:JavaScript library, makeup
The makeup of a JavaScript library can be broken down into three aspects:

- Advanced use of the JavaScript language

- Meticulous construction of cross-browser code

- The use of current best practices that tie everything together


We’ll be carefully analyzing these three aspects in each of the libraries to
gather a complete knowledge base we can use to create our own effective
JavaScript code.

**** Understanding the JavaScript language

{{{heading(Objects---Functions---Closures)}}}

JavaScript consists of a close relationship between:
- objects,
- functions, and
- closures

#+caption:JavaScript consists of a close relationship between objects, functions, and closures.
#+name:fig-JS-objects-functions-closures
[[https://dpzbhybb2pdcj.cloudfront.net/resig/Figures/01fig01.jpg]]

Understanding the strong relationship between these three concepts can vastly
improve our JavaScript programming ability, giving us a strong foundation for
any type of application development.

{{{heading(Timers---Regular Expressions)}}}

#+cindex:timers
#+cindex:regular expressions
In addition to these fundamental concepts, there are two features in JavaScript
that are woefully underused:

- timers; and

- regular expressions.


These two concepts have applications in virtually any JavaScript code base, but
they aren’t always used to their full potential due to their misunderstood
nature.  A firm grasp of how /timers/ operate within the browser, all too
frequently a mystery, gives us the ability to tackle complex coding tasks such
as long-running computations and smooth animations.  And a sound understanding
of how /regular expressions/ work allows us to simplify what would otherwise be
quite complicated pieces of code.

{{{heading(The ~with~ Statement---The ~eval()~ Method)}}}

#+cindex:@code{with} statement
#+cindex:@code{eval()} method
As another high point of our advanced tour of the JavaScript language, we’ll
take a look at the ~with~ statement in chapter 10, and the divisive ~eval()~
method in chapter 9---two important, but controversial, language features that
have been trivialized, misused, and even condemned outright by many JavaScript
programmers.

**** Cross-Browser Considerations
When developing browser-based JavaScript applications (which is the focus of
this book), sooner rather than later, we’re going to run face first into The
Browsers and their maddening issues and inconsistencies.

The quality of browsers has improved greatly as of late, but they all still
have some bugs, missing APIs, and browser-specific quirks that we’ll need top
deal with.  Developing a comprehensive strategy for tackling these browser
issues, and becoming intimately familiar with their differences and quirks, is
just as important, if not more so, than proficiency in JavaScript itself.

When writing browser applications or JavaScript libraries to be used in them,
picking and choosing which browsers to support is an important consideration.
We’d probably like to support them all, but limitations on development and
testing resources dictate otherwise.  So how do we decide which to support, and
to what level?

...

**** Current best practices
#+cindex:best practices
To enter the big leagues, you also need to exhibit the traits that scores of
previous developers have proved are beneficial to the development of quality
code.  These traits, which we’ll examine in depth in chapter 2, are known as
/best practices/ and, in addition to mastery of the language, include such
elements as:

#+cindex:testing
- Testing

  #+cindex:performance analysis
- Performance analysis

  #+cindex:debugging skills
- Debugging skills

***** Current best practice---testing

***** Current best practice---performance analysis

*** Arming with Testing and Debugging
:PROPERTIES:
:chapter:  2
:END:

** Part 2---Apprentice Training

*** Functions are Fundamental

*** Wielding Functions

*** Closing in on Closures

*** Object-orientation with Prototypes

*** Wrangling Regular Expressions

*** Taming Threads and Timers

** Part 3---Ninja Training

*** Ninja Alchemy - Runtime Code Evaluation

*** =with= Statements

*** Developing Cross-Browser Strategies

*** Cutting Through Attributes-Properties-and CSS
*** Surviving Events

** Part 4---Master Training

*** Manipulating the DOM

*** CSS Selector Engines

** End Matter

** Concept Index
:PROPERTIES:
:index:    cp
:unnumbered: t
:END:
* Variants
** TypeScript

- http://www.typescriptlang.org
- https://github.com/Microsoft/TypeScript

- http://jonathancreamer.com/why-would-you-not-use-typescript/

- https://medium.jonasbandi.net/here-is-why-you-might-not-want-to-use-typescript-part-1-alternatives-ec1248bb6dc
- https://medium.jonasbandi.net/here-is-why-you-might-not-want-to-use-typescript-part-2-typescript-adds-overhead-20b670b9105a
- https://medium.jonasbandi.net/here-is-why-you-might-not-want-to-use-typescript-50ab0d225bdd

- https://medium.jonasbandi.net/hidden-features-of-create-react-app-52db3a17acc0

** PureScript

- http://www.purescript.org
- https://github.com/purescript


#+begin_quote
"A small strongly, statically typed language which compiles to Javascript"
#+end_quote

- https://survivejs.com/blog/purescript-interview/

** TypeScript vs Purescript

- https://blog.logrocket.com/typescript-vs-purescript-not-all-compilers-are-created-equal-c16dadaa7d3e/

- https://www.slant.co/versus/378/389/~typescript_vs_purescript

** Elm

- https://elm-lang.org
- https://github.com/elm


#+begin_quote
"Elm is a domain-specific programming language for declaratively creating web
browser-based graphical user interfaces.  Elm is purely functional, and is
developed with emphasis on usability, performance, and robustness.  It
advertises "no runtime exceptions in practice", made possible by the Elm
compiler's static type checking."
#+end_quote

- Designed By :: Evan Czaplicki
- First Appeared :: 2012
- Influenced By :: Haskell, Standard ML, OCaml, F#

** Reason---Facebook

"Reason lets you write simple, fast and quality type safe code while leveraging
both the JavaScript & OCaml ecosystems."

- https://reasonml.github.io
- https://github.com/facebook/reason


#+begin_quote
"Reason, also known as ReasonML, is a syntax extension and toolchain for OCaml
created by Jordan Walke at Facebook.  Reason offers a syntax familiar to
JavaScript programmers, and transpiles to OCaml.  Statically typed Reason (or
OCaml) code may be compiled to dynamically typed JavaScript using the
BuckleScript compiler."
#+end_quote

- Designed By :: Jordan Walke
- First Appeared :: May 16, 2016
- Influenced By :: OCaml

** Flow

"Flow is a static type checker for JavaScript."

- https://flow.org
- https://github.com/facebook/flow

** Dart---Google---Ecma TC52

"Dart is a client-optimized language for fast apps on any platform."

- https://dart.dev
- https://github.com/dart-lang
- https://www.dartlang.org/guides/language/spec


#+begin_quote
Dart is a client-optimized programming language for fast apps on multiple
platforms.  It is developed by Google and is used to build mobile, desktop,
backend and web applications.

Dart is an object-oriented, class defined, garbage-collected language using a
C-style syntax that transcompiles optionally into JavaScript.  It supports
interfaces, mixins, abstract classes, reified generics, static typing, and a
sound type system.
#+end_quote

- Designed By :: Lars Bak and Kasper Lund
- First Appeared :: October 10, 2011
- Influenced By :: C#, Erlang, JavaScript, Smalltalk, Strongtalk

* Concept Index
:PROPERTIES:
:index:    cp
:unnumbered: t
:END:

* Footnotes

[fn:5] Roughly 2000--2010

[fn:1] Except "use strict"

[fn:2] Except leading zeroes in parseInt

[fn:3] Partially supported by all browsers

[fn:4] This page was last modified on 9 October 2011, at 19:22.

* Export Settings                                                  :noexport:
** Macro Definitions
#+macro:heading @@html:<h2>@@@@texinfo:@heading @@$1@@html:</h2>@@
#+macro:subheading @@html:<h3>@@@@texinfo:@subheading @@$1@@html:</h3>@@

** Export to HTML
*** HTML Options
#+OPTIONS: html-link-use-abs-url:nil html-postamble:auto html-preamble:t H:6
#+OPTIONS: html-scripts:t html-style:t html5-fancy:t tex:t ':t broken-links:mark

*** HTML Export Settings
#+export_file_name: ecmascript_262.html
#+html_doctype: html5
#+html_container: div
#+description:
#+keywords:
#+html_link_home:
#+html_link_up:
#+html_mathjax:
#+html_head:
#+html_head_extra:
#+subtitle:Version {{{version}}} Lasted Updated {{{date}}}
#+infojs_opt:
#+creator: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 26.1 (<a href="https://orgmode.org">Org</a> mode 9.1.14)
#+latex_header:

** Export to Texinfo
*** Texinfo Export Settings
#+texinfo_filename:ecmascript_262.info
#+texinfo_class: info
#+texinfo_header:
#+texinfo_post_header:
#+subtitle:
#+subauthor:
#+texinfo_dir_category:JavaScript
#+texinfo_dir_title:Secrets of the JavaScript Ninja
#+texinfo_dir_desc:Training in the JavaScript language
#+texinfo_printed_title:Secrets of the JavaScript Ninja

* Local Variables                                                  :noexport:
# Local Variables:
# fill-column: 79
# time-stamp-pattern: "8/^\\#\\+Date:%:y-%02m-%02d %02H:%02M$"
# eval: (setq org-publish-project-alist '(("ecmascript_262" :base-directory "." :publishing-directory "./public_html" :publishing-function org-html-publish-to-html :section-numbers t :table-of-contents t)))
# End:
